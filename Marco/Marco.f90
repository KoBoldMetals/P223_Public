!    PROGRAM Marco
!------------------------------------------------------------------------------------
Module MG_Metadata
!--------------
! 
! Module designed to hold 'constant character options'
    Implicit NONE

    Character (Len = 40), Parameter :: PNAME = 'Marco'
    Character (Len = 40), Parameter :: PVERS = '5.0.1'
    Character (Len = 40), Parameter :: PDATE = '08 February, 2021'
    Character (Len = 40), Parameter :: PAUT1 = 'CSIRO Electromagnetic Modelling Group'
    Character (Len = 40), Parameter :: PAUT2 = 'Zonghou Xiong, Art Raiche'
    Character (Len = 40), Parameter :: PAUT3 = 'David Annetts (david.annetts@csiro.au)'
    Character (Len = 40), Parameter :: PPROJ = 'AMIRA P223D'
    Character (Len = 80), Parameter :: PRELS = 'GPL-2.0 (Full text at https://opensource.org/licenses/gpl-2.0.php)'

End Module MG_Metadata
!------------------------------------------------------------------------------------
!
! 5.0.0
!
!	1.	Removed symmetry checks. These were critical in when memory was limited. However, in
!		2020, they prove more trouble than they are worth when the major limiting factor
!		is CPU speed and memory is O(GB) not O(kB).
!	2.	
!
!********************
!   DESCRIPTION     *
!********************
!
!  Within a multi-layered earth, Marco computes the frequency domain and/or
!  the time domain responses for any arbitrary structure which can be
!  composed of multiple rectilinear prisms oriented parallel to the three
!  component axes.
!  Cole-Cole resistivities may be specified for target and layers.
!  Receivers may be in air, downhole, or on the surface of the earth.
!
!  Marco also computes high frequency radio imaging responses for grounded
!  sources and downhole magnetic dipole sources.
!
!  Marco uses multiple prismatic blocks to simulate arbitrary structures.
!  The conductivity in each block can be arbitrary or constant.  The
!  program also allows symmetric structures with two symmetry planes,
!  the (XOZ) and (YOZ) planes, with the shape and conductivity of the
!  structure in one quadrant being arbitrary.  Symmetrical considerations
!  greatly saves both computation time and storage requirements.
!
!  This program uses a system iterative method for solving the matrix
!  equation,  thus it allows a large number of cells to be handled for
!  large and complex structures.  The division of substructures are
!  done automatically by the program itself if the number of cells for the
!  structure or for one quadrant of a symmetric structure exceeds defined
!  limits for a single scattering matrix.  There is in fact no limit on
!  the total number of cells to be computed by this program.  If the
!  structure is discretized into equal sized cells that fit in a uniform
!  grid, the program will invoke spatial symmetry reductions to speed up
!  the computation for the Green's functions.  The spatial symmetry
!  reductions also enable fast re-computation of all matrix elements,
!  which in conjunction with the method of system iteration allows tens,
!  or even hundreds of thousands of cells.  Thus there is no limit on the
!  size of the models to be computed,  as long as there is available
!  computer time.
!
!  This current version of Marco is however restricted to conductivity
!  contrasts of up to about 1000 to 1 between the 3D target and its
!  immediate host.
!
!
!*************************
!   NEW FILE CONVENTIONS *
!*************************
!
!   The input control file, now called Marco.cfl is read
!   from logical unit number 3.
!
!   The output data file, now called Marco.out is written
!   to logical unit number 4.
!
!   Frequency-domain data, now called Marco.frq data is written
!   to logical unit number 7.
!
!   The AMIRA format file, now called Marco.AMR, is written
!   to logical unit number 22.
!
!    UNIT #   UNIT ID      FILE ID           FUNCTION
!    ------   -------      -------           --------
!      3        NR       Marco.cfl    Input control file
!      4        NW       Marco.out    Time or frequency-domain output data
!      7        ND       Marco.frq    Frequency-domain data for TDEM reuse
!      22       NA       Marco.amx    Output data in extended AMIRA format
!
!  These unit numbers are set at the start of the MAIN program
!  and can be changed to suit the users host computer.
!
!
!*******************
!  USEFUL FEATURES *
!*******************
!
!  For time-domain applications, the frequency- domain results are written
!  UNIT 7 to a file called Marco.frq.
!  This allows the user to experiment with different transmitter waveforms
!  and receiver windows without re-running the entire frequency-domain
!  computation as long as the model and Tx-Rx geometry remain the same.
!  Specifying NTEM3D = 2 in RECORD 4 will accomplish this.
!  Scattered fields can now be printed by specifying NTEM3D as a negative
!  integer; i.e., NTEM3D = -1 or -2.
!
!
!  MARCO allows the user to model a layered half-spaces of up to 20 layers.
!
!
!*********************
!  TECHNICAL ASPECTS *
!*********************
!
!  The time-domain response is computed by first calculating the
!  frequency-domain response from 0.1 Hz to 100 kHz at an interval
!  of six frequencies per decade.  A cubic spline interpolation of
!  the imaginary component of the magnetic field is used to
!  represent the frequency-domain response over the whole spectrum.
!
!  The time domain-magnetic fields are computed using digital
!  filter coefficients which had been derived from the fast Hankel
!  transform program of Johansen and Sorensen.  A spline is fit to
!  the time-domain magnetic fields and db/dt is computed using the
!  spline coefficients.  This is then convolved with the source
!  function to give the field voltages (area * db/dt).
!
!  Marco avoids a problem which can arise from using representing the
!  normal field from the transmitter loop as a line integration of
!  horizontal electric dipoles.  The dipoles one opposite sides of the loop
!  contribute fields of opposite sign.  At late times, these have the same
!  magnitude so that the sum produces numerical chaos.  Before this
!  happens, the "smoke ring" passes the transmitter boundary which means
!  that the transmitter acts like a single vertical magnetic dipole.  An
!  even more accurate approximation at this point is to use the response
!  from a circular loop of equal area.  These computations do not suffer
!  from numerical instability at late times.
!  This version tests for this condition and switches representation
!  before numerical chaos sets in.  This will affect the horizontal
!  fields more than the vertical ones.
!
!
!***************************************************************************
!************         DESCRIPTION OF DATA RECORDS            ***************
!***************************************************************************
!
!  All records are in list directed (free) format except for
!  the TITLE in RECORD 1.
!
!    NOTE:  All distances and locations are to be specified in metres.
!    ----   All angles are to be specified in degrees.
!
!      In plan view, the coordinate system used for input and output
!      has X positive to the North and Y positive to the East
!      RLs (relative levels increase negatively downwards.
!
!***************************************************************************
!
!***************************************************************************
!
!** RECORD 1:  TITLE - up to 120 characters
!
!** RECORD 2:  TDFD, PRFL, STEP, ISTOP
!
!      TDFD = 1 compute time domain responses
!           = 2 compute frequency domain responses
!           = -1 over-ride default limits for frequency to time domain conversion
!
!      PRFL = 1  prints response in profile mode.
!                Each column contains the response for one channel
!                (or frequency) for all stations on the profile.
!
!           = 0  prints responses in temporal or frequency mode.
!                Each column contains the responses for one receiver
!                position for either all channels (if TDFD = 1) or
!                for all frequencies (if TDFD = 2).
!
!      STEP = 0 => Compute dB/dt for all magnetic dipole receivers.
!           = 1 => Compute B for all magnetic dipole receivers.
!           = 0 for all other receiver types
!
!     ISTOP = 0  read the input data and run the specified models.
!           = 1  read the input data, print the model description
!                  and STOP so that the model description can be verified.
!                  REMEMBER to change ISTOP to 0 once the models have been
!                  verified.
!   ______________________________________________________________________________________
!
!** (only if TDFD = -1)  RECORD 2.1:  MINFRQ, MAXFRQ, MXFRQE  (only if TDFD = 1)
!
!                Time domain output is computed as a transform of frequency domain results.
!                MINFRQ = frequency below which the step B and impulse E are extrapolated
!                          back to zero as constant.
!                MAXFRQ = cut off frequency for magnetic field computations.
!                MXFRQE = cut off frequency for electric field computations.
!                DEFAULTS:  MINFRQ = 1 Hz for B field; 0.1 Hz for electric field
!                           MAXFRQ = 100 KHz or 1 MHz;  MXFRQE = 4 kHz
!   ---------------------------------------------------------------------------------------
!
!20
!         CONTROL PARAMETERS FOR TIME-DOMAIN SYSTEMS
!         ------------------------------------------
!
!** RECORD 3 (time-domain):  DO3D, NSX, OFFTIME, NCHNL, KRXW
!
!      DO3D = 1  compute new 3D model
!
!           = 2  use previously computed frequency-domain responses
!                contained in Marco.frq    Setting DO3D = 2 allows
!                the user to test different time-domain systems (with
!                the same model and Tx-Rx geometry) in a tiny fraction
!                of the time required to rerun the whole model.  Under
!                this option, the user can vary the waveform, receiver
!                channels, PRFL mode or switch between B & dB/dt
!
!                Variations in model and system geometry require DO3D = 1
!
!           = 0 (Leroi & Marco only) Compute the response of a layered
!                half-space with no 3D target.
!
!      NSX = number of points needed to describe 1/2 cycle of the transmitter
!            waveform.  A bipolar waveform is assumed.  Thus for a system
!            like Sirotem or EM37, NSX = 4, one point each for the start
!            and end of the two ramps.  For an ideal step turnoff system,
!            NSX = 1
!
!      OFFTIME - time (milliseconds) between end of one pulse and the start of
!                the next pulse (of opposite sign) since a bipolar waveform is
!                assumed.  For systems which have a signal which is always on,
!                OFFTIME = 0.
!
!      NCHNL - number of receiver channels
!
!      KRXW = 1 => receiver channels will be read in terms of start and end
!                  times in ms.
!           = 2 => receiver channels will be read in terms of midpoints and
!                  channel widths.
!
!         -->   THESE TIMES WILL BE TAKEN FROM THE SIGNAL ORIGIN TIME
!         -->   To reference them to the signal off time  (or any other time)
!         -->   set KRXW = -1 or -2 and enter reference time in RECORD 3.1
!
!    Only if KRXW < 0
!** RECORD 3.1 (time-domain):  REFTYM
!               Time (in ms) from which TMS or TOPN & TCLS are measured.
!               For example, this could be signal off-time or
!                            start of downward ramp.
!
!** RECORD 4.1 (time-domain):  (TXON(J), TXAMP(J), J = 1,NSX)
!
!      TXON(J) = digitised time (in milliseconds)
!                In most cases, TXON(1) = 0, TXON(NSX) = pulse on-time
!
!      TXAMP(J) = transmitter current in amps at time TXON(J)
!
!
!   For KRXW = 1
!** RECORD 4.2 (time-domain):  (TOPN(J), TCLS(J), J=1, NCHNL)
!
!              Start and end times (in ms) of receiver windows.
!              (measured from start of signal turn on.)
!
!           SKIP to RECORD 5
!
!
!   For KRXW = 2
!** RECORD 4.2 (time-domain):  (TMS(J), J=1,NCHNL)
!** RECORD 4.3 (time-domain):  (WIDTH(J), J=1,NCHNL)
!
!        TMS(J) -  centre of receiver window J in ms.
!                  measured from start of signal turn on.
!      WIDTH(J) -  width of receiver window J in ms.
!
!           SKIP to RECORD 5
!
!   For KRXW = -1
!** RECORD 4.2 (time-domain):  (TOPN(J), TCLS(J), J=1, NCHNL)
!
!              Start and end times (in ms) of receiver windows.
!              measured from time entered in RECORD 3.1
!
!   For KRXW = -2
!** RECORD 4.2 (time-domain):  (TMS(J), J=1,NCHNL)
!** RECORD 4.3 (time-domain):  (WIDTH(J), J=1,NCHNL)
!
!        TMS(J) -  centre of receiver window J in ms.
!                  measured from time entered in RECORD 3.1
!      WIDTH(J) -  width of receiver window J in ms.
!
!
!         CONTROL PARAMETERS FOR FREQUENCY-DOMAIN SYSTEMS
!         -----------------------------------------------
!
!** RECORD 3 (frequency-domain):  NFRQ
!
!      NFRQ - number of frequencies
!
!** RECORD 4 (frequency-domain):  (FREQ(J), CURNT(J), J = 1,NFRQ)
!
!       FREQ(J) - frequency in Hz
!      CURNT(J) - current in amps for Jth frequency
!
!
!         TRANSMITTER - RECEIVER INFORMATION
!         ----------------------------------
!
!** RECORD 5:  SOURCE_TYPE, SURVEY_TYPE, NTX, NRXG
!
!
!      SOURCE_TYPE = 1 => general loop (vertex locations will be specified)
!                  = 2 => grounded wire (path + endpoints will be specified
!                  = 3 => magnetic dipole (location & angle will be specified
!                  = 4 => magnetotellurics
!
!      SURVEY_TYPE = 1 => separate setup of transmitter and receiver arrays.
!
!                  = 2 => single magnetic dipole receiver moving at fixed
!                         offset with a magnetic dipole or loop transmitter
!                         (only for SOURCE_TYPE = 1 or 3)
!
!                  = 3 => central loop survey with magnetic dipole receiver
!                         in the centre of transmitting loop.
!
!                  = 4 => coincident loop survey (time-domain only)
!                         (only for SOURCE_TYPE = 1 & TDFD = 1)
!
!       NTX = number of transmitter positions
!             (loop, magnetic dipole, or electric bipole or dipole)
!
!      NRXG = number of receiver groups.  A receiver group consists of one
!             or more receivers in fixed positions.  All receivers in a group
!             must measure the same thing, either B, dB/dt for a magnetic
!             dipole receivers, or the electric field integrated over electric
!             dipole receiver.
!
!             If SURVEY_TYPE > 1, set NRXG = NTX
!
!============================================================================
!
!  RECORD(S) 6 SPECIFIES THE TRANSMITTER LOCATIONS
!============================================================================
!
!
!** For SOURCE_TYPE = 1 or 2 (closed loop & grounded wire)
!   ======================================================
!
!     For each source position, specify the number of vertices followed by the
!     East, North, & RLs of each vertex.  If the loop is above the earth's
!     surface reference point, RL is positive.
!
!     If SOURCE_TYPE = 1, the program will connect the first vertex
!                         to the last to complete the loop.
!                         DON'T SPECIFY THE SAME VERTEX MORE THAN ONCE.
!
!     If SOURCE_TYPE = 2, the program assumes that the wire is grounded
!                         at the first and last (N_VRTX) vertex.
!
!   SPECIFY_TX: DO FOR J = 1 TO NTX
!** RECORD 6.J.0: N_VRTX - number of vertices
!
!     SPECIFY_VERTICES: DO FOR I = 1 TO N_VRTX
!**   RECORDS 6.J.I: SXE(I,J), SXN(I,J), SXZ(I,J)
!
!       SXE(I,J) = east coordinate of vertex I for loop position J
!       SXN(I,J) = north coordinate of vertex I for loop position J
!       SXZ(I,J) = relative level of vertex I for loop position J
!
!     END SPECIFY_VERTICES FOR TX POSITION J
!
!   END SPECIFY_TX
!
!
!** For SOURCE_TYPE = 3 (dipole source)
!   ===================================
!
!   SPECIFY_TX: DO FOR J = 1 TO NTX
!** RECORD 6.J: SDE(J), SDN(J), SDZ(J), SXDIP(J), SXAZ(J), SXMNT(J)
!
!       SDE(J) = east coordinate of dipole J
!       SDN(J) = north coordinate of dipole J
!       SDZ(J) = relative level of dipole J
!
!-------------------------------------------------------------------------
!     SXDIP(J) = dip (in degrees) of dipole J  (Borehole convention)
!                                              ---------------------
!      SXAZ(J) = azimuth (in degrees) of dipole J
!                (north = 0, east = 90)
!

!         For a dipole whose axis is horizontal pointing Northeast,
!             SXDIP = 0;  SXAZ = 45
!
!         For a dipole whose axis points vertically downwards,
!             SXDIP = 90;  SXAZ = 0
!-------------------------------------------------------------------------
!     SXMNT(J) = moment per unit amp of dipole J
!                (physical area * number of turns)
!
!   END SPECIFY_TX
!
!============================================================================
!
!  RECORD(S) 7 SPECIFIES THE TRANSMITTER LOCATIONS & MEASUREMENT UNITS
!============================================================================
!
!
!   UNITS is an integer which allows the user to choose outut units for
!         dB/dt, B, or grounded wire receivers.
!
!            RX_TYPE(J)= 1        RX_TYPE(J)= 1        Loop receivers &
!            (mag dipole)         (mag dipole)         grounded electrodes
!            &  STEP = 0          &  STEP = 1          RX_TYPE(J)= 2 or 3
!    UNITS       dB/dt              B                 (integrated E field)
!
!      1      nanoteslas /sec    nanoteslas             volts
!      2      picoteslas /sec    picoteslas             millivolts
!      3      microvolts         femtoteslas            microvolts
!      4      nanovolts                                 nanovolts
!
!  ------------------------------------------------------------------------------
!  IF SURVEY_TYPE = 4 (coincident loop)
!** RECORD 7: UNITS
!
!***********************************************
!   SKIP TO RECORD 10 for model specification
!***********************************************
!
!=============================================================================
!  IF SURVEY_TYPE = 2 or 3 (single, fixed offset magnetic dipole receiver),
!  specify receiver moment & offset.
!
!** RECORD 7: RXOE, RXON, RXOZ, RXFMNT, CMP, UNITS
!
!        RXOE - east offset of receiver from transmitter
!        RXON - north offset of receiver from transmitter
!        RXOZ - vertical offset (positive for receiver above transmitter)
!      RXFMNT - physical area * turns of receiver
!
!          CMP(J) = 0 => compute 3 components (North, East, Vertical)
!          CMP(J) = 1 => compute single component in vertical direction
!
!        ___________________________________________________________________
!        If the source is a magnetic dipole an additional option to write
!        three components in a borehole system is available:
!        ___________________________________________________________________
!
!          CMP(J) = 1 => compute single component in Tx dipole direction
!
!          CMP(J) = 2 => write 3 components in a borehole system (HR, SL, AX)
!                        defined by transmitter azimuth rotation, SXAZ
!                        followed by transmitter dip rotation, SXDIP
!
!              AX (Axial component) lies along the borehole axis, defined by SXDIP.
!                 If the hole is vertical, it contains the vertical component.
!                 If the hole is horizontal, with azimuth = 0, it points north.
!              SL (Slope component perpendicular to AX) in the vertical plane
!                 containing the borehole.
!                 If the hole is vertical, it points North. (12 o'clock)
!                 If the hole is horizontal, it contains the vertical component.
!              HR is the Horizontal component regardless of dip.
!                 If the hole is vertical, it points West. (9 o'clock)
!
!***********************************************
!   SKIP TO RECORD 10 for model specification
!***********************************************
!
!=============================================================================
!
!   RECEIVER GROUP SPECIFICATION FOR SURVEY_TYPE = 1
!   ------------------------------------------------
!
!   Note that electric dipole receivers cannot be in the same group
!   as magnetic dipole receivers.
!
!
!   Enter one RECORD 7 followed by RECORDs 8 for each group of receivers.
!   DO FOR J = 1 TO NRXG
!
!** RECORD 7.J: NRX(J), RX_TYPE(J), CMP(J), UNITS(J)
!
!         NRX(J) = number of receivers for receiver group J
!     RX_TYPE(J) = 1 for magnetic dipole receivers
!                = 2 for finite loop receiver
!                = 3 for electric dipole receivers
!
!          CMP(J) = 0 => compute 3 components (North, East, Vertical)
!          CMP(J) = 1 => compute single component in vertical direction
!
!        ___________________________________________________________________
!        If the receiver is a magnetic dipole, an additional option to write
!        three components in a borehole system is available:
!        ___________________________________________________________________
!
!          CMP(J) = 2 => write 3 components in a borehole system (HR, SL, AX)
!                        defined by receiver azimuth rotation, RXAZ
!                        followed by receiver dip rotation, RXDIP
!
!              AX (Axial component) lies along the borehole axis, defined by SXDIP.
!                 If the hole is vertical, it contains the vertical component.
!                 If the hole is horizontal, with azimuth = 0, it points north.
!
!              SL (Slope component perpendicular to AX) in the vertical plane
!                 containing the borehole.
!                 If the hole is vertical, it points North. (12 o'clock)
!                 If the hole is horizontal, it contains the vertical component.
!
!              HR is the Horizontal component regardless of dip.
!                 If the hole is vertical, it points West. (9 o'clock)
!
!     Enter  RECORD(s) 8 for each receiver in Group J,
!     (DO FOR I = 1 TO NRX(J)
!
!       IF RX_TYPE(J) = 1 (magnetic dipoles), AND CMP(J) < 2,
!                                             --------------
!             enter the east (RXE) & north (RXN) cordinates and RLs (RXZ) of the
!             Ith receiver of receiver group J plus the receiver dipole moment
!             RXMNT, (area * number of turns)
!
!**   RECORD 8.I  RXE(I,J,1), RXN(I,J,1), RXZ(I,J,1), RXMNT(I,J)
!
!    OR IF RX_TYPE(J) = 1 (magnetic dipoles), AND CMP(J) = 2,
!                                             --------------
!             enter the east (RXE) & north (RXN) cordinates and RLs (RXZ) of the
!             Ith receiver of receiver group J plus the receiver dipole moment
!             RXMNT, (area * number of turns)
!             plus RXDIP, RXAZ, the dip and azimuth of each receiver position
!
!**   RECORD 8.I  RXE(I,J,1), RXN(I,J,1), RXZ(I,J,1), RXDIP(I,J), RXAZ(I,J), RXMNT(I,J)
!
!-------------------------------------------------------------------------
!     RXDIP(J) = dip (in degrees) of dipole receiver J  (Borehole convention)
!                                                       ---------------------
!      RXAZ(J) = azimuth (in degrees) of dipole J
!                (north = 0, east = 90)
!
!         For a dipole whose axis is horizontal pointing Northeast,
!             RXDIP = 0;  RXAZ = 45
!
!         For a dipole whose axis points vertically downwards,
!             RXDIP = 90;  RXAZ = 0
!-------------------------------------------------------------------------
!
!     or IF RX_TYPE(J) = 2 (finite loops) enter the east and north
!        coordinates and RLs of four corners.
!
!**   RECORD 8.I.1  RXE(I,J,1), RXN(I,J,1), RXZ(I,J,1)
!**   RECORD 8.I.2  RXE(I,J,2), RXN(I,J,2), RXZ(I,J,2)
!**   RECORD 8.I.3  RXE(I,J,3), RXN(I,J,3), RXZ(I,J,3)
!**   RECORD 8.I.4  RXE(I,J,4), RXN(I,J,4), RXZ(I,J,4)
!
!     or IF RX_TYPE(J) = 3 (electric dipoles) enter the east and north
!        coordinates and RLs of each electrode.
!
!**   RECORD 8.I.1  RXE(I,J,1), RXN(I,J,1), RXZ(I,J,1)
!**   RECORD 8.I.2  RXE(I,J,2), RXN(I,J,2), RXZ(I,J,2)
!
!   SURVEY EVENT SPECIFICATION FOR SURVEY_TYPE = 1
!   ----------------------------------------------
!
!   An event consists of specifying one transmitter position index and
!   one receiver group index.
!
!** RECORD 9.0: NEVENTS
!
!   DO FOR J = 1 TO NEVENTS - one record for each event
!** RECORD 9.J TX_INDEX(J), RXG_INDEX(J)
!
 !     TX_INDEX(J) must be a positive integer less than or equal to NTX
!     RXG_INDEX(J) must be a positive integer less than or equal to NRXG
!
!===============================================================================
!
!          LITHOLOGY & STRUCTURE FOR MARCO & MARCO_AIR
!          ===========================================
!
!** RECORD 10:  NLAYER, NPRISM, NLITH, GND_LVL
!
!      NLAYER - number of layers including basement.
!               NLAYER must equal 1 or 2.
!
!      NPRISM - number of 3D prisms in the layered earth structure
!             - a negative value of NPRISM will bypass symmetry checks.  This is 
!               useful for models containing single targets which are offset from the 
!               origin. Symmetry checks would shift such plates to a new origin.
!
!       NLITH - number of layer plus plate lithologies.  Any number of
!               lithologies may be defined.  Be careful not to use
!               layer lithologies for plates and vice versa
!
!     GND_LVL - Relative level of flat surface (m)
!
!
!          DEFINE LITHOLOGIES
!          ------------------
!
!** RECORD 11.1: RES(1), SIG_T(1), RMU(1), REPS(1), CHRG(1), CTAU(1), CFREQ(1)
!** RECORD 11.2: RES(2), SIG_T(2), RMU(2), REPS(2), CHRG(2), CTAU(2), CFREQ(2)
!     .
!
!** RECORD 11.N: RES(N), SIG_T(N), RMU(N), REPS(N), CHRG(N), CTAU(N), CFREQ(N)
!
!           N = NLITH
!      RES(I) - layer resistivity
!    SIG_T(I) - Conductance (conductivity-thickness product)
!      RMU(I) - relative layer magnetic permeability for LITH_INDEX(I)
!     REPS(I) - relative layer dielectric constant (permitivity for LITH_INDEX(I)
!     CHRG(I) - Cole-Cole layer chargeability for LITH_INDEX(I)
!     CTAU(I) - Cole-Cole layer time constant for LITH_INDEX(I)
!    CFREQ(I) - Cole-Cole layer frequency constant for LITH_INDEX(I)
!
!    Default values:  RMU = 1   REPS = 1   CHRG = 0   CTAU = 0   CFREQ = 1
!
!    The default means no magnetic permeability contrast (MU = 4 PI * 10^(-7))
!                      no dielectric constant contrast  (EPSILON = 8.854215E-12)
!                      and no IP effects (no Cole-Cole)
!
!
!     NOTE:  SIG_T must equal -1
!            For prisms,  RMU must = 1;   REPS must = 1
!
!
!          LAYERED EARTH STRUCTURE
!          -----------------------
!
!   (Don't enter 12.1 for a uniform half-space)
!** RECORD 12.1: LITH(1), THICK(1) (unless NLAYER = 1)
!     .
!     .
!     .
!** RECORD 12.J: LITH(J), THICK(J)
!
!** RECORD 12.NLAYER: LITH (NLAYER)
!
!     THICK(J) = thickness of layer J
!      LITH(J) = integer which assigns the resistivity and other
!                physical properties from the list of RECORD 11
!                to layer J.  LITH(J) must be between 1 and NLITH
!
!
!                *********************************************
!                !   DATA ENTRY IS FINISHED IF DO3D = 0,     !
!                !   DATA ENTRY IS FINISHED IF NPRISM = 0    !
!                !                                           !
!                !   If DO3D /= 0 & NPRISM > 0,              !
!                !   CONTINUE FOR 3-D TARGET SPECIFICATION   !
!                *********************************************
!
!===============================================================================
!
!          INPUT DATA FOR THE 3D TARGET STRUCTURE
!          --------------------------------------
!
!     DISCRETISATION AND COMPUTATION CONTROL
!     --------------------------------------
!
!** RECORD 13:  KACC, SOLVER, OUTPUT
!
!        KACC = 2:  standard accuracy
!             = 3:  enhanced accuracy
!
!      SOLVER = 1:  direct solver          (best choice if model isn't too big)
!             = 2:  block iterative solver
!
!
!        OUTPUT = 10 => write out total fields only
!        OUTPUT = 11 => include scattered fields in .OUT file but not in .AMX file
!        OUTPUT = 12 => include scattered fields in both .OUT and .AMX files
!        OUTPUT = -10, -11, or -12. then .AMX file will Ignore PPM data and print field values
!        OUTPUT = 20, 21, or 22. then .AMX file will print blocked fields corresponding to
!                 10, 11, or 12 for unblocked option
!
!===============================================================================
!
!  RECORDS 14, 15 & 16 are repeated sequentially for each prism (brick)
!
!  DO FOR J = 1, NPRISM
!
!** RECORD 14:  LITH(J), PRISM_EAST(J), PRISM_NORTH(J), PRISM_TOP(J)
!
!            LITH(J) = integer which assigns the resistivity and other
!                      physical properties from the list of RECORD 11
!                      to PRISM J.  LITH(J) must be between 1 and NLITH
!     PRISM_EAST(J)  = East coordinate of the centre of the J'th prism.
!     PRISM_NORTH(J) = North coordinate of the centre of the J'th prism.
!
!
!  |     ****************************************************************************
!  |     ****************************************************************************
!  |                 MAJOR CHANGE TO SIGN & DEFINITION OF PRSM_TOP
!  |
!  |             PRSM_TOP(J) = RL of the top of the J'th prism
!  |
!  |                Therefore PRSM_TOP now increases NEGATIVELY downwards
!  |     ****************************************************************************
!  |     ****************************************************************************
!
!** RECORD 15:  PRSM_SIZE_EW(J), PRSM_SIZE_NS(J), PRSM_SIZE_Z(J)
!
!      PRSM_SIZE_EW(J) = length of the J'th prism in the East-West direction.
!      PRSM_SIZE_NS(J) = length of the J'th prism in the North-South direction.
!      PRSM_SIZE_Z(J)  = depth extent of the J'th prism from top to bottom
!
!     DISCRETISATION
!     --------------
!
!** RECORD 16:  CELL_SIZE_EW(J), CELL_SIZE_NS(J), CELL_SIZE_Z(J)
!
!          Each prism is divided into a number of cells.  Ideally these are
!          equi-dimensional but this is not a requirement.  The program will
!          adjust these dimensions to fit an integer number of cells into
!          each prism.
!
!          CELL_SIZE_EW, CELL_SIZE_NS, CELL_SIZE_Z are the cell lengths in the
!          east-west; north-south & depth directions respectively.  (metres)
!
!
!   NOTE:  For exploratory data purposes, cells can have dimensions of
!   ====   40 metres.  However, accuracy for high contrast models may
!          require cells with dimensions of 5 x 5 x 5 m.  Models with
!          this level discretisation can take quite a long time to run.
!
!   END DO
!
!**  If NPRISM > 1,  repeat records 14, 15 and 16 for each prism.
!
!  |
!  |_____   END READ OVER NPRISM
!
!
!#####################
!  END OF DATA ENTRY #
!#####################
!

   MODULE MG_Filter_coefficients
!  --------------------------

  IMPLICIT NONE

  INTEGER, PARAMETER :: JNLO=-250, JNHI=150, NDEC_JN=15, &
                        SNLO=-112, SNHI=85,  NDEC_SN=12
  INTEGER J9
  REAL SHFTJN, WJ0(JNLO:JNHI), WJ1(JNLO:JNHI), WSIN(SNLO:SNHI), DELCOS,WCOS(-200:99)
  SAVE

!  Filter restored to original Meroi_Air 7 February, 2000 (artificial shift removed)

!  J0 filter coefficients computed from the Niels Christensen program, FILCOA
!  for the following parameters:
!
!   ANY =  0      AMY =  0      NDEC = 15       NLO = -250        NHI =  150
!   IOPT = 1   ISHIFT = 0      OMEGA = .3 PI    EPS = 1.0E-12      SC = 3.257209
!      A = 0.162875             DEL0 = 0.14314998               ERROR =  1.4032E-08

 DATA SHFTJN /0.14314998/
 DATA (WJ0(J9), J9= -250,-161)/ &
  2.86608135867E-18,  3.34160553102E-18,  3.89602601168E-18,  4.54243283439E-18,  5.29608785801E-18,  6.17478510356E-18, &
  7.19927087644E-18,  8.39373359283E-18,  9.78637487555E-18,  1.14100754027E-17,  1.33031712306E-17,  1.55103589191E-17, &
  1.80837508313E-17,  2.10841055215E-17,  2.45822622636E-17,  2.86608135867E-17,  3.34160553102E-17,  3.89602601168E-17, &
  4.54243283439E-17,  5.29608785801E-17,  6.17478510356E-17,  7.19927087644E-17,  8.39373359283E-17,  9.78637487555E-17, &
  1.14100754027E-16,  1.33031712306E-16,  1.55103589191E-16,  1.80837508313E-16,  2.10841055215E-16,  2.45822622636E-16, &
  2.86608135867E-16,  3.34160553102E-16,  3.89602601168E-16,  4.54243283439E-16,  5.29608785801E-16,  6.17478510356E-16, &
  7.19927087644E-16,  8.39373359283E-16,  9.78637487555E-16,  1.14100754027E-15,  1.33031712306E-15,  1.55103589191E-15, &
  1.80837508313E-15,  2.10841055215E-15,  2.45822622636E-15,  2.86608135867E-15,  3.34160553102E-15,  3.89602601168E-15, &
  4.54243283439E-15,  5.29608785801E-15,  6.17478510356E-15,  7.19927087644E-15,  8.39373359283E-15,  9.78637487555E-15, &
  1.14100754027E-14,  1.33031712306E-14,  1.55103589191E-14,  1.80837508313E-14,  2.10841055215E-14,  2.45822622636E-14, &
  2.86608135867E-14,  3.34160553102E-14,  3.89602601168E-14,  4.54243283439E-14,  5.29608785801E-14,  6.17478510356E-14, &
  7.19927087644E-14,  8.39373359283E-14,  9.78637487555E-14,  1.14100754027E-13,  1.33031712306E-13,  1.55103589191E-13, &
  1.80837508313E-13,  2.10841055215E-13,  2.45822622636E-13,  2.86608135867E-13,  3.34160553102E-13,  3.89602601168E-13, &
  4.54243283439E-13,  5.29608785801E-13,  6.17478510356E-13,  7.19927087644E-13,  8.39373359283E-13,  9.78637487555E-13, &
  1.14100754027E-12,  1.33031712306E-12,  1.55103589191E-12,  1.80837508313E-12,  2.10841055215E-12,  2.45822622636E-12/
 DATA (WJ0(J9),J9= -160,-71)/ &
  2.86608135867E-12,  3.34160553102E-12,  3.89602601168E-12,  4.54243283439E-12,  5.29608785801E-12,  6.17478510356E-12, &
  7.19927087644E-12,  8.39373359283E-12,  9.78637487555E-12,  1.14100754027E-11,  1.33031712306E-11,  1.55103589191E-11, &
  1.80837508313E-11,  2.10841055215E-11,  2.45822622636E-11,  2.86608135867E-11,  3.34160553102E-11,  3.89602601168E-11, &
  4.54243283439E-11,  5.29608785801E-11,  6.17478510356E-11,  7.19927087644E-11,  8.39373359283E-11,  9.78637487555E-11, &
  1.14100754027E-10,  1.33031712306E-10,  1.55103589191E-10,  1.80837508313E-10,  2.10841055215E-10,  2.45822622636E-10, &
  2.86608135867E-10,  3.34160553102E-10,  3.89602601168E-10,  4.54243283439E-10,  5.29608785801E-10,  6.17478510356E-10, &
  7.19927087644E-10,  8.39373359283E-10,  9.78637487555E-10,  1.14100754027E-09,  1.33031712306E-09,  1.55103589191E-09, &
  1.80837508313E-09,  2.10841055215E-09,  2.45822622636E-09,  2.86608135867E-09,  3.34160553102E-09,  3.89602601168E-09, &
  4.54243283439E-09,  5.29608785801E-09,  6.17478510356E-09,  7.19927087644E-09,  8.39373359283E-09,  9.78637487555E-09, &
  1.14100754027E-08,  1.33031712306E-08,  1.55103589191E-08,  1.80837508313E-08,  2.10841055215E-08,  2.45822622636E-08, &
  2.86608135867E-08,  3.34160553102E-08,  3.89602601168E-08,  4.54243283439E-08,  5.29608785801E-08,  6.17478510356E-08, &
  7.19927087644E-08,  8.39373359283E-08,  9.78637487555E-08,  1.14100754027E-07,  1.33031712306E-07,  1.55103589191E-07, &
  1.80837508313E-07,  2.10841055215E-07,  2.45822622635E-07,  2.86608135866E-07,  3.34160553102E-07,  3.89602601167E-07, &
  4.54243283438E-07,  5.29608785799E-07,  6.17478510354E-07,  7.19927087640E-07,  8.39373359277E-07,  9.78637487545E-07, &
  1.14100754026E-06,  1.33031712304E-06,  1.55103589187E-06,  1.80837508307E-06,  2.10841055205E-06,  2.45822622620E-06/
 DATA (WJ0(J9),J9= -70,19)/ &
  2.86608135842E-06,  3.34160553063E-06,  3.89602601105E-06,  4.54243283340E-06,  5.29608785643E-06,  6.17478510107E-06, &
  7.19927087248E-06,  8.39373358656E-06,  9.78637486561E-06,  1.14100753870E-05,  1.33031712056E-05,  1.55103588795E-05, &
  1.80837507685E-05,  2.10841054221E-05,  2.45822621060E-05,  2.86608133369E-05,  3.34160549143E-05,  3.89602594894E-05, &
  4.54243273495E-05,  5.29608770041E-05,  6.17478485378E-05,  7.19927048056E-05,  8.39373296541E-05,  9.78637388116E-05, &
  1.14100738267E-04,  1.33031687328E-04,  1.55103549604E-04,  1.80837445571E-04,  2.10840955776E-04,  2.45822465035E-04, &
  2.86607886087E-04,  3.34160157229E-04,  3.89601973751E-04,  4.54242289050E-04,  5.29607209800E-04,  6.17476012564E-04, &
  7.19923128912E-04,  8.39367085119E-04,  9.78627543681E-04,  1.14099178031E-03,  1.33029214523E-03,  1.55099630479E-03, &
  1.80831234191E-03,  2.10831111434E-03,  2.45806862870E-03,  2.86583158466E-03,  3.34120966900E-03,  3.89539861933E-03, &
  4.54143849891E-03,  5.29451197347E-03,  6.17228756167E-03,  7.19531268313E-03,  8.38746058912E-03,  9.77643350230E-03, &
  1.13943208262E-02,  1.32782050079E-02,  1.54707967971E-02,  1.80210634703E-02,  2.09847837166E-02,  2.44249145050E-02, &
  2.84115778193E-02,  3.30213524808E-02,  3.83353639832E-02,  4.44353673090E-02,  5.13965627145E-02,  5.92752031985E-02, &
  6.80880607240E-02,  7.77794366644E-02,  8.81696149649E-02,  9.88766639298E-02,  1.09202052802E-01,  1.17971700371E-01, &
  1.23332521049E-01,  1.22530035854E-01,  1.11753240889E-01,  8.62569960973E-02,  4.11899187108E-02, -2.61456504772E-02, &
 -1.11691705121E-01, -1.97411432453E-01, -2.44254055664E-01, -1.95918893763E-01, -1.49300191739E-02,  2.33634698676E-01, &
  3.13582629541E-01, -4.47760615930E-03, -3.86535797015E-01, -3.87589109967E-03,  4.18653972543E-01, -4.16298788795E-01/
 DATA (WJ0(J9),J9= 20,109)/ &
  2.34448877498E-01, -9.52158343728E-02,  3.09020778713E-02, -8.49535839509E-03,  2.06835506815E-03, -4.67185821059E-04, &
  1.02086153218E-04, -2.20830053233E-05,  4.76413760468E-06, -1.02705545675E-06,  2.21421979164E-07, -4.77750910705E-08, &
  1.03340738634E-08, -2.25102276694E-09,  4.99715357680E-10, -1.16500471179E-10,  3.03986897639E-11, -9.72611811870E-12, &
  3.99994042396E-12, -2.00348565820E-12,  1.11608417099E-12, -6.50767639555E-13,  3.86180817012E-13, -2.30659587418E-13, &
  1.38093695980E-13, -8.27455585993E-14,  4.95961642994E-14, -2.97302965597E-14,  1.78224472343E-14, -1.06841897105E-14, &
  6.40498685290E-15, -3.83968417568E-15,  2.30182896520E-15, -1.37991039489E-15,  8.27234374391E-16, -4.95913890248E-16, &
  2.97292643817E-16, -1.78222228351E-16,  1.06841401468E-16, -6.40497544674E-17,  3.83968128138E-17, -2.30182807939E-17, &
  1.37991004842E-17, -8.27234560136E-18,  4.95913797287E-18, -2.97292590016E-18,  1.78222272891E-18, -1.06841382487E-18, &
  6.40497431324E-19, -3.83968224515E-19,  2.30182767120E-19, -1.37990980321E-19,  8.27234414081E-20, -4.95914134387E-20, &
  2.97292537295E-20, -1.78222241286E-20,  1.06841455108E-20, -6.40497317742E-21,  3.83968156424E-21, -2.30182923671E-21, &
  1.37990955793E-21, -8.27234267383E-22,  4.95914046240E-22, -2.97292739490E-22,  1.78222209690E-22, -1.06841436161E-22, &
  6.40497753124E-23, -3.83968088314E-23,  2.30182784256E-23, -1.37991049701E-23,  8.27234475022E-24, -4.95913958682E-24, &
  2.97292559305E-24, -1.78222330828E-24,  1.06841371450E-24, -6.40497639510E-25,  3.83968184851E-25, -2.30182842033E-25, &
  1.37990966066E-25, -8.27234682962E-26,  4.95914083158E-26, -2.97292634049E-26,  1.78222222810E-26, -1.06841489841E-26, &
  6.40497251344E-27, -3.83968281228E-27,  2.30182702533E-27, -1.37991000702E-27,  8.27234181627E-28, -4.95914207635E-28/
 DATA WJ0(110:150)/ &
  2.97292963477E-28, -1.78222420371E-28,  1.06841425086E-28, -6.40497412376E-29,  3.83968377606E-29, -2.30182957681E-29, &
  1.37991153609E-29, -8.27235098582E-30,  4.95914332316E-30, -2.97292528486E-30,  1.78222312353E-30, -1.06841451903E-30, &
  6.40498122076E-31, -3.83968474142E-31,  2.30183015458E-31, -1.37991188353E-31,  8.27234597206E-32, -4.95914031749E-32, &
  2.97292858145E-32, -1.78222357152E-32,  1.06841478804E-32, -6.40498282844E-33,  3.83968570659E-33, -2.30182876031E-33, &
  1.37991104718E-33, -8.27234805187E-34,  4.95914156225E-34, -2.97292932767E-34,  1.78222401887E-34, -1.06841414093E-34, &
  6.40497895409E-35, -3.83968338099E-35,  2.30182933903E-35, -1.37991139355E-35,  8.27235013127E-36, -4.95914281087E-36, &
  2.97292752582E-36, -1.78222294016E-36,  1.06841440910E-36, -6.40498056176E-37,  3.83968434477E-37/

!  J1 filter coefficients computed from the Niels Christensen program, FILCOA
!  for the following parameters:
!
!   ANY =  1      AMY =  0      NDEC = 15       NLO = -250        NHI =  150
!   IOPT = 1   ISHIFT = 0      OMEGA = .3 PI    EPS = 1.0E-12      SC = 3.257209
!      A = 0.162875             DEL0 = 0.14314998               ERROR =  1.4032E-08

 DATA (WJ1(J9),J9= -250,-161)/ &
  2.67560875879E-35,  3.63710586576E-35,  4.94412310292E-35,  6.72082533724E-35,  9.13599687416E-35,  1.24190757379E-34, &
  1.68819499732E-34,  2.29485865865E-34,  3.11953078380E-34,  4.24055410750E-34,  5.76442432690E-34,  7.83590704850E-34, &
  1.06517903247E-33,  1.44795792522E-33,  1.96829085937E-33,  2.67560875879E-33,  3.63710586576E-33,  4.94412310292E-33, &
  6.72082533724E-33,  9.13599687416E-33,  1.24190757379E-32,  1.68819499732E-32,  2.29485865865E-32,  3.11953078380E-32, &
  4.24055410750E-32,  5.76442432690E-32,  7.83590704850E-32,  1.06517903247E-31,  1.44795792522E-31,  1.96829085937E-31, &
  2.67560875879E-31,  3.63710586576E-31,  4.94412310292E-31,  6.72082533724E-31,  9.13599687416E-31,  1.24190757379E-30, &
  1.68819499732E-30,  2.29485865865E-30,  3.11953078380E-30,  4.24055410750E-30,  5.76442432690E-30,  7.83590704850E-30, &
  1.06517903247E-29,  1.44795792522E-29,  1.96829085937E-29,  2.67560875879E-29,  3.63710586576E-29,  4.94412310292E-29, &
  6.72082533724E-29,  9.13599687416E-29,  1.24190757379E-28,  1.68819499732E-28,  2.29485865865E-28,  3.11953078380E-28, &
  4.24055410750E-28,  5.76442432690E-28,  7.83590704850E-28,  1.06517903247E-27,  1.44795792522E-27,  1.96829085937E-27, &
  2.67560875879E-27,  3.63710586576E-27,  4.94412310292E-27,  6.72082533724E-27,  9.13599687416E-27,  1.24190757379E-26, &
  1.68819499732E-26,  2.29485865865E-26,  3.11953078380E-26,  4.24055410750E-26,  5.76442432690E-26,  7.83590704850E-26, &
  1.06517903247E-25,  1.44795792522E-25,  1.96829085937E-25,  2.67560875879E-25,  3.63710586576E-25,  4.94412310292E-25, &
  6.72082533724E-25,  9.13599687416E-25,  1.24190757379E-24,  1.68819499732E-24,  2.29485865865E-24,  3.11953078380E-24, &
  4.24055410750E-24,  5.76442432690E-24,  7.83590704850E-24,  1.06517903247E-23,  1.44795792522E-23,  1.96829085937E-23/
 DATA (WJ1(J9),J9= -160,-71)/ &
  2.67560875879E-23,  3.63710586576E-23,  4.94412310292E-23,  6.72082533724E-23,  9.13599687416E-23,  1.24190757379E-22, &
  1.68819499732E-22,  2.29485865865E-22,  3.11953078380E-22,  4.24055410750E-22,  5.76442432690E-22,  7.83590704850E-22, &
  1.06517903247E-21,  1.44795792522E-21,  1.96829085937E-21,  2.67560875879E-21,  3.63710586576E-21,  4.94412310292E-21, &
  6.72082533724E-21,  9.13599687416E-21,  1.24190757379E-20,  1.68819499732E-20,  2.29485865865E-20,  3.11953078380E-20, &
  4.24055410750E-20,  5.76442432690E-20,  7.83590704850E-20,  1.06517903247E-19,  1.44795792522E-19,  1.96829085937E-19, &
  2.67560875879E-19,  3.63710586576E-19,  4.94412310292E-19,  6.72082533724E-19,  9.13599687416E-19,  1.24190757379E-18, &
  1.68819499732E-18,  2.29485865865E-18,  3.11953078380E-18,  4.24055410750E-18,  5.76442432690E-18,  7.83590704850E-18, &
  1.06517903247E-17,  1.44795792522E-17,  1.96829085937E-17,  2.67560875879E-17,  3.63710586576E-17,  4.94412310292E-17, &
  6.72082533724E-17,  9.13599687416E-17,  1.24190757379E-16,  1.68819499732E-16,  2.29485865865E-16,  3.11953078380E-16, &
  4.24055410750E-16,  5.76442432690E-16,  7.83590704850E-16,  1.06517903247E-15,  1.44795792522E-15,  1.96829085937E-15, &
  2.67560875879E-15,  3.63710586576E-15,  4.94412310292E-15,  6.72082533724E-15,  9.13599687416E-15,  1.24190757379E-14, &
  1.68819499732E-14,  2.29485865865E-14,  3.11953078380E-14,  4.24055410750E-14,  5.76442432690E-14,  7.83590704849E-14, &
  1.06517903247E-13,  1.44795792522E-13,  1.96829085938E-13,  2.67560875878E-13,  3.63710586577E-13,  4.94412310288E-13, &
  6.72082533728E-13,  9.13599687406E-13,  1.24190757380E-12,  1.68819499729E-12,  2.29485865868E-12,  3.11953078372E-12, &
  4.24055410758E-12,  5.76442432666E-12,  7.83590704871E-12,  1.06517903240E-11,  1.44795792527E-11,  1.96829085917E-11/
 DATA (WJ1(J9),J9= -70,19)/ &
  2.67560875891E-11,  3.63710586515E-11,  4.94412310317E-11,  6.72082533541E-11,  9.13599687462E-11,  1.24190757324E-10, &
  1.68819499736E-10,  2.29485865695E-10,  3.11953078363E-10,  4.24055410221E-10,  5.76442432542E-10,  7.83590703194E-10, &
  1.06517903172E-09,  1.44795791998E-09,  1.96829085611E-09,  2.67560874206E-09,  3.63710585268E-09,  4.94412304898E-09, &
  6.72082528725E-09,  9.13599669890E-09,  1.24190755523E-08,  1.68819493996E-08,  2.29485859113E-08,  3.11953059487E-08, &
  4.24055386543E-08,  5.76442370102E-08,  7.83590618983E-08,  1.06517882412E-07,  1.44795762309E-07,  1.96829016283E-07, &
  2.67560770231E-07,  3.63710352883E-07,  4.94411942636E-07,  6.72081747305E-07,  9.13598412795E-07,  1.24190492063E-06, &
  1.68819059152E-06,  2.29484968860E-06,  3.11951559104E-06,  4.24052372735E-06,  5.76437203602E-06,  7.83580400571E-06, &
  1.06516106220E-05,  1.44792293329E-05,  1.96822917833E-05,  2.67548981332E-05,  3.63689436167E-05,  4.94371845248E-05, &
  6.72010067340E-05,  9.13461935181E-05,  1.24165945005E-04,  1.68772580859E-04,  2.29400955289E-04,  3.11793204874E-04, &
  4.23764974965E-04,  5.75897507579E-04,  7.82597702990E-04,  1.06332133421E-03,  1.44456435715E-03,  1.96195766368E-03, &
  2.66401748131E-03,  3.61551958902E-03,  4.90456094796E-03,  6.64729428357E-03,  9.00112880743E-03,  1.21689223295E-02, &
  1.64231258930E-02,  2.20996958736E-02,  2.96400942278E-02,  3.95385050500E-02,  5.24078149405E-02,  6.87615215337E-02, &
  8.91013723344E-02,  1.13192375541E-01,  1.40192739735E-01,  1.66618485339E-01,  1.87030308669E-01,  1.89612379729E-01, &
  1.61380285157E-01,  8.29859362099E-02, -4.46335736689E-02, -2.01737898138E-01, -2.84006740802E-01, -1.90854624427E-01, &
  1.45861570853E-01,  3.42338340245E-01,  5.72930699760E-02, -4.71068534718E-01,  2.63969067746E-01,  8.25956507901E-02/
 DATA (WJ1(J9),J9= 20,109)/ &
 -2.22236420794E-01,  2.04428998525E-01, -1.44401888321E-01,  9.24618900674E-02, -5.69896615248E-02,  3.45697730305E-02, &
 -2.08227940873E-02,  1.25054653306E-02, -7.50178808640E-03,  4.49828025678E-03, -2.69688071237E-03,  1.61678766116E-03, &
 -9.69249547051E-04,  5.81052166908E-04, -3.48332124427E-04,  2.08819730575E-04, -1.25184162926E-04,  7.50459390809E-05, &
 -4.49888596104E-05,  2.69701130091E-05, -1.61681580285E-05,  9.69255610555E-06, -5.81053473294E-06,  3.48332405883E-06, &
 -2.08819791213E-06,  1.25184175990E-06, -7.50459418954E-07,  4.49888602168E-07, -2.69701131398E-07,  1.61681580566E-07, &
 -9.69255611161E-08,  5.81053473425E-08, -3.48332405911E-08,  2.08819791219E-08, -1.25184175991E-08,  7.50459418957E-09, &
 -4.49888602168E-09,  2.69701131398E-09, -1.61681580566E-09,  9.69255611161E-10, -5.81053473425E-10,  3.48332405911E-10, &
 -2.08819791219E-10,  1.25184175991E-10, -7.50459418957E-11,  4.49888602168E-11, -2.69701131398E-11,  1.61681580566E-11, &
 -9.69255611161E-12,  5.81053473425E-12, -3.48332405911E-12,  2.08819791219E-12, -1.25184175991E-12,  7.50459418957E-13, &
 -4.49888602168E-13,  2.69701131398E-13, -1.61681580566E-13,  9.69255611161E-14, -5.81053473425E-14,  3.48332405911E-14, &
 -2.08819791219E-14,  1.25184175991E-14, -7.50459418957E-15,  4.49888602168E-15, -2.69701131398E-15,  1.61681580566E-15, &
 -9.69255611161E-16,  5.81053473425E-16, -3.48332405911E-16,  2.08819791219E-16, -1.25184175991E-16,  7.50459418957E-17, &
 -4.49888602168E-17,  2.69701131398E-17, -1.61681580566E-17,  9.69255611161E-18, -5.81053473425E-18,  3.48332405911E-18, &
 -2.08819791219E-18,  1.25184175991E-18, -7.50459418957E-19,  4.49888602168E-19, -2.69701131398E-19,  1.61681580566E-19, &
 -9.69255611161E-20,  5.81053473425E-20, -3.48332405911E-20,  2.08819791219E-20, -1.25184175991E-20,  7.50459418957E-21/
 DATA WJ1(110:150)/ &
 -4.49888602168E-21,  2.69701131398E-21, -1.61681580566E-21,  9.69255611161E-22, -5.81053473425E-22,  3.48332405911E-22, &
 -2.08819791219E-22,  1.25184175991E-22, -7.50459418957E-23,  4.49888602168E-23, -2.69701131398E-23,  1.61681580566E-23, &
 -9.69255611161E-24,  5.81053473425E-24, -3.48332405911E-24,  2.08819791219E-24, -1.25184175991E-24,  7.50459418957E-25, &
 -4.49888602168E-25,  2.69701131398E-25, -1.61681580566E-25,  9.69255611161E-26, -5.81053473425E-26,  3.48332405911E-26, &
 -2.08819791219E-26,  1.25184175991E-26, -7.50459418957E-27,  4.49888602168E-27, -2.69701131398E-27,  1.61681580566E-27, &
 -9.69255611161E-28,  5.81053473425E-28, -3.48332405911E-28,  2.08819791219E-28, -1.25184175991E-28,  7.50459418957E-29, &
 -4.49888602168E-29,  2.69701131398E-29, -1.61681580566E-29,  9.69255611161E-30, -5.81053473425E-30/

!  Niels Christensen shifted cosine filter:
!  12 points per decade, OMEGA = .3 PI

  DATA DELCOS /.00632173 /
  DATA (WCOS (J9), J9 = -200, -21)/ &
  3.27764748749E-18,  3.97096058632E-18,  4.81092858166E-18,  5.82857304036E-18,  7.06147744874E-18,  8.55517523993E-18, &
  1.03648314276E-17,  1.25572799515E-17,  1.52134919784E-17,  1.84315663162E-17,  2.23303523839E-17,  2.70538395400E-17, &
  3.27764748749E-17,  3.97096058632E-17,  4.81092858166E-17,  5.82857304036E-17,  7.06147744874E-17,  8.55517523993E-17, &
  1.03648314276E-16,  1.25572799515E-16,  1.52134919784E-16,  1.84315663162E-16,  2.23303523839E-16,  2.70538395400E-16, &
  3.27764748749E-16,  3.97096058632E-16,  4.81092858166E-16,  5.82857304036E-16,  7.06147744874E-16,  8.55517523993E-16, &
  1.03648314276E-15,  1.25572799515E-15,  1.52134919784E-15,  1.84315663162E-15,  2.23303523839E-15,  2.70538395400E-15, &
  3.27764748749E-15,  3.97096058632E-15,  4.81092858166E-15,  5.82857304036E-15,  7.06147744874E-15,  8.55517523993E-15, &
  1.03648314276E-14,  1.25572799515E-14,  1.52134919784E-14,  1.84315663162E-14,  2.23303523839E-14,  2.70538395400E-14, &
  3.27764748749E-14,  3.97096058632E-14,  4.81092858166E-14,  5.82857304036E-14,  7.06147744874E-14,  8.55517523993E-14, &
  1.03648314276E-13,  1.25572799515E-13,  1.52134919784E-13,  1.84315663162E-13,  2.23303523839E-13,  2.70538395400E-13, &
  3.27764748749E-13,  3.97096058632E-13,  4.81092858166E-13,  5.82857304036E-13,  7.06147744874E-13,  8.55517523993E-13, &
  1.03648314276E-12,  1.25572799515E-12,  1.52134919784E-12,  1.84315663162E-12,  2.23303523839E-12,  2.70538395400E-12, &
  3.27764748749E-12,  3.97096058632E-12,  4.81092858166E-12,  5.82857304036E-12,  7.06147744874E-12,  8.55517523993E-12, &
  1.03648314276E-11,  1.25572799515E-11,  1.52134919784E-11,  1.84315663162E-11,  2.23303523839E-11,  2.70538395400E-11, &
  3.27764748749E-11,  3.97096058632E-11,  4.81092858166E-11,  5.82857304036E-11,  7.06147744874E-11,  8.55517523993E-11, &
  1.03648314276E-10,  1.25572799515E-10,  1.52134919784E-10,  1.84315663162E-10,  2.23303523839E-10,  2.70538395400E-10, &
  3.27764748749E-10,  3.97096058632E-10,  4.81092858166E-10,  5.82857304036E-10,  7.06147744874E-10,  8.55517523993E-10, &
  1.03648314276E-09,  1.25572799515E-09,  1.52134919784E-09,  1.84315663162E-09,  2.23303523839E-09,  2.70538395400E-09, &
  3.27764748749E-09,  3.97096058632E-09,  4.81092858166E-09,  5.82857304036E-09,  7.06147744874E-09,  8.55517523993E-09, &
  1.03648314276E-08,  1.25572799515E-08,  1.52134919784E-08,  1.84315663162E-08,  2.23303523839E-08,  2.70538395400E-08, &
  3.27764748749E-08,  3.97096058632E-08,  4.81092858166E-08,  5.82857304036E-08,  7.06147744874E-08,  8.55517523992E-08, &
  1.03648314276E-07,  1.25572799515E-07,  1.52134919784E-07,  1.84315663162E-07,  2.23303523839E-07,  2.70538395400E-07, &
  3.27764748748E-07,  3.97096058631E-07,  4.81092858163E-07,  5.82857304032E-07,  7.06147744866E-07,  8.55517523979E-07, &
  1.03648314273E-06,  1.25572799511E-06,  1.52134919777E-06,  1.84315663149E-06,  2.23303523815E-06,  2.70538395358E-06, &
  3.27764748674E-06,  3.97096058499E-06,  4.81092857928E-06,  5.82857303614E-06,  7.06147744122E-06,  8.55517522657E-06, &
  1.03648314038E-05,  1.25572799093E-05,  1.52134919033E-05,  1.84315661826E-05,  2.23303521464E-05,  2.70538391177E-05, &
  3.27764741237E-05,  3.97096045276E-05,  4.81092834413E-05,  5.82857261799E-05,  7.06147669760E-05,  8.55517390427E-05, &
  1.03648290523E-04,  1.25572757278E-04,  1.52134844670E-04,  1.84315529598E-04,  2.23303286305E-04,  2.70537973035E-04, &
  3.27763997594E-04,  3.97094723005E-04,  4.81090482791E-04,  5.82853080445E-04,  7.06140233231E-04,  8.55504167951E-04, &
  1.03645938870E-03,  1.25568576016E-03,  1.52127408052E-03,  1.84302307509E-03,  2.23279769616E-03,  2.70496162210E-03/

  DATA (WCOS (J9), J9= -20, 99)/ &
  3.27689631886E-03,  3.96962511374E-03,  4.80855324839E-03,  5.82435024343E-03,  7.05396657593E-03,  8.54182367870E-03, &
  1.03410843805E-02,  1.25150721296E-02,  1.51384287367E-02,  1.82981828574E-02,  2.20932012652E-02,  2.66326428704E-02, &
  3.20280504750E-02,  3.83817031757E-02,  4.57529090015E-02,  5.41138165506E-02,  6.32336060872E-02,  7.25429239280E-02, &
  8.07814005943E-02,  8.56648215301E-02,  8.29754131995E-02,  6.61728839009E-02,  2.49099879313E-02, -5.25662370332E-02, &
 -1.77257695902E-01, -3.38275600250E-01, -4.82415902998E-01, -4.55992280486E-01, -7.52812327135E-02,  6.65970979261E-01, &
  8.99170503986E-01, -3.96592370781E-01, -1.38198747238E+00,  1.66395693227E+00, -9.30334922154E-01,  3.30012032268E-01, &
 -8.19311720454E-02,  1.48662188728E-02, -2.13960121462E-03,  2.89777944084E-04, -4.10252655190E-05,  5.96303531789E-06, &
 -8.72916816254E-07,  1.28031659199E-07, -1.87886052472E-08,  2.75763186999E-09, -4.04758530392E-10,  5.94101668614E-11, &
 -8.72020580969E-12,  1.27995006152E-12, -1.87869546474E-13,  2.75750390141E-14, -4.04729332639E-15,  5.94004630834E-16, &
 -8.70764639675E-17,  1.27459963186E-17, -1.82944370627E-18,  2.67836880337E-19, -3.04833935943E-20,  1.64313000801E-21, &
  3.01142825752E-21, -5.21478596825E-22,  1.37002813677E-21, -6.52797182652E-22,  1.40079856288E-22, -1.40667671784E-22, &
  1.70033730143E-23, -2.74453364807E-23,  2.41787117103E-23, -1.78716987481E-23,  4.99883433782E-24, -4.06084044984E-24, &
  2.89670334941E-24, -8.77965537372E-25,  1.21194987045E-25, -1.74181776862E-25,  1.50307641169E-25, -1.09826064382E-25, &
  3.14586965779E-26, -2.51308231025E-26,  1.77594485992E-26, -1.17543940755E-26,  8.42024121640E-28, -1.10510759608E-27, &
  9.31619291992E-28, -6.75339996352E-28,  1.97531071217E-28, -1.55371775135E-28,  1.08953022579E-28, -7.17780762223E-29, &
  2.55398099963E-29, -6.99012347840E-30,  5.76787420019E-30, -4.15016624873E-30,  1.23507827864E-30, -9.59703688264E-31, &
  6.68070421281E-31, -4.37770918800E-31,  1.57257106203E-31, -1.06708053061E-31,  3.57322505765E-32, -2.54887457918E-32, &
  7.72541668811E-33, -5.92277283725E-33,  4.09438835539E-33, -1.32259081936E-33,  1.67919911757E-33, -2.76812163102E-34, &
  2.21131777864E-34,  5.28010221339E-35,  1.03429563330E-34, -7.40916006860E-36,  9.72409086858E-36, -8.19752817047E-36, &
 -2.58911797964E-36, -3.98829026336E-36,  1.78104494324E-37, -3.32579083872E-37,  3.00732538418E-37, -2.24730545742E-37/

! Niels Christensen sine filter computed for the following parameters :
!
!    ANY =  0.50          AMY =  0.50     NDEC_SN = 12         SC = 2.605767
!      A = 0.203593       EPS = 1.00E-12     IOPT = 1       OMEGA = 0.30 PI
! ISHIFT = 0             DEL0 = 0.00000      SNLO = -112     SNHI =  85
!  ERROR = 5.3494E-07

 DATA (WSIN(J9),J9= SNLO,SNHI)/ &
  3.29843470141E-20,  4.84144003903E-20,  7.10626214352E-20,  1.04305663698E-19,  1.53099776785E-19,  2.24719740238E-19, &
  3.29843470141E-19,  4.84144003903E-19,  7.10626214352E-19,  1.04305663698E-18,  1.53099776785E-18,  2.24719740238E-18, &
  3.29843470141E-18,  4.84144003903E-18,  7.10626214352E-18,  1.04305663698E-17,  1.53099776785E-17,  2.24719740238E-17, &
  3.29843470141E-17,  4.84144003903E-17,  7.10626214352E-17,  1.04305663698E-16,  1.53099776785E-16,  2.24719740238E-16, &
  3.29843470141E-16,  4.84144003903E-16,  7.10626214352E-16,  1.04305663698E-15,  1.53099776785E-15,  2.24719740238E-15, &
  3.29843470141E-15,  4.84144003903E-15,  7.10626214351E-15,  1.04305663698E-14,  1.53099776784E-14,  2.24719740238E-14, &
  3.29843470140E-14,  4.84144003905E-14,  7.10626214348E-14,  1.04305663699E-13,  1.53099776783E-13,  2.24719740240E-13, &
  3.29843470135E-13,  4.84144003912E-13,  7.10626214333E-13,  1.04305663701E-12,  1.53099776778E-12,  2.24719740250E-12, &
  3.29843470115E-12,  4.84144003946E-12,  7.10626214259E-12,  1.04305663713E-11,  1.53099776751E-11,  2.24719740291E-11, &
  3.29843470017E-11,  4.84144004090E-11,  7.10626213893E-11,  1.04305663763E-10,  1.53099776614E-10,  2.24719740458E-10, &
  3.29843469501E-10,  4.84144004636E-10,  7.10626211927E-10,  1.04305663935E-09,  1.53099775856E-09,  2.24719740965E-09, &
  3.29843466535E-09,  4.84144005941E-09,  7.10626200153E-09,  1.04305664163E-08,  1.53099771106E-08,  2.24719740669E-08, &
  3.29843447058E-08,  4.84143999692E-08,  7.10626118987E-08,  1.04305659511E-07,  1.53099736752E-07,  2.24719712781E-07, &
  3.29843299537E-07,  4.84143847630E-07,  7.10625477136E-07,  1.04305580801E-06,  1.53099454243E-06,  2.24719318225E-06, &
  3.29842043629E-06,  4.84141911268E-06,  7.10619846782E-06,  1.04304644290E-05,  1.53096912404E-05,  2.24714835740E-05, &
  3.29830502601E-05,  4.84120618278E-05,  7.10567202638E-05,  1.04294586029E-04,  1.53072809860E-04,  2.24667522134E-04, &
  3.29719828517E-04,  4.83898767299E-04,  7.10057855007E-04,  1.04190820377E-03,  1.52838000422E-03,  2.24183176974E-03, &
  3.28636154488E-03,  4.81642274472E-03,  7.05054547250E-03,  1.03141810945E-02,  1.50529568277E-02,  2.19321837975E-02, &
  3.18014238705E-02,  4.59240858792E-02,  6.56510206738E-02,  9.29354313249E-02,  1.28683857774E-01,  1.73917366767E-01, &
  2.23007141217E-01,  2.67404509859E-01,  2.73366070252E-01,  2.06068241098E-01, -1.67534380110E-02, -3.60408605065E-01, &
 -7.33064377532E-01, -4.81827612364E-01,  4.40141743865E-01,  1.32831422063E+00, -1.13994567799E+00, -2.46268092208E-01, &
  9.29146388411E-01, -8.57560517297E-01,  5.73597714499E-01, -3.36064823205E-01,  1.85046743779E-01, -9.90581893402E-02, &
  5.24802391849E-02, -2.77162017159E-02,  1.46248394020E-02, -7.71564221998E-03,  4.07025589629E-03, -2.14707450654E-03, &
  1.13258347863E-03, -5.97437791024E-04,  3.15148309040E-04, -1.66240647777E-04,  8.76918939599E-05, -4.62574484721E-05, &
  2.44007905095E-05, -1.28714098324E-05,  6.78966490764E-06, -3.58154624520E-06,  1.88926459271E-06, -9.96586517910E-07, &
  5.25699095571E-07, -2.77306118553E-07,  1.46278896111E-07, -7.71620747468E-08,  4.07029717719E-08, -2.14708056581E-08, &
  1.13258436802E-08, -5.97437921568E-09,  3.15148328202E-09, -1.66240650589E-09,  8.76918943727E-10, -4.62574485326E-10, &
  2.44007905184E-10, -1.28714098337E-10,  6.78966490783E-11, -3.58154624523E-11,  1.88926459271E-11, -9.96586517911E-12, &
  5.25699095571E-12, -2.77306118553E-12,  1.46278896111E-12, -7.71620747468E-13,  4.07029717719E-13, -2.14708056581E-13, &
  1.13258436802E-13, -5.97437921568E-14,  3.15148328202E-14, -1.66240650589E-14,  8.76918943727E-15, -4.62574485326E-15, &
  2.44007905184E-15, -1.28714098337E-15,  6.78966490783E-16, -3.58154624523E-16,  1.88926459271E-16, -9.96586517911E-17, &
  5.25699095571E-17, -2.77306118553E-17,  1.46278896111E-17, -7.71620747468E-18,  4.07029717719E-18, -2.14708056581E-18, &
  1.13258436802E-18, -5.97437921568E-19,  3.15148328202E-19, -1.66240650589E-19,  8.76918943727E-20, -4.62574485326E-20/

END MODULE MG_Filter_coefficients

MODULE MG_Input_routines

! CONTAINS: READ_SYSTEM_DATA, READ_MODEL_DATA, SET_FRQ
 Use iso_Fortran_env
 Use MG_Metadata
 IMPLICIT NONE

! SYSTEM & LITHOLOGY DIMENSIONS
! -----------------------------

 INTEGER, PARAMETER :: NPROP=7
 REAL, PARAMETER :: PI=3.141592654
 INTEGER NR,NW,ND,NDR,NLG,MSG,MXERR,DO3D,TDFD,STEP,NSX,PRFL,ISTOP,KRXW,NCHNL,NFRQ, &
         SOURCE_TYPE,SURVEY_TYPE,NTX,NRXG,MXVRTX,MQVR,J,JS,JT,JV,JG,JR,NEVENTS,LRX, &
         MRX,NLITH,KACC,SOLVER,OUTPUT,NPULS,NTYRP,NTYPLS,NTXE,KFRQE
 INTEGER, ALLOCATABLE, DIMENSION(:) :: N_VRTX,UNITS,NRX,RX_TYPE,CMP,NRGTX,NRXTX,TXID,NCMPG
 INTEGER, ALLOCATABLE, DIMENSION(:,:)  :: RGTXID,RXID,NCMP,PRTCMP
 REAL T0SX,OFFTYM,REFTYM,PULSE,RXOE,RXON,RXOZ,RXFMNT,MAXFRQ,MINFRQ,MXFRQE
 REAL, ALLOCATABLE, DIMENSION(:) :: TXON,WAVEFORM,CURNT,TRP,TMS,WTMS,TOPN,TCLS,FREQ,SWX, &
                                    SXMNT,SXDIP,SXAZ
 REAL, ALLOCATABLE, DIMENSION(:,:) :: SWY,SXE,SXN,SXZ,LYTH,RXDIP,RXAZ,RXMNT,BHAZ,BHDIP
 REAL, ALLOCATABLE, DIMENSION(:,:,:) :: RXE,RXN,RXZ
 REAL(KIND=8) ECNTRD,NCNTRD,QD
 REAL(KIND=8), ALLOCATABLE, DIMENSION(:,:)   :: SXED,SXND,SXZD,CLCD
 REAL(KIND=8), ALLOCATABLE, DIMENSION(:,:,:) :: RXED,RXND,RXZD
 LOGICAL NEW, PRTSEC
 LOGICAL, ALLOCATABLE :: BHR(:,:)
 CHARACTER (LEN=120) INP,TITLE
 Integer :: tvals(8)

! Specific parameters for Marco
! -----------------------------

 INTEGER NLYR,NPRISM,KSYMM
 REAL GND_LVL
 REAL, ALLOCATABLE, DIMENSION(:) :: THK,RES,RMU,REPS,CHRG,CTAU,CFREQ,LITHP
 INTEGER, DIMENSION (:), ALLOCATABLE :: NCELL_EW,NCELL_NS,NCELL_Z
 REAL, DIMENSION (:), ALLOCATABLE :: PRSM_RES,RMUP,REPSP,PRSM_CHRG,PRSM_TAU,PRSM_CFR, &
                                     PRSM_SIZE_EW,PRSM_SIZE_NS,PRSM_SIZE_Z
 REAL(KIND=8), DIMENSION (:), ALLOCATABLE :: PRISM_ZMIDD,PRISM_EASTD,PRISM_NORTHD
 REAL, DIMENSION (:), ALLOCATABLE :: PRISM_ZMID,PRISM_EAST,PRISM_NORTH
!

 REAL TN,TE
 INTEGER JB,JL,JP
!   LITHL and ID_LITH used both in READ_MODEL_DATA and LYTH_CHK
 INTEGER, DIMENSION(:), ALLOCATABLE :: LITHL,ID_LITH

!** moved back to subroutine
! REAL, PARAMETER :: PTOL = 1.0  !  Minimum prism dimension, and overlap tolerance
! INTEGER KEW,KNS,NPR1,NPR2,NP11,JP,PR_LYR,IDUMV,JB,JL
! REAL CELL_SIZE_EW,CELL_SIZE_NS,CELL_SIZE_Z,ESTRT,EFIN,NSTRT,NFIN,A, &
!      BOT,BOTP,TOP,TOPL,DUMV(9),PRISM_TOP
! INTEGER, ALLOCATABLE :: LBLK(:,:),QLB(:)    ! kind = 8 ??
! REAL, ALLOCATABLE :: PBLK(:,:),QPB(:,:)
!
 CONTAINS
!
   SUBROUTINE READ_SYSTEM_DATA
!  ---------------------------

!***  Called by MAIN
!***  Calls CUBSPL, CALL CONFIG_ID, WRYT_LOG_FILE

 IMPLICIT NONE
 INTEGER, PARAMETER :: MXTMP=1024		! was 300 which caused problems with arrays of magnetic dipoles
 INTEGER NEVNT_TX,KS,JS1,JRG,JRP,KRFIN,KRG,NRX1,FVERS
 INTEGER, ALLOCATABLE, DIMENSION(:) :: TX_INDX, RXG_INDX
 REAL RXOR
 REAL(KIND=8), ALLOCATABLE, DIMENSION(:,:,:) :: Q2E,Q2N,Q2Z
 LOGICAL REFT

 NR = 3       !  Set INPUT UNIT NUMBER
 NW = 4       !  Set OUTPUT UNIT NUMBER
 ND = 7       !  Set unit to store frequency domain input for reruns.
 NLG = 23     !  Set LOG FILE UNIT NUMBER
 T0SX = 100.

 OPEN(NR,FILE = 'Marco.cfl',STATUS = 'OLD')
 OPEN(NW,FILE = 'Marco.out',STATUS = 'REPLACE')
 OPEN(NLG,FILE = 'Marco.log',STATUS = 'REPLACE')

!      Initialise some variables.

 NEW = .TRUE.
 NDR = NR              !  Read from Marco.cfl
 MXERR = 0             !  Initialise input error flag
 DO3D = 1
 PRTSEC = .FALSE.
 REFT = .FALSE.
 REFTYM = 0.

!  Reproduce input data with no assignments and rewind file.
Call Date_and_time(Values = tvals)
Write (NW, 1) PNAME, PVERS, PDATE, PAUT1, PAUT2, PAUT3, PPROJ, PRELS, &
              compiler_version(), compiler_options(), &
              tvals(1:3), tvals(5:7)
Write ( *, 1) PNAME, PVERS, PDATE, PAUT1, PAUT2, PAUT3, PPROJ, PRELS, &
              compiler_version(), compiler_options(), &
              tvals(1:3), tvals(5:7)

!
! not any more ... 
! WRITE(NW,'(T11,A/T11,A/)') 'INPUT DATA', '----------'
! REFLECT_DATA: DO J = 1,200
!   READ(NR,'(A)',END = 100) INP
!   WRITE(NW,'(1X,A)') INP
! END DO REFLECT_DATA

 100 REWIND NR
     ! WRITE(NW,2)

 READ(NR,'(A)') TITLE
 WRITE(NW,'(/1X,A)') TITLE

! Read model control & print parameters

 READ(NR,*)  TDFD, PRFL, STEP, ISTOP
 WRITE(NW,3) TDFD, PRFL, STEP, ISTOP

!   TDFD = 1 (or -1) or 2 for TD or FD respectively.
!   PRFL - indicates profile or decay curve output
!  ISTOP - read data and stop if ISTOP = 1
!        - used as a frequency setter later on in this routine.

 MINFRQ = -1.;  MAXFRQ = -1.;  MXFRQE = -1.

 IF (TDFD == -1) THEN
   READ(NR,*)  MINFRQ, MAXFRQ, MXFRQE
   MAXFRQ = MAX (MAXFRQ,MXFRQE)
   WRITE(NW,7) MINFRQ, MAXFRQ, MXFRQE
   TDFD = 1
 END IF

 IF (TDFD /= 1 .AND. TDFD /= 2) CALL WRYT_LOG_FILE (NLG,1,MXERR,3)

 IF (PRFL < 0 .OR. PRFL > 1 ) THEN
   CALL WRYT_LOG_FILE (NLG,2,MXERR,2)
   PRFL = 1
 END IF

 IF (STEP /= 1 .AND. STEP /= 0) CALL WRYT_LOG_FILE (NLG,4,MXERR,3)

 IF (TDFD == 1) THEN                            ! Time-domain parameters
   READ(NR,*) DO3D,NSX,OFFTYM,NCHNL,KRXW
   WRITE(NW,4) DO3D, NSX, NCHNL, KRXW, OFFTYM
   IF (DO3D < 0) PRTSEC = .TRUE.
   DO3D = ABS(DO3D)

   IF (KRXW < 0) THEN     !  Check for shifted time origin for receiver channels
     REFT = .TRUE.
     KRXW = ABS (KRXW)
   END IF

   IF (DO3D < 2) THEN
     OPEN(ND,FILE = 'Marco.frq',STATUS = 'REPLACE')
   ELSE IF (DO3D == 2) THEN
     NEW = .FALSE.
     NDR = ND           ! Data to be read in from Marco.frq
     OPEN(ND,FILE = 'Marco.frq',STATUS = 'OLD')
   ELSE IF (DO3D > 2) THEN
     DO3D = 1
     CALL WRYT_LOG_FILE (NLG,3,MXERR,2)
   END IF

   IF (KRXW /= 1 .AND. KRXW /= 2) CALL WRYT_LOG_FILE (NLG,5,MXERR,3)


   IF (REFT) READ(NR,*) REFTYM

   ALLOCATE (TXON(NSX), WAVEFORM(NSX),TMS(NCHNL),WTMS(NCHNL),TOPN(NCHNL),TCLS(NCHNL),SWX(NSX),SWY(NSX,3))
   TXON=0.; WAVEFORM=0.; TMS=0.; WTMS=0.; TOPN=0.; TCLS=0; SWX=0; SWY=0

   READ(NR,*) (TXON(J),WAVEFORM(J), J = 1,NSX)  ! Read in source waveform.

   WRITE(NW,5)
   DO J = 1, NSX
     WRITE(NW,'(3X,I4,F13.3,5X,G13.4)') J,TXON(J),WAVEFORM(J)
     SWX(J) = 1.E-3 * TXON(J)
     SWY(J,3) = WAVEFORM(J)
   END DO
   PULSE = 1.E-3 * (OFFTYM + MAXVAL (TXON) )

   IF (KRXW == 1) THEN
     READ(NR,*) (TOPN(J) ,TCLS(J), J = 1,NCHNL)
     TMS = (TOPN + TCLS) / 2.
     WTMS = TCLS - TOPN
   ELSE
     READ(NR,*) TMS(1:NCHNL)
     READ(NR,*) WTMS(1:NCHNL)
     TCLS= TMS + WTMS /2.
     TOPN= TMS - WTMS /2.
   END IF

   IF (REFT) THEN
     WRITE(NW,25) REFTYM
   ELSE
     WRITE(NW,6)
   END IF

   TOPN = TOPN + REFTYM
   TCLS = TCLS + REFTYM
   DO J = 1,NCHNL
     IF (REFT) THEN
       WRITE(NW,'(7X,I4,2F12.3,F11.3,F12.3,F11.3)') J,TOPN(J),TCLS(J),WTMS(J),TMS(J)+REFTYM,TMS(J)
     ELSE
       WRITE(NW,'(7X,I4,2F12.3,F11.3,F12.3)') J,TOPN(J),TCLS(J),WTMS(J),TMS(J)
     END IF
     IF ( TOPN(J) <= 0) CALL WRYT_LOG_FILE (NLG,7,MXERR,3)
   END DO
   TOPN = 1.E-3 * TOPN
   TCLS = 1.E-3 * TCLS
 END IF

 IF (TDFD == 2) THEN          ! Frequency-domain systems
   NEW = .FALSE.
   READ(NR,*)  NFRQ
   WRITE(NW,8) NFRQ
   ALLOCATE( FREQ(NFRQ), CURNT(NFRQ))

! Read & write source waveform.

   WRITE(NW,9)
   DO J = 1, NFRQ
     READ(NR,*) FREQ(J),CURNT(J)
     WRITE(NW,'(3X,I4,F13.4,5X,G13.4)') J,FREQ(J),CURNT(J)
   END DO
 END IF

! Transmitter Information
! -----------------------
! Read in absolute locations in double precision variables and convert to
! REAL*4 body centred coordinates before entering the computation realm.


 READ(NDR,*) SOURCE_TYPE, SURVEY_TYPE, NTX, NRXG
 IF (SURVEY_TYPE > 1) NRXG = NTX
 IF (NEW) WRITE(ND,'(5I5)') SOURCE_TYPE, SURVEY_TYPE, NTX, NRXG

 WRITE(NW,10) SOURCE_TYPE, SURVEY_TYPE, NTX, NRXG

 IF (SOURCE_TYPE < 1 .OR. SOURCE_TYPE > 4) CALL WRYT_LOG_FILE (NLG,8,MXERR,3)
 ! IF (SOURCE_TYPE == 4) THEN
 !   WRITE(NW,'(/T3,A/)') 'MT OPTION NOT YET IMPLEMENTED.  NO EXECUTION.'
 !   WRITE(*,'(/T3,A/)') 'MT OPTION NOT YET IMPLEMENTED.  NO EXECUTION.'
 !   STOP
 ! END IF

 IF (SURVEY_TYPE < 1 .OR. SURVEY_TYPE > 4) CALL WRYT_LOG_FILE (NLG,10,MXERR,3)
 IF (SURVEY_TYPE == 1 .AND. NRXG == 0) CALL WRYT_LOG_FILE (NLG,11,MXERR,3)

 ALLOCATE (UNITS(NRXG),NRX(NRXG),RX_TYPE(NRXG),CMP(NRXG),NCMPG(NRXG),PRTCMP(10,NRXG))
 UNITS=0; NRX=1; MRX=1; MQVR=1; RX_TYPE=1; CMP=1

! When SURVEY_TYPE > 1, then the number of events is equal to the number
! and this can be used to set dimensions early.  Otherwise, the transmitter
! related dimensions have to wait until events are counted.

 IF (SURVEY_TYPE > 1) THEN  ! Allocate SURVEY_TYPE = 1 variables for degenerate case
   NTXE = NTX  ! Number of transmitters actually used.
   MRX = 1     ! Maximum number of receivers per group
   LRX = 1     ! Maximum number of receivers per transmitter
   MQVR = 1    ! Dipole receiver has 1 "corner"

   ALLOCATE (NRGTX(NTXE), NRXTX(NTXE), RGTXID(NRXG,NTXE),RXID(LRX,NTXE),BHR(LRX,NTXE),     &
             BHDIP(LRX,NTXE),BHAZ(LRX,NTXE),NCMP(LRX,NTXE),RXDIP(MRX,NRXG),RXAZ(MRX,NRXG), &
             RXED(MRX,NRXG,MQVR),RXND(MRX,NRXG,MQVR),RXZD(MRX,NRXG,MQVR),RXMNT(MRX,NRXG),  &
             RXE(MRX,NRXG,MQVR),RXN(MRX,NRXG,MQVR),RXZ(MRX,NRXG,MQVR))

   NRGTX = 1;  NRXTX = 1; RGTXID = 0; RXID = 1; BHR = .FALSE.; BHAZ = 0.; BHDIP = 0.
   NCMP = 1; RXMNT = 1.; RXN = 0.; RXE = 0.; RXZ = 0.; RXED = 0.D0; RXZD = 0.D0
   RXND = 0.D0; RXAZ = 0; RXDIP = 0.

   DO JS = 1,NTXE
     RGTXID(JS,JS) = JS
   END DO
 END IF

 ALLOCATE (SXED(MXTMP,NTX),SXND(MXTMP,NTX),SXZD(MXTMP,NTX),SXMNT(NTX),SXDIP(NTX),SXAZ(NTX),N_VRTX(NTX))
 N_VRTX = 1; SXMNT = 1; SXAZ = 0; SXDIP = 0; SXED = 0.D0; SXND = 0.D0; SXZD = 0.D0

 IF (SOURCE_TYPE < 3) THEN
   IF (SOURCE_TYPE == 1) WRITE(NW,11)
   IF (SOURCE_TYPE == 2) WRITE(NW,12)
   DO JS = 1,NTX
     READ(NDR,*) N_VRTX(JS)
     IF (NEW) WRITE(ND,'(I5)') N_VRTX(JS)
     WRITE(NW,13) JS,N_VRTX(JS)
     DO JV = 1, N_VRTX(JS)
       READ(NDR,*) SXED(JV,JS),SXND(JV,JS),SXZD(JV,JS)
       WRITE(NW,'(I5,3F14.2)') JV,SXED(JV,JS),SXND(JV,JS),SXZD(JV,JS)
       IF (NEW) WRITE(ND,'(3F14.2)') SXED(JV,JS),SXND(JV,JS),SXZD(JV,JS)
     END DO
   END DO

   MXVRTX = MAXVAL (N_VRTX)

 ELSE IF (SOURCE_TYPE == 3) THEN
   MXVRTX=1
   N_VRTX = 1
   WRITE(NW,14)
   DO JS = 1,NTX
     READ(NDR,*) SXED(1,JS),SXND(1,JS),SXZD(1,JS),SXDIP(JS),SXAZ(JS),SXMNT(JS)
     WRITE(NW,'(I5,3F14.2,2F9.1,F10.1)') JS,SXED(1,JS),SXND(1,JS),SXZD(1,JS),SXDIP(JS),SXAZ(JS),SXMNT(JS)
     IF(NEW) WRITE(ND,'(6F13.2)') SXED(1,JS),SXND(1,JS),SXZD(1,JS),SXDIP(JS),SXAZ(JS),SXMNT(JS)
   END DO
 END IF

 NCNTRD = 0.5D0 * (MAXVAL (SXND) + MINVAL (SXND) )  !  Working origin if DO3D = 0
 IF (ABS (NCNTRD) < 2.D3) NCNTRD = 0.D0
 ECNTRD = 0.5D0 * (MAXVAL (SXED) + MINVAL (SXED) )
 IF (ABS (ECNTRD) < 2.D3) ECNTRD = 0.D0

!   Receiver Group Specification
!   ----------------------------

 IF (SURVEY_TYPE == 4) THEN      ! Coincident Loop
   IF (SOURCE_TYPE > 1) CALL WRYT_LOG_FILE (NLG,16,MXERR,3)
   IF (TDFD == 2) CALL WRYT_LOG_FILE (NLG,17,MXERR,3)
   READ(NDR,*) UNITS(1)
   WRITE(NW,'(/A,I2)') '  Coincident loop voltage units =',UNITS(1)
   IF (NEW) WRITE(ND,'(I3)') UNITS(1)

 ELSE IF (SURVEY_TYPE == 2 .OR. SURVEY_TYPE == 3) THEN
   READ(NDR,*) RXOE,RXON,RXOZ,RXFMNT,CMP(1),UNITS(1)        ! mag dipole at fixed offfset
   IF (SOURCE_TYPE == 2) CALL WRYT_LOG_FILE (NLG,14,MXERR,3)

   IF (CMP(1) > 2) CMP(1) = 0
   IF (SOURCE_TYPE /= 3 .AND. CMP(1) == 2) CMP(1) = 0
   CMP = CMP(1)

   IF (NEW) WRITE(ND,'(4F13.2,2I5)') RXOE,RXON,RXOZ,RXFMNT,CMP(1),UNITS(1)
   WRITE(NW,16) RXOE,RXON,RXOZ,RXFMNT,CMP(1),UNITS(1)
   RXOR = ABS (RXOE) + ABS (RXON) + ABS (RXOZ)
   IF (SOURCE_TYPE == 3) THEN
     IF (RXOR < 0.01) CALL WRYT_LOG_FILE (NLG,15,MXERR,3)
     IF (SURVEY_TYPE == 3) CALL WRYT_LOG_FILE (NLG,6,MXERR,3)
   END IF
 ELSE IF (SURVEY_TYPE == 1) THEN
   ALLOCATE (RXED(MXTMP,NRXG,4), RXND(MXTMP,NRXG,4), RXZD(MXTMP,NRXG,4), &
             RXDIP(MXTMP,NRXG),  RXAZ(MXTMP,NRXG),   RXMNT(MXTMP,NRXG))
   RXZD = 0.D0; RXED = 0.D0; RXND = 0.D0; RXDIP = 0; RXAZ = 0; RXMNT = 1.

   DO JG = 1,NRXG
     READ(NDR,*) NRX(JG),RX_TYPE(JG), CMP(JG), UNITS(JG)
     IF (RX_TYPE(JG) /= 1) CMP(JG) = 1
     IF (NEW) WRITE(ND,'(4I6)') NRX(JG), RX_TYPE(JG), CMP(JG), UNITS(JG)
     WRITE(NW,17) JG, NRX(JG), RX_TYPE(JG), CMP(JG), UNITS(JG)

     IF (RX_TYPE(JG) == 1) THEN
       IF (CMP(JG) > 2)  CMP(JG) = 0
       IF (CMP(JG) < 2) THEN
         WRITE(NW,18)
         DO JR = 1, NRX(JG)
           READ (NDR,*) RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1), RXMNT(JR,JG)
           IF (NEW) WRITE(ND,'(4F12.2)') RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1), RXMNT(JR,JG)
           WRITE(NW,'(I4,3F13.2,F10.1)') JR,RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1),RXMNT(JR,JG)
         END DO
       ELSE IF (CMP(JG) == 2) THEN
         WRITE(NW,15)
         DO JR = 1, NRX(JG)
           READ (NDR,*) RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1),RXDIP(JR,JG), &
                        RXAZ(JR,JG),RXMNT(JR,JG)
           IF (NEW) WRITE(ND,'(6F12.2)') RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1), &
                                         RXDIP(JR,JG),RXAZ(JR,JG),RXMNT(JR,JG)
           WRITE(NW,'(I4,3F13.2,2F8.1,F12.1)') JR,RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1), &
                                               RXDIP(JR,JG),RXAZ(JR,JG),RXMNT(JR,JG)
         END DO
       END IF
     ELSE IF (RX_TYPE(JG) == 2) THEN
       WRITE(NW,19)
       MQVR = 4
       DO JR = 1, NRX(JG)
         DO JV = 1,4
           READ (NDR,*) RXED(JR,JG,JV),RXND(JR,JG,JV),RXZD(JR,JG,JV)
           IF (NEW) WRITE(ND,'(3F13.2)') RXED(JR,JG,JV),RXND(JR,JG,JV),RXZD(JR,JG,JV)

         END DO
         WRITE(NW,'(/I4,3F13.2)') JR,RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1)
         DO JV = 2,4
           WRITE(NW,'(4X,3F13.2)')  RXED(JR,JG,JV),RXND(JR,JG,JV), RXZD(JR,JG,JV)
         END DO
       END DO

     ELSE IF (RX_TYPE(JG) == 3) THEN
       WRITE(NW,20)
       MQVR = MAX (MQVR,2)
       DO JR = 1, NRX(JG)
         DO JV = 1,2
           READ (NDR,*) RXED(JR,JG,JV),RXND(JR,JG,JV),RXZD(JR,JG,JV)
           IF (NEW) WRITE(ND,'(3F13.2)') RXED(JR,JG,JV),RXND(JR,JG,JV),RXZD(JR,JG,JV)
         END DO
         WRITE(NW,'(I4,6F13.2)') JR,RXED(JR,JG,1),RXND(JR,JG,1),RXZD(JR,JG,1), &
                                      RXED(JR,JG,2),RXND(JR,JG,2),RXZD(JR,JG,2)
       END DO
     END IF
   END DO
   MRX = MAXVAL (NRX)
 END IF

 LRX = 1
 IF (SURVEY_TYPE == 1) THEN
   READ(NDR,*) NEVENTS
   IF (NEW) WRITE(ND,'(I4)') NEVENTS
   WRITE(NW,30) NEVENTS
   IF (NEVENTS < 1) THEN
     CALL WRYT_LOG_FILE (NLG,12,MXERR,3)
   ELSE IF (NEVENTS < NTX) THEN
     CALL WRYT_LOG_FILE (NLG,13,MXERR,1)
   END IF

   ALLOCATE (RXG_INDX(NEVENTS), TX_INDX(NEVENTS))
   DO JS = 1, NEVENTS
     READ(NDR,*) TX_INDX(JS), RXG_INDX(JS)
     IF (NEW) WRITE(ND,'(2I4)') TX_INDX(JS), RXG_INDX(JS)
     WRITE(NW,'(I6,2I8,I7)') JS, TX_INDX(JS), RXG_INDX(JS), NRX(RXG_INDX(JS))
   END DO

!  Set up transmitter indexing system based on the events.
!  First count the number of transmitters used in events for dimensioning purposes.

   NTXE = 0
   TX_CNT: DO JS = 1,NTX   !  Compute the actual number of transmitters in use
     DO J = 1,NEVENTS
       IF (TX_INDX(J) == JS) THEN
         NTXE = NTXE + 1
         CYCLE TX_CNT
       END IF
     END DO
   END DO TX_CNT

   ALLOCATE (NRXTX(NTXE), TXID(NTXE), RGTXID(NRXG,NTXE), NRGTX(NTXE))
   NRXTX = 0; TXID = 0; RGTXID = 0; NRGTX = 0
   KS = 0

   DO JS = 1,NTX   !  Compute the actual number of transmitters in use
     NEVNT_TX = 0

     DO J = 1,NEVENTS
       IF (TX_INDX(J) == JS) THEN
         NEVNT_TX = NEVNT_TX + 1   ! The number of events using transmitter Tx
         IF (NEVNT_TX == 1) THEN   ! Use KS as the new transmitter index of
           KS = KS + 1             !   transmitters that are actually used.
           TXID(KS) = JS           ! Identify new Tx index with old one
         END IF                    ! Don't count transmitters more han once

         NRGTX(KS) = NEVNT_TX                 ! Update the number of receiver groups new Tx index, KS
         RGTXID(NEVNT_TX,KS) = RXG_INDX(J)    ! Identify Rx Group number
         NRXTX(KS) = NRXTX(KS) + NRX (RXG_INDX(J)) ! Update total number of Rx for transmitter index KS
       END IF
     END DO
   END DO
   LRX = MAXVAL (NRXTX)
   DEALLOCATE (RXG_INDX, TX_INDX)

 ELSE
   NCMP = 1
   IF (RX_TYPE(1) == 1) NCMP = 3
   UNITS = UNITS(1)
 END IF

!  Reset dimensions for transmitters

 ALLOCATE (Q2N(MXVRTX,NTXE,2), Q2E(MXVRTX,NTXE,2), Q2Z(MXVRTX,NTXE,2), CLCD(3,NTXE) )
 CLCD = 0.D0

 DO JS1 = 1, NTXE
   JS = JS1
   IF (SURVEY_TYPE == 1) JS = TXID(JS1)
   Q2N(1:MXVRTX,JS1,1) = SXND(1:MXVRTX,JS)
   Q2E(1:MXVRTX,JS1,1) = SXED(1:MXVRTX,JS)
   Q2Z(1:MXVRTX,JS1,1) = SXZD(1:MXVRTX,JS)

   Q2N(1,JS1,2) = SXAZ(JS)
   Q2E(1,JS1,2) = SXDIP(JS)
   Q2Z(1,JS1,2) = SXMNT(JS)

 END DO
 DEALLOCATE (SXND,SXED,SXZD,SXAZ,SXDIP,SXMNT)

 ALLOCATE (SXED(MXVRTX,NTXE), SXND(MXVRTX,NTXE), SXZD(MXVRTX,NTXE), &
           SXE(MXVRTX,NTXE),  SXN(MXVRTX,NTXE),  SXZ(MXVRTX,NTXE),  &
           SXDIP(NTXE),       SXAZ(NTXE),        SXMNT(NTXE))

 SXE =  0.;  SXN  = 0.;  SXZ  = 0.  !  Centred system to be defined later

 DO JS = 1, NTXE
   SXND(1:MXVRTX,JS) = Q2N(1:MXVRTX,JS,1)
   SXED(1:MXVRTX,JS) = Q2E(1:MXVRTX,JS,1)
   SXZD(1:MXVRTX,JS) = Q2Z(1:MXVRTX,JS,1)

   SXAZ(JS)  = REAL (Q2N(1,JS,2) )
   SXDIP(JS) = REAL (Q2E(1,JS,2) )
   SXMNT(JS) = REAL (Q2Z(1,JS,2) )
 END DO
 DEALLOCATE (Q2N, Q2E, Q2Z)

 IF (SURVEY_TYPE == 1) THEN ! Reset receivers

   ALLOCATE (Q2N(MRX,NRXG,MQVR+1), Q2E(MRX,NRXG,MQVR+1), Q2Z(MRX,NRXG,MQVR+1) )

   DO JG = 1, NRXG
     DO JV = 1,MQVR
       Q2N(1:MRX,JG,JV) = RXND(1:MRX,JG,JV)
       Q2E(1:MRX,JG,JV) = RXED(1:MRX,JG,JV)
       Q2Z(1:MRX,JG,JV) = RXZD(1:MRX,JG,JV)
     END DO
     Q2N(1:MRX,JG,MQVR+1) = RXAZ(1:MRX,JG)
     Q2Z(1:MRX,JG,MQVR+1) = RXDIP(1:MRX,JG)
     Q2E(1:MRX,JG,MQVR+1) = RXMNT(1:MRX,JG)
   END DO
   DEALLOCATE (RXND,RXED,RXZD,RXAZ,RXDIP,RXMNT)

   ALLOCATE (RXED(MRX,NRXG,MQVR), RXND(MRX,NRXG,MQVR), RXZD(MRX,NRXG,MQVR), &
             RXE(MRX,NRXG,MQVR),  RXN(MRX,NRXG,MQVR),  RXZ(MRX,NRXG,MQVR), &
             RXDIP(MRX,NRXG),  RXAZ(MRX,NRXG), RXMNT(MRX,NRXG))

   RXE = 0.; RXN = 0.; RXZ = 0.

   DO JG = 1, NRXG
     DO JV = 1,MQVR
       RXND(1:MRX,JG,JV) = Q2N(1:MRX,JG,JV)
       RXED(1:MRX,JG,JV) = Q2E(1:MRX,JG,JV)
       RXZD(1:MRX,JG,JV) = Q2Z(1:MRX,JG,JV)
     END DO
     RXAZ(1:MRX,JG)  = REAL (Q2N(1:MRX,JG,MQVR+1) )
     RXDIP(1:MRX,JG) = REAL (Q2Z(1:MRX,JG,MQVR+1) )
     RXMNT(1:MRX,JG) = REAL (Q2E(1:MRX,JG,MQVR+1) )
   END DO

 ELSE IF (SURVEY_TYPE == 2 .OR. SURVEY_TYPE == 3) THEN

! Convert receiver offsets to absolute positions (REAL*8)

   RXMNT = RXFMNT
   RXAZ = 0
   RXDIP = 0
   IF (SOURCE_TYPE == 1) THEN
     DO JS = 1,NTXE
       JV = N_VRTX(JS)
       QD = SUM (SXED(1:JV,JS)) / REAL (JV,8)
       RXED(1,JS,1) = QD + REAL (RXOE,8)
       QD = SUM (SXND(1:JV,JS)) / REAL (JV,8)
       RXND(1,JS,1) = QD + REAL (RXON,8)
       QD = SUM (SXZD(1:JV,JS)) / REAL(JV,8)
       RXZD(1,JS,1) = QD + REAL (RXOZ,8)
     END DO

   ELSE IF (SOURCE_TYPE == 3) THEN
     RXED(1,1:NTX,1) = SXED(1,1:NTX) + REAL (RXOE,8)
     RXND(1,1:NTX,1) = SXND(1,1:NTX) + REAL (RXON,8)
     RXZD(1,1:NTX,1) = SXZD(1,1:NTX) + REAL (RXOZ,8)
     IF (CMP(1) > 0) THEN
       BHR(1,1:NTXE) = .TRUE.
       RXAZ(1,1:NTXE) = SXAZ(1:NTXE)
       RXDIP(1,1:NTXE) = SXDIP(1:NTXE)
       BHAZ(1,1:NTXE) = SXAZ(1:NTXE) * PI / 180.

!  Convert from borehole convention to computation convention.
       BHDIP(1,1:NTXE) = (90. - SXDIP(1:NTXE)) * PI / 180.
!-------------------------------------------------------
     END IF
   END IF
 END IF

 PRTCMP = 0; NCMPG = 1
 PRTCMP(1,1:NRXG) = 1  ! Put default response into component 1

 DO JG = 1,NRXG
   IF (RX_TYPE(JG) /= 1 .OR. SURVEY_TYPE == 4) CYCLE         !  Only magnetic dipole receivers have alternatives
   IF (CMP(JG) /= 1) NCMPG(JG) = 3

! For unrotated systems the following will result in printing out the
! vertical component first followed by the east and north components.
! For rotated systems, the axial component will be printed out first
! followed by the Slope and Horizontal components.
! Note that for constant offset systems, if the user chooses to print
! only one component, this will be the vertical one for unrotated
! systems and the maximally coupled component for rotated systems.

   PRTCMP(1,JG) = 3   !  Print vertical component first
   PRTCMP(2,JG) = 2   !  followed by east component
   PRTCMP(3,JG) = 1   !  followed by north component

   IF (CMP(JG) == 2) THEN              !  Use Axial, Slope & Horizontal borehole coordinates
     PRTCMP(1,JG) = 6                  !  Print the axial component, first
     PRTCMP(2,JG) = 5                  !  followed by the Slope component
     PRTCMP(3,JG) = 4                  !  followed by the Horizontal component
   END IF
   IF (CMP(JG) == 1 .AND. SOURCE_TYPE == 3) PRTCMP(1,JG) = 6
 END DO

!  For Survey Type 1, assign the receiver type, number of computed components
!  the dip and azimuth of the receivers in a given receiver group to the
!  appropriate receivers belonging to each transmitter

 IF (SURVEY_TYPE == 1) THEN
   ALLOCATE (NCMP(LRX,NTXE), RXID(LRX,NTXE), BHR(LRX,NTXE), BHAZ(LRX,NTXE), BHDIP(LRX,NTXE))
   BHR = .FALSE.; BHDIP = 0.; BHAZ = 0.
   NCMP = 1                             !  Set the number of components for each receiver (1 or 3)

   DO JS = 1, NTXE
     KRFIN = 0
     DO JRG = 1, NRGTX(JS)
       KRG = RGTXID(JRG,JS)    ! Receiver Group index for group JRG for Tx JS
       NRX1 = NRX(KRG)         ! Number of receivers in receiver group KRG
       DO JR = 1,NRX1
         JRP = JR + KRFIN
         RXID(JRP,JS) = RX_TYPE(KRG)
         IF (RX_TYPE(KRG) == 1) NCMP(JRP,JS) = 3

         IF (CMP(KRG) == 2) THEN
           BHR(JRP,JS) = .TRUE.
           BHAZ(JRP,JS) = RXAZ(JR,KRG) * PI / 180.

!  Convert from borehole convention to computation convention.
           BHDIP(JRP,JS) = (90. - RXDIP(JR,KRG)) * PI / 180.
!-------------------------------------------------------
         END IF
       END DO
       KRFIN = KRFIN + NRX1  ! Set index for next group
     END DO                  ! End of Rx groups for transmitter JS
   END DO
 END IF

  1 Format (/, 2x, 78('-'), &
    /, 2x, '| Program:  ', a, &
    /, 2x, '| Version:  ', a, &
    /, 2x, '| Date:     ', a, &
    /, 2x, '|', &
    /, 2x, '| Authors:  ', a, &
    /, 2x, '|           ', a, &
    /, 2x, '| Contact:  ', a, &
    /, 2x, '| Project:  ', a, &
    /, 2x, '| License:  ', a, &
    /, 2x, '|', &
    /, 2x, '| Compiler: ', a, &
    /, 2x, '| Options:  ', a, &
    /, 2x, '|', &
    /, 2x, '| Started:  ', i4.4, '-', i2.2, '-', i2.2, 'T', i2.2, ':', i2.2, ':', i2.2, &
    /, 2x, 78('-'), /)
 2 FORMAT (T1,79('-'))
 3 FORMAT(/T3,'TDFD =',I2,';   PRFL =',I2,';   STEP =',I2,';   ISTOP =',I2)
 4 FORMAT(/10X,'+-----------------------------------------+' &
          /10X,'+  Time-Domain Ground System Information  +' &
          /10X,'+-----------------------------------------+' &
         // T3,'DO3D =',I3,';   NSX =',I4,';   NCHNL =',I4, &
         /T3,'KRXW =',I2,';    OFFTYM =',G12.4)
 5 FORMAT(//T14,'TXON (ms)    Transmitter current (amps)' &
           /T14,'---------    --------------------------'/)
 6 FORMAT(//T10,'Receiver Window Specifications (ms - referenced to signal origin)'/ &
            T10,'----------------------------------------------------------------'// &
            T8,'Window',T19,'Open',T30,'Close',T42,'Width',T52,'Centre'/ &
            T8,'------',T19,'----',T30,'-----',T42,'-----',T52,'------')
 7 FORMAT(/T3,'MINFRQ =',G12.4,' Hz.  MAXFRQ =',G12.4,' Hz.    MXFRQE =',G12.4,' Hz.')
 8 FORMAT(/10X,'+----------------------------------------------+' &
          /10X,'+  Frequency-Domain Ground System Information  +' &
          /10X,'+----------------------------------------------+' &
          //T3,'NFRQ =',I3)
 9 FORMAT(/T12,'Frequency      Transmitter current in amps', &
          /T12,'---------      ---------------------------'/)
10 FORMAT(//T3,'SOURCE_TYPE =',I2,';   SURVEY_TYPE =',I2,';   NTX =',I3,';   NRXG =',I2/)
11 FORMAT(/T3,'Vertex Locations for Loop Sources' &
          /T3,'---------------------------------')
12 FORMAT(/T3,'Vertex Locations for Grounded Wire Sources' &
          /T3,'------------------------------------------')
13 FORMAT(/T3,'Transmitter',I3,' has',I3,' vertices.' &
         //T13,'Easting      Northing      Elevation' &
          /T13,'-------      --------      ---------')
14 FORMAT(/T3,'Dipole Source Specification' &
         //T12,'Easting       Northing      Elevation     Dip   Azimuth   Moment' &
          /T12,'-------       --------      ---------     ---   -------   ------')
15 FORMAT(/T11,'Magnetic Dipole Receivers' &
          /T11,'-------------------------' &
         //T11,'Easting     Northing     Elevation   Dip    Azimuth    Moment' &
          /T11,'-------     --------     ---------   ---    -------    ------')
16 FORMAT(/T3,'Fixed Offset for Magnetic Dipole Receiver', &
          /T3,'-----------------------------------------' &
          /T6,'East        North     Vertical   Moment    CMP  UNITS'/4F11.2,2I6)
17 FORMAT(//T3,'Rx Group:',I3,';   NRX =',I3,';   Type =',I2,';   CMP =',I2,';   Units =',I2)
18 FORMAT(/T11,'Magnetic Dipole Receivers' &
          /T11,'-------------------------' &
         //T11,'Easting     Northing      Elevation   Moment' &
          /T11,'-------     --------      ---------   ------')
19 FORMAT(/T11,'Receiver Loop Vertices' &
          /T11,'----------------------' &
         //T11,'Easting     Northing      Elevation' &
          /T11,'-------     --------      ---------')
20 FORMAT(/T12,'Electric Dipole Receiver Electrodes' &
          /T12,'-----------------------------------' &
         //T12,'East 1      North 1     Elevation 1    East 2      North 2     Elevation 2' &
          /T12,'------      -------     -----------    ------      -------     -----------')
25 FORMAT(/T10,'Receiver channel origin INPUT is shifted by', F9.3,' ms from signal origin.' &
         //T10,'Receiver Window Specifications (ms - referenced to signal origin)'/ &
            T10,'----------------------------------------------------------------'// &
            T62,'Referenced'/ &
            T8,'Window',T19,'Open',T30,'Close',T42,'Width',T52,'Centre',T64,'Centre'/ &
            T8,'------',T19,'----',T30,'-----',T42,'-----',T52,'------',T64,'------')
30 FORMAT(/T5,'This survey is composed of',I3,' events.' &
         //T14,'Tx   Rx Group'/T4,'Event   Index  Index    NRX'/)

   END SUBROUTINE READ_SYSTEM_DATA
!
   SUBROUTINE READ_MODEL_DATA
!  --------------------------

!***  Called by MAIN
!***  Calls CHK_SYMMETRY, WRYT_LOG_FILE

!  This subroutine was revised to allow checking for prism geometry
!  names have also been changed to be more descriptive.
!  SUBROUTINE MARCO_3D is called with these new names but nothing
!  was changed within that part of the program.
!  The record order was changed.  Also the user now specifies cell size
!  rather than the  number of cells.  The routine calculates the number
!  of cells to output to SUBROUTINE MARCO_3D.  The following relates the
!  variables of this subroutine with Xiong's MARCO_3D


!   TRGT_BLCK = NPRISM
!   BLCK_NY = NCELL_EW    BLCK_LY = PRSM_SIZE_EW    BLCK_CX = PRISM_NORTH
!   BLCK_NX = NCELL_NS    BLCK_LX = PRSM_SIZE_NS    BLCK_CY = PRISM_EAST
!   BLCK_NZ = NCELL_Z     BLCK_LZ = PRSM_SIZE_Z     BLCK_CZ = PRISM_ZMID

 REAL, PARAMETER :: PTOL = 1.0  !  Minimum prism dimension, and overlap tolerasnce
 INTEGER NPR1,NPR2,NP11,JP,J,PR_LYR,IDUMV,KEW,KNS
 INTEGER, ALLOCATABLE :: LBLK(:,:)
 REAL CELL_SIZE_EW,CELL_SIZE_NS,CELL_SIZE_Z,A,ESTRT,EFIN,NSTRT,NFIN, &
      BOT,BOTP,TOP,TOPL,DUMV(9),PRISM_TOP,DUMVZ
 REAL(KIND=8) DUMVE,DUMVN
 REAL, ALLOCATABLE :: PBLK(:,:) !,QPB(:,:)
 REAL, ALLOCATABLE, DIMENSION(:) :: DEPTH


 READ(NDR,*) NLYR, NPRISM, NLITH, GND_LVL
 IF (NEW) WRITE(ND,'(3I6,G12.4,A)') NLYR, NPRISM, NLITH, GND_LVL,'!  NLYR, NSHT, NLITH, GND_LVL'
 WRITE(NW,1) NLYR, NPRISM, NLITH, GND_LVL

 If (NPRISM < 0) Then
 	KSYMM = 0
 	NPRISM = Abs(NPRISM)
 Else 
 	KSYMM = 1
 End If
 IF (NPRISM .eq. 0) DO3D = 0
 ALLOCATE (DEPTH(NLYR),THK(NLYR),RES(NLYR),CHRG(NLYR),CTAU(NLYR),CFREQ(NLYR), &
           RMU(NLYR),REPS(NLYR),LITHL(NLYR), ID_LITH(NLITH),LYTH(NLITH,NPROP))

 DEPTH=0.; THK=0; RES=0; CHRG=0; CTAU=0; CFREQ=0; RMU=1; REPS=1
 LITHL=0; ID_LITH=0

 IF (DO3D == 0 .AND. NPRISM > 0) WRITE(NW,2) NPRISM

!  Initialise temporary lithology list.  Eliminate duplicate lithologies

 LYTH(1:NLITH, 1) = -1.   !  blank resistivity indicator
 LYTH(1:NLITH, 2) = -1.   !  blank conductance (SIG_T) indicator
 LYTH(1:NLITH, 3) = 1.    !  Relative magnetic permeabilities
 LYTH(1:NLITH, 4) = 1.    !  Relative dielectric constants
 LYTH(1:NLITH, 5) = 0.    !  Chargeabilities
 LYTH(1:NLITH, 6) = 0.    !  CTAUs
 LYTH(1:NLITH, 7) = 1.    !  CFREQs

 DO JL = 1,NLITH
   READ (NDR,*) LYTH(JL,1:NPROP)
   IF (NEW) WRITE(ND,'(7G14.5)') LYTH(JL,1:NPROP)

   IF (LYTH(JL,3) < 0.01) LYTH(JL,3) = 1.   ! Default RMU
   IF (LYTH(JL,4) < 0.01) LYTH(JL,4) = 1.   ! Default REPS


   IF (LYTH(JL,5) < 1.E-3 .OR. LYTH(JL,6) < 1.E-15 .OR. LYTH(JL,7) < 1.E-6)  THEN
     LYTH(JL,5) = 0   ! default CHRG
     LYTH(JL,6) = 0   ! default CTAU
     LYTH(JL,7) = 1   ! default CFRQ
   END IF

 END DO

 CALL LYTH_CHK   !  Eliminate duplicate lithologies.

! Read Layered Earth Model

 DEPTH(NLYR) = 1.E6
 WRITE(NW,8)

 IF (NLYR > 1) THEN
   DO JL = 1, NLYR-1
     READ (NDR,*) LITHL(JL), THK(JL)
     IF (NEW) WRITE(ND,'(I5,G13.5)') LITHL(JL), THK(JL)
     LITHL(JL) = ID_LITH(LITHL(JL))
     IF (JL == 1) THEN
       DEPTH(1) = THK(1)
     ELSE
       DEPTH(JL) = THK(JL) + DEPTH(JL-1)
     END IF
     WRITE(NW,'(2I4,F7.1,T19,A)') JL, LITHL(JL), THK(JL),'J, LITHL(J), THK(J)'
   END DO
 END IF
 READ(NDR,*) LITHL(NLYR)
 IF (NEW) WRITE(ND,'(I5)') LITHL(NLYR)
 LITHL(NLYR) = ID_LITH(LITHL(NLYR))
 WRITE(NW,'(2I4,T22,A)') NLYR,LITHL(NLYR),'Basement Lithology'

 DO JL = 1, NLYR
   J = LITHL(JL)

   IF (J < 1 .OR. J > NLITH) THEN
     WRITE(NW,'(T3,A,I2,A,I4)') 'LITHL(',JL,') =',J
     CALL WRYT_LOG_FILE (NLG,22,MXERR,2)
   END IF

   RES(JL)  =  LYTH(J,1)
   RMU(JL) =   LYTH(J,3)
   REPS(JL) = LYTH(J,4)
   CHRG(JL) =  LYTH(J,5)
   CTAU(JL) =  LYTH(J,6)
   CFREQ(JL) = LYTH(J,7)
 END DO

!*************************
!*************************

 IF (DO3D == 0) THEN
   OUTPUT = 10
   RETURN
 END IF
!*************************
!*************************

 READ (NDR,*) KACC,SOLVER,OUTPUT

!  OUTPUT = 10 => write out total fields only
!  OUTPUT = 11 => include scattered fields in .OUT file but not in .AMX file
!  OUTPUT = 12 => include scattered fields in both .OUT and .AMX files
!  OUTPUT = -10, -11, or -12. then .AMX file will Ignore PPM data and print field values
!  OUTPUT = 20, 21, or 22. then .AMX file will print blocked fields corresponding to
!           10, 11, or 12 for unblocked option

 IF (OUTPUT < -12) OUTPUT = 10
 IF (OUTPUT > -9 .AND. OUTPUT < 11) OUTPUT = 10
 IF (OUTPUT > 12 .AND. OUTPUT < 20) OUTPUT = 10
 IF (OUTPUT > 22) OUTPUT = 10

 IF (PRTSEC .AND. OUTPUT == 10) OUTPUT = 11
 IF (OUTPUT > 10) PRTSEC = .TRUE.
 IF (OUTPUT < -10) PRTSEC = .TRUE.
 IF (OUTPUT == 20) PRTSEC = .FALSE.

 IF (NEW) WRITE(ND,'(2I4)') KACC,SOLVER,OUTPUT
 WRITE(NW,4)  NPRISM, KACC, SOLVER,OUTPUT
 IF (SOLVER /= 1 .AND. SOLVER /= 2) THEN
   SOLVER = 1
   CALL WRYT_LOG_FILE (NLG,17,MXERR,1)
 END IF

 IF (KACC < 1 .OR. KACC > 3) KACC = 2
 IF (KACC == 1) WRITE(NW,5)

 NP11 = 11 * NPRISM
 ALLOCATE (LBLK(NP11,2), PBLK(NP11,9))
 LBLK=0; PBLK=0

! Initially, prism variabes are read into a pre-dummy array before
! being transferred to LBLK & PBLK.
! LBLK & PBLK are dummy arrays used to modify prism structure.
! Checks need to be made for prisms which cross layer boundaries
! & whether 2 fold symmetry is pressent.
! After this is done, the value of NPRISM is determined and the variables
! can be given their proper names.

 LBLK = 0
 PBLK = 0
 NPR1 = 0

!  For distant origins, it is necessary to read horizontal coordinates into
!  REAL(KIND=8) variables DUMVE, DUMVN to maintain precision.  If either has
!  an absolute value greater than 2000, the origin is shifted to above the
!  first prism.  The depths to the top of the prisms are now read in as RLs
!  (negative down so they need to be converted to positive depths below
!  surface to minimise changes to MARCO_3D.


 ECNTRD = 0.D0; NCNTRD = 0.D0
 PR1: DO J = 1, NPRISM

!               LITHP(J),   PRISM_EAST(J), PRISM_NORTH(J), PRISM_TOP
   READ (NDR,*) IDUMV,      DUMVE,         DUMVN,          DUMVZ
   IF (J == 1) THEN
     IF (ABS (DUMVN) > 2.D3) NCNTRD = DUMVN
     IF (ABS (DUMVE) > 2.D3) ECNTRD = DUMVE

   END IF
   DUMV(1) = REAL (DUMVE - ECNTRD)
   DUMV(2) = REAL (DUMVN - NCNTRD)
   DUMV(3) = GND_LVL - DUMVZ

   IF (NEW) WRITE(ND,'(I4,3G14.6)') IDUMV,DUMVE,DUMVN,DUMVZ
   IF (DUMV(3) < 0) THEN
     DUMV(3) = 0
     WRITE(NW,6) J
   END IF

   IF (IDUMV < 1 .OR. IDUMV > NLITH) THEN
     WRITE(NW,'(T3,A,I2,A,I4)') 'LITHP(',J,') =',IDUMV
     CALL WRYT_LOG_FILE (NLG,16,MXERR,2)
   END IF

   IDUMV = ID_LITH(IDUMV)  !  Assign common lithological index
   WRITE(NW,'(/T3,A,2I4,T56,3F12.1)') 'J, LITHP, PRISM_EAST, PRISM_NORTH, PRISM_TOP:', &
                                   J, IDUMV,DUMVE,DUMVN,DUMVZ

!               PRSM_SIZE_EW(J), PRSM_SIZE_NS(J), PRSM_SIZE_Z(J)
   READ (NDR,*) DUMV(4),         DUMV(5),         DUMV(6)
   IF (NEW) WRITE(ND,'(3G14.6)') DUMV(4:6)
   WRITE(NW,'(T6,A,T56,3F12.1)') 'PRSM_SIZE_EW, PRSM_SIZE_NS, PRSM_SIZE_Z', DUMV(4:6)

!               CELL_SIZE_EW(J), CELL_SIZE_NS(J), CELL_SIZE_Z(J)
   READ (NDR,*) DUMV(7),         DUMV(8),         DUMV(9)
   DUMV(7) = MIN (DUMV(7), DUMV(4))
   DUMV(8) = MIN (DUMV(8), DUMV(5))
   DUMV(9) = MIN (DUMV(9), DUMV(6))

   IF (NEW) WRITE(ND,'(3G14.6)') DUMV(7:9)
   WRITE(NW,'(T6,A,T56,3F12.1)') 'CELL_SIZE_EW, CELL_SIZE_NS, CELL_SIZE_Z', DUMV(7:9)


!  Eliminate PRISMS whose minimum dimension < 1 m.  If NLYR = 1, eliminate
!  prisms with the same lithology as that of the half-space.

   IF (MINVAL (DUMV(4:6)) < PTOL) THEN
      WRITE(NW,10) PTOL
      CYCLE PR1
   END IF

   IF (NLYR == 1 .AND. IDUMV == LITHL(1) ) THEN
      WRITE(NW,11)
      CYCLE PR1
   END IF

   NPR1 = NPR1 + 1
   LBLK(NPR1,1) = IDUMV
   PBLK(NPR1,1:9) = DUMV(1:9)
 END DO PR1
 NPRISM = NPR1

 IF (NPRISM < 1) THEN
   DO3D = 0
   WRITE(NW,12)
   RETURN
 END IF

! If any prisms cross layer boundaries, create new prisms.  Eliminate
! prisms which have the same lithology as the layer which contains them.

 IF (NLYR > 1) THEN

   NPR2 = 0
   PR2: DO JP = 1, NPR1
     BOTP = PBLK(JP,3) + PBLK(JP,6)
     LYR1: DO JL = 1, NLYR
       IF (PBLK(JP,3) + PTOL < DEPTH(JL)) THEN
         PR_LYR = JL   !  The top of prism J and at least
         EXIT LYR1     !  0.1 m of it are in layer JL
       END IF
     END DO LYR1

     TOPL = 0
     LYR2: DO JL = PR_LYR, NLYR
       IF (LBLK(JP,1) /= LITHL(JL)) THEN
         IF (JL > 1) TOPL = DEPTH(JL-1)
         TOP = MAX (TOPL, PBLK(JP,3))
         BOT = MIN (DEPTH(JL), BOTP)
         IF (BOT < TOP + PTOL) CYCLE LYR2
         NPR2 = NPR2 + 1
         LBLK(NPR2+NPR1,1) = LBLK(JP,1)
         PBLK(NPR2+NPR1,3) = TOP
         PBLK(NPR2+NPR1,6) = BOT - TOP
         PBLK(NPR2+NPR1,1:2) = PBLK(JP,1:2)
         PBLK(NPR2+NPR1,4:5) = PBLK(JP,4:5)
         PBLK(NPR2+NPR1,7:9) = PBLK(JP,7:9)

         IF (BOTP < DEPTH(JL) + PTOL) CYCLE PR2
       END IF
     END DO LYR2

   END DO PR2

   IF (NPR2 /= NPRISM) WRITE(NW,7)
   NPRISM = NPR2
   DO J = 1, NPRISM   !  Move new block structure to the top
     PBLK(J, 1:9) = PBLK(NPR1+J, 1:9)
     LBLK(J, 1) = LBLK(NPR1+J, 1)
   END DO
 END IF

 PBLK(NPRISM+1:NP11, 1:6) = 0.
 LBLK(NPRISM+1:NP11, 1) = 0
 LBLK(1:NP11, 2) = 0

 If (KSYMM .ne. 0) Then
   CALL CHK_SYMMETRY (NPRISM,NP11,LBLK,PBLK,TE,TN,KSYMM)
 End If
 IF (KSYMM == 1) WRITE(NW,13) TE,TN

 ALLOCATE (LITHP(NPRISM),PRISM_EAST(NPRISM),PRISM_NORTH(NPRISM),PRSM_SIZE_EW(NPRISM),  &
           PRSM_SIZE_NS(NPRISM),PRSM_SIZE_Z(NPRISM),NCELL_EW(NPRISM),NCELL_NS(NPRISM), &
           NCELL_Z(NPRISM),PRISM_ZMID(NPRISM),PRSM_RES(NPRISM),RMUP(NPRISM),           &
           REPSP(NPRISM),PRSM_CHRG(NPRISM),PRSM_TAU(NPRISM),PRSM_CFR(NPRISM))

 LITHP=0; PRISM_EAST=0; PRISM_NORTH=0; PRSM_SIZE_EW=0; PRSM_SIZE_NS=0; PRSM_SIZE_Z=0
 NCELL_EW=0; NCELL_NS=0; NCELL_Z=0; PRISM_ZMID=0; PRSM_RES=0; RMUP=1; REPSP=1
 PRSM_CHRG=0; PRSM_TAU=0; PRSM_CFR=0

 DO J = 1, NPRISM
   JL = LBLK(J,1)

   LITHP(J) = JL

   PRSM_RES(J)  = LYTH(JL,1)
   RMUP(J)      = LYTH(JL,3)
   REPSP(J)     = LYTH(JL,4)
   PRSM_CHRG(J) = LYTH(JL,5)
   PRSM_TAU(J)  = LYTH(JL,6)
   PRSM_CFR(J)  = LYTH(JL,7)

   PRISM_EAST(J)   = PBLK(J,1)
   PRISM_NORTH(J)  = PBLK(J,2)
   PRISM_TOP       = PBLK(J,3)
   PRSM_SIZE_EW(J) = PBLK(J,4)
   PRSM_SIZE_NS(J) = PBLK(J,5)
   PRSM_SIZE_Z(J)  = PBLK(J,6)
   CELL_SIZE_EW    = PBLK(J,7)
   CELL_SIZE_NS    = PBLK(J,8)
   CELL_SIZE_Z     = PBLK(J,9)

!  Construct the number of cells in each dimension

   NCELL_EW(J) = INT (PRSM_SIZE_EW(J) / CELL_SIZE_EW)
   IF (NCELL_EW(J) < 1 ) NCELL_EW(J) = 1
   A = 1.2 * NCELL_EW(J) * PRSM_SIZE_EW(J)
   IF (A < PRSM_SIZE_EW(J)) NCELL_EW(J) = NCELL_EW(J) + 1
   CELL_SIZE_EW =  PRSM_SIZE_EW(J) / REAL (NCELL_EW(J))

   NCELL_NS(J) = INT (PRSM_SIZE_NS(J) / CELL_SIZE_NS)
   IF (NCELL_NS(J) < 1 ) NCELL_NS(J) = 1
   A = 1.2 * NCELL_NS(J) * PRSM_SIZE_NS(J)
   IF (A < PRSM_SIZE_NS(J)) NCELL_NS(J) = NCELL_NS(J) + 1
   CELL_SIZE_NS = PRSM_SIZE_NS(J) / REAL (NCELL_NS(J))

   NCELL_Z(J) = INT (PRSM_SIZE_Z(J) / CELL_SIZE_Z)
   IF (NCELL_Z(J) < 1 ) NCELL_Z(J) = 1
   A = 1.2 * NCELL_Z(J) * PRSM_SIZE_Z(J)
   IF (A < PRSM_SIZE_Z(J)) NCELL_Z(J) = NCELL_Z(J) + 1
   CELL_SIZE_Z = PRSM_SIZE_Z(J) / REAL (NCELL_Z(J))
   PRISM_ZMID(J)= PRISM_TOP + .5 * PRSM_SIZE_Z(J)

   ESTRT = PRISM_EAST(J) - 0.5 * PRSM_SIZE_EW(J)
   EFIN  = PRISM_EAST(J) + 0.5 * PRSM_SIZE_EW(J)
   KEW = NCELL_EW(J)

   NSTRT = PRISM_NORTH(J) - 0.5 * PRSM_SIZE_NS(J)
   NFIN  = PRISM_NORTH(J) + 0.5 * PRSM_SIZE_NS(J)
   KNS = NCELL_NS(J)

   BOT = PRISM_TOP + PRSM_SIZE_Z(J)

   WRITE(NW,14) J
   WRITE(NW,15) J,ESTRT,EFIN, NSTRT,NFIN,PRISM_TOP,BOT,J,KEW,CELL_SIZE_EW,KNS, &
                CELL_SIZE_NS,NCELL_Z(J),CELL_SIZE_Z,J,PRSM_RES(J)
   WRITE(NW,16) RMUP(J), REPSP(J), PRSM_CHRG(J), PRSM_CFR(J), PRSM_TAU(J)

 END DO
 DEALLOCATE (PBLK,LBLK)

  1 FORMAT(//T3,'NLAYER =',I3,';   NPRISM =',I3,';   NLITH =',I3,';   GND_LVL =',F8.2)
  2 FORMAT(/T3,'NPRISM =',I3,' but since DO3D = 0, only the layered half-space' &
           /T3,'response will be computed')
  4 FORMAT(//T3,'Initial parameters for',I3,' prisms'/T3,39('-')          &
            /T3,'KACC =',I2,4X,'SOLVER =',I2,4X,'OUTPUT =',I3 )
  5 FORMAT(//T3,'SOUTH PARK DEFENSE:'/T3,'These responses are very approximate and cannot be trusted.' &
            /T3,'You may wish to verify them by setting KACC = 2'/)
  6 FORMAT(/T3,'MARCO DOES NOT WORK FOR OUTCROPPING PRISMS.  The top of PRISM',I3, &
           /T3,'has been dropped to the air-earth interface.  A small cell size of' &
           /T3,'around 5 m (or less) would be advisable for a prism at the surface.'/)
  7 FORMAT(/T3,'Prism structire has changed due either prisms crossing layer boundaries' &
           /T3,'or no contrast in at least 1 layer.')
  8 FORMAT(//T4,'Layered host specification',/T4,26('-'))
 10 FORMAT(/T3,'The minimum dimension allowed for a prism is',F5.1 &
           /T3,'This prism will be deleted.')
 11 FORMAT(/T3,'This prism has no geoelectric contrast with the half-space')
 12 FORMAT(/T3,'None of the prisms have a geoelectric contrast with the half-space')
 13 FORMAT(/T3,'The prism structure has two-fold symmetry about' &
           /T3,'East-North coordinates:',2G12.4 &
          //T3,'It has been reduced to an equivalent single quadrant structure' &
           /T3,'to allow faster computation using a group symmetry option.')
 14 FORMAT (//T10,'Description of PRISM',I3/T10,'-----------------------'/)
 15 FORMAT(T3,'PRISM',I3,' extends:' &
          /T12,'from',F7.1,'  to',F7.1,T34,' - West to East' &
          /T12,'from',F7.1,'  to',F7.1,T34,' - South to North' &
          /T12,'from',F7.1,'  to',F7.1,T34,' - Below Air-Earth Interface' &
          //T3,'PRISM',i3,' is discretised into:' &
          /T12,I3,' cells of length',F7.1,' m.  East-West', &
          /T12,I3,' cells of length',F7.1,' m.  North-South', &
          /T12,I3,' cells of length',F7.1,' m.  Vertically' &
          //T3,'PRISM',I3,' resistivity =',G12.4,' ohm-m')
 16 FORMAT(T12,'Relative MU =',F7.2,4X,'Relative EPSILON =',F7.2/ &
           T14,'PRSM_CHRG =',F7.2,T36,'PRSM_CFR =',F6.2,4X,'PRSM_TAU =',G12.4)

   END SUBROUTINE READ_MODEL_DATA


 SUBROUTINE LYTH_CHK
!-------------------

!***  Called by SUBROUTINE READ_MODEL_DATA
!  Checks lithology data and identifies duplicates
!  Checks for Cole-Cole identification.

 INTEGER  JL1
 REAL  A1,A2

 DO JL = 1,NLITH
   ID_LITH(JL) = JL
   LYTH(JL,1) = ABS (LYTH(JL,1) )
   IF (LYTH(JL,3) < 0) LYTH(JL,2) = 1
   IF (LYTH(JL,4) < 0) LYTH(JL,3) = 1
   IF (LYTH(JL,5) < 1.E-3 .OR. LYTH(JL,6) < 1.E-15 .OR. LYTH(JL,7) < 1.E-6)  THEN
     LYTH(JL,5) = 0
     LYTH(JL,6) = 0
     LYTH(JL,7) = 1.
   END IF
 END DO

 DO JL = 1, NLITH-1
   INNER: DO JL1 = JL+1, NLITH
     DO JP = 1, NPROP
       A1 = ABS (LYTH(JL,JP) - LYTH(JL1, JP))
       A2 = MIN (LYTH(JL,JP), LYTH(JL1, JP))
       IF (A1 > 1.0E-3 * A2) CYCLE INNER
     END DO
     ID_LITH(JL1) = ID_LITH(JL)
     WRITE(NW,3) JL1,JL
   END DO INNER
 END DO
 WRITE(NW,1)
 DO JL = 1, NLITH
   WRITE(NW,2) JL,LYTH(JL,1:NPROP)
 END DO


 1 FORMAT(//T27,'LITHOLOGY PROPERTIES'/T27,'--------------------' &
          //T35,'Relative   Relative     Cole-Cole Parameters'    &
           /T9,'Resistivity  Conductance     MU     Dielectric   CHRG    CTAU       CFREQ'/)
 2 FORMAT(I4,T8,G12.4,T22,F7.1,F12.3,F11.3,F10.2,G12.3,F8.2)
 3 FORMAT(/T3,'Lithologies',I3,' and',I3,' are identical.')

END SUBROUTINE LYTH_CHK

   SUBROUTINE SHOW_MODEL
!  ---------------------

!  Prints the 3D model in revised coordinates plus layered earth host.
!  Initially, these are located over the first PRISM specified.
!  If the model is symmetric, the origin is further shifted to the centre of aymetry.

!*** Called by MAIN

 IMPLICIT NONE
 INTEGER KRX
 REAL ECNTR,NCNTR

 ECNTR = REAL (ECNTRD)
 NCNTR = REAL (NCNTRD)

 IF (KSYMM == 1) THEN
   ECNTR = ECNTR - TE
   NCNTR = NCNTR - TN
 END IF

 WRITE (NW,1) ECNTR,NCNTR,GND_LVL

 IF (SOURCE_TYPE < 3) THEN
   IF (SOURCE_TYPE == 1) WRITE(NW,2)
   IF (SOURCE_TYPE == 2) WRITE(NW,3)
   DO JS = 1,NTXE
     WRITE(NW,4) JS,N_VRTX(JS)
     DO JV = 1, N_VRTX(JS)
       WRITE(NW,'(I5,3F11.2)') JV,SXE(JV,JS),SXN(JV,JS),SXZ(JV,JS)
     END DO
   END DO
 ELSE IF (SOURCE_TYPE == 3) THEN
   WRITE(NW,5)
   DO JS = 1,NTXE
     WRITE(NW,'(I4,3F11.2,3F10.2)') JS,SXE(1,JS),SXN(1,JS),SXZ(1,JS),SXDIP(JS),SXAZ(JS),SXMNT(JS)
   END DO
   SXAZ = SXAZ * 3.14159 / 180.
   SXDIP = (90. - SXDIP) * 3.14159 / 180.
 END IF

! Print out receiver positions

 IF (SURVEY_TYPE == 1) THEN
   DO JG = 1,NRXG
     KRX = NRX(JG)
     IF (RX_TYPE(JG) == 1) THEN
       WRITE(NW,6) JG
       DO JR = 1, KRX
         WRITE(NW,'(I4,3F11.2,2F7.1,F10.0)') JR,RXE(JR,JG,1),RXN(JR,JG,1),RXZ(JR,JG,1), &
                                    RXDIP(JR,JG),RXAZ(JR,JG),RXMNT(JR,JG)
       END DO
     ELSE IF (RX_TYPE(JG) == 2) THEN
       WRITE(NW,7) JG
       DO JR = 1, KRX
         WRITE(NW,'(/I4,3F11.2)') JR,RXE(JR,JG,1),RXN(JR,JG,1),RXZ(JR,JG,1)
         DO JV = 2,4
           WRITE(NW,'(4X,3F11.2)')  RXE(JR,JG,JV),RXN(JR,JG,JV), RXZ(JR,JG,JV)
         END DO
       END DO
     ELSE IF (RX_TYPE(JG) == 3) THEN
       WRITE(NW,8) JG
       DO JR = 1, KRX
         WRITE(NW,'(I4,6F11.2)') JR,RXE(JR,JG,1),RXN(JR,JG,1),RXZ(JR,JG,1), &
                                    RXE(JR,JG,2),RXN(JR,JG,2),RXZ(JR,JG,2)
       END DO
     END IF
   END DO

   WRITE(NW,30)
   DO JS = 1,NTXE
     WRITE(NW,'(/T3,I3,T17,I3,T30,I3,T39,I3)') TXID(JS),JS,RGTXID(1,JS),NRX(RGTXID(1,JS))
     DO JR = 2,NRGTX(JS)
       WRITE(NW,'(T30,I3,T39,I3)') RGTXID(JR,JS),NRX(RGTXID(JR,JS))
     END DO
   END DO

 ELSE IF (SURVEY_TYPE == 2 .OR. SURVEY_TYPE == 3) THEN
   IF (SURVEY_TYPE == 2) WRITE(NW,9)
   IF (SURVEY_TYPE == 3) WRITE(NW,10)
   DO JG = 1,NTXE
     WRITE(NW,'(I4,3F11.2,2F7.1,F10.0)') JG,RXE(1,JG,1),RXN(1,JG,1),RXZ(1,JG,1), &
                                          RXDIP(1,JG),RXAZ(1,JG),RXMNT(1,JG)
   END DO
 END IF

! Set up pretty output for layered earth.

 WRITE(NW,18)
 DO JL = 1, NLYR
   IF(JL == NLYR) THEN
     WRITE(NW,19) NLYR,RES(NLYR),RMU(NLYR),REPS(NLYR),CHRG(NLYR),CTAU(NLYR),CFREQ(NLYR)
   ELSE
     WRITE(NW,20) JL,THK(JL),RES(JL),RMU(JL),REPS(JL),CHRG(JL),CTAU(JL),CFREQ(JL)
   END IF
 END DO

 IF (DO3D > 0) THEN
   IF (TDFD == 1) WRITE(NW,21)  ! Time-domain option
   IF (TDFD == 2) WRITE(NW,22)  ! Frequency-domain option
   IF (KACC == 1) WRITE(NW,23)
   IF (KACC > 1) WRITE(NW,24) KACC
 ELSE
   IF (TDFD == 1) WRITE(NW,25)  ! Time-domain option
   IF (TDFD == 2) WRITE(NW,26)  ! Frequency-domain option
 END IF

 WRITE(NW,35)                 ! End of input data description


 1 FORMAT(//T3,'Before computation begins, Marco transforms array and model coordinates from'  &
           /T3,'"real world" coordinates where elevation increases positive upwards to a'     &
           /T3,'body- centred system where depth increases positive downwards.  The new '      &
           /T3,'vertical origin is at the air-earth interface.  If the model is symmetric',    &
           /T3,'the new horizontal origin is over the centre of the model region.  Otherwise', &
           /T3,'the origin is over the top of the first prism specified', &
           /T3,'In the "real world" coordinates the new computation origin is located at:' &
          //T4,'EAST: ',F12.2,';    NORTH: ',F12.2,';    ELEVATION: ',F8.2)

 2 FORMAT(/T3,'Transformed Vertex Locations for Loop Sources' &
          /T3,'---------------------------------------------')
 3 FORMAT(/T3,'Transformed Vertex Locations for Grounded Wire Sources' &
          /T3,'------------------------------------------------------')
 4 FORMAT(/T7,'Transmitter',I3,' has',I3,' vertices.'&
         //T10,'Easting   Northing     Depth'/)
 5 FORMAT(/T3,'Transformed Dipole Source Specification'// &
         //T9,'Easting   Northing      Depth      Dip    Azimuth   Moment' &
          /T9,'-------   --------      -----      ---    -------   ------')
 6 FORMAT(//T3,'Transformed Locations for Magnetic Dipole Receivers in Rx Group',I3 &
           /T3,'------------------------------------------------------------------' &
           /T9,'Easting   Northing     Depth    Dip    Azimuth   Moment'/)
 7 FORMAT(//T3,'Transformed Vertices for Loop Receivers in Rx Group',I3 &
           /T3,'------------------------------------------------------' &
          /T9,'Easting   Northing     Depth ')
 8 FORMAT(//T3,'Transformed Electrode Positions for Electric Dipoles in Rx Group',I3 &
           /T3,'-------------------------------------------------------------------' &
          /T10,'East 1    North 1    Depth 1     East 2    North 2    Depth 2'/)

 9 FORMAT(//T3,'Transformed Locations for Constant Offset Magnetic Dipole Receivers' &
           /T3,'-------------------------------------------------------------------' &
           /T9,'Easting   Northing     Depth    Dip    Azimuth   Moment'/)
 10 FORMAT(//T3,'Transformed Locations for Central Loop Magnetic Dipole Receivers' &
           /T3,'-----------------------------------------------------------------')
 18 FORMAT(//T11,'+----------------------------------+'  &
            /T11,'+  Layered Earth Model Parameters  +'  &
            /T11,'+----------------------------------+'  &
           //T2,'Layer  Thickness  Resistivity   MU-R   EPS-R   CHRG    CTAU      CFREQ' &
            /T2,'-----  ---------  -----------   ----   -----   ----    ----      -----')
 19 FORMAT(I4,11X,  G15.4,2F7.2,F8.2,G11.2,F7.2)
 20 FORMAT(I4,F11.1,G15.4,2F7.2,F8.2,G11.2,F7.2)
 21 FORMAT(/T3,'Marco will compute 3D responses for a time-domain system')
 22 FORMAT(/T3,'Marco will compute 3D responses for a frequency-domain system')
 23 FORMAT(/T3,'using a fast APPROXIMATE 3D solution. !')
 24 FORMAT( T3,'using accuracy level:',I3)
 25 FORMAT(/T3,'Marco will compute layered earth responses for a', &
           /T3,'time-domain system.')
 26 FORMAT(/T3,'Marco will compute layered earth responses for a', &
           /T3,'frequency-domain system.')
 30 FORMAT(//T7,'Revised transmitter indexing'/T7,'----------------------------' &
           //T5,'Old          New        Receiver  Group' &
            /T3,'Tx Index     Tx Index     Groups     NRX')
 35 FORMAT(/75('-')/T24,'END OF INPUT DATA DESCRIPTION'/75('-'))

   END SUBROUTINE  SHOW_MODEL

   SUBROUTINE SET_FRQ
!  ------------------

!***  Called by MAIN program

!  For time-domain options for B or dB/dt:
!
!  Numerical experiments where the frequency-domain responses of layered
!  layered 1/2 space models were transformed to time-domain for a wide
!  range of resistivities has indicated that 6 points per decade is
!  adequate frequency discretisation, even at the high end.  Moreover,
!  for perfect frequency-domain data, only 3 frequencies are required
!  from 1 to 10 Hz to maintain an accuracy of better than .1 percent for
!  the models studied.  This means that 28 frequencies are needed for the
!  1Hz to 100kHz range.
!
!  The imaginary component of B divided by iw is extrapolated back to
!  zero frequency using the constant value at freq = 1Hz.
!
!  The need to go to 1 MHz depends upon receiver channels and conductivity.
!  A 10,000 ohm-m 1/2 space requires extended range if the earliest window
!  opening is within .28 ms of signal turn-off.  A 1 ohm-m 1/2 space allows
!  normal range if the first window open time is > .002 ms.
!
!  In a 3D program, this is pretty hard to control because of non-uniform
!  resistivity distribution so the safe option of going to 1 MHz is chosen
!  if the first window opens earlier than .2 ms after signal turn-off.  This
!  requires computation for 34 frequencies.
!
!  This can be over-ridden by setting ISTOP = -1 in which case the program
!  will compute 43 frequency-domain responses at 6 points per decade from
!  .1 Hz to 1MHz.
!
!  For a truly tedious experience, the user can force frequency computations
!  at 12 points per decade from 1 Hz to 1 MHz by entering ISTOP = -2 but this
!  is excessive, especially for a program which takes as long as Marco
!  to run.
!
!  Although only 6 frequencies per decade are used, setting these frequencies
!  precisely allows the most accurate use of the filters by COSTRN.

 IMPLICIT NONE
 INTEGER JF
 REAL T0
 REAL(KIND=8), ALLOCATABLE :: QQ(:)
 REAL(KIND=8) QFRQ,QFRQ3,QFRQ6,QFRQ12,QQT

 ALLOCATE (QQ(200))

 QQ(1) = 1.D-1
 QFRQ6 = EXP ( LOG (10.D0) /6.D0 )
 QFRQ12 = EXP ( LOG (10.D0) /12.D0 )
 QFRQ3 = EXP ( LOG (10.D0) /3.D0 )
 QFRQ = QFRQ6
 NFRQ = 7

 IF (ISTOP == -2) THEN                  ! Very tedious DEFAULT choice
   QFRQ = QFRQ12
   MAXFRQ = 1.E6
   MXFRQE = MAXFRQ
   DO JF = 2,7
     QQ(JF) = QQ(JF-1) * QFRQ12
   END DO
 ELSE IF (ISTOP == -1) THEN             ! Somewhat tedious DEFAULT choice
   MAXFRQ = 1.E6
   MXFRQE = MAXFRQ
   DO JF = 2,7
     QQ(JF) = QQ(JF-1) * QFRQ6
   END DO

 ELSE
   IF (MINFRQ < 0) THEN                  ! Default range
     MXFRQE = 3162.
     IF (MAXVAL (RX_TYPE) < 3) THEN      ! No E field measurements
       QQ(1) = 1.0D0
       DO JF = 2,4
         QQ(JF) = QQ(JF-1) * QFRQ3       ! 3 points per decade to 10 Hz
       END DO
       DO JF = 5,7
         QQ(JF) = QQ(JF-1) * QFRQ6       ! 6 points per decade after 10 Hz
       END DO
     ELSE                                ! E field starts at 0.1 Hz
       DO JF = 2,7
         QQ(JF) = QQ(JF-1) * QFRQ3       ! 3 points per decade to 10 Hz
       END DO
     END IF
     T0 = MINVAL (TOPN) - T0SX
     MAXFRQ = 1.E5
     IF (T0 < 1.E-5) MAXFRQ = 1.E6
     IF (MINVAL (RX_TYPE) == 3) MAXFRQ = MXFRQE   !  Maximum value for E fields only
   ELSE                                !  USER defined range
     QQ(1) = 10.D0                     !  Find starting point
     DO JF = 1, 36
       IF (QQ(1) < 0.95*MINFRQ) EXIT
       QQ(1) = QQ(1) / QFRQ12
     END DO
     DO JF = 2,7
       QQ(JF) = QQ(JF-1) * QFRQ6       ! 6 points per decade
     END DO
   END IF

   IF (MINVAL (RX_TYPE) == 3) MAXFRQ = MXFRQE   !  Maximum value for E fields only
 END IF

 DO JF = 8,100
   QQT = QQ(JF-1) * QFRQ
   IF (QQT > 1.1 * MAXFRQ) EXIT
   NFRQ = NFRQ + 1
   QQ(JF) = QQT
 END DO

 ALLOCATE (FREQ(NFRQ) )

 DO JF = 1,NFRQ
   FREQ(JF) = REAL (QQ(JF))
   IF (FREQ(JF) < 1.1 * MXFRQE) KFRQE = JF
 END DO
 DEALLOCATE (QQ)

 IF (ISTOP == -2) THEN                  ! Very tedious DEFAULT choice
   WRITE(NW,1)
 ELSE IF (ISTOP == -1) THEN                  ! Very tedious DEFAULT choice
   WRITE(NW,2)
 ELSE IF (MINFRQ < 0) THEN                  ! Default range
   WRITE(NW,3) FREQ(1),FREQ(NFRQ)
 ELSE
   WRITE(NW,4) FREQ(1),FREQ(NFRQ)
 END IF

 IF (NEW) THEN
   WRITE(NW,5)
 ELSE
   WRITE(NW,6)
 END IF

 1 FORMAT(/T3,'The time-domain results will be constructed using frequency-domain' &
          /T3,'output computed at 12 points per decade, from 0.1 Hz to 1 MHz')
 2 FORMAT(/T3,'The time-domain results will be constructed using frequency-domain' &
          /T3,'output computed at 6 points per decade, from 0.1 Hz to 1 MHz')
 3 FORMAT(/T3,'The time-domain results will be constructed using frequency-domain' &
          /T3,'output computed at 3 points per decade, from',F5.1,' Hz to 10 Hz' &
          /T3,'and at 6 points per decade, from 10 Hz to',G12.4,' Hz.')
 4 FORMAT(/T3,'The time-domain results will be constructed from frequency-domain output' &
          /T3,'computed at 6 points per decade, from',F5.1,' Hz to',G12.4,' Hz.')
 5 FORMAT(/T3,'Marco will start by computing new frequency-domain responses in the specified ' &
          /T3,'range to construct the spectrum from DC to the appropriate upper limit.')
 6 FORMAT(/T3,'Marco will compute time-domain responses from the frequency-domain data' &
          /T3,'contained in file Marco.frq' &
         //T3,'THESE MUST BE AT THE DENSITIES SPECIFIED ABOVE!'/)

   END SUBROUTINE SET_FRQ

   SUBROUTINE SET_SURVEY
!  ---------------------

!  Arrays are given in real world coordinates which require double precision.
!  Rather than carry unnecessary higher precision into the computation, arrays
!  are adjusted by ECNTRD and NCNTRD  after the model has been read in.
!  A further shift by TE, TN is necessary if symmetry applies.
!  If the model is symmetric, it is shifted by a further TE,TN wrt the
!  single precision coordinates before this routine is called.

   IMPLICIT NONE
   IF (STEP == 1) RXMNT = 1.
   DO JG = 1,NRXG
     IF (STEP == 0 .AND. UNITS(JG) < 3) RXMNT(1:MRX,JG) = 1
   END DO

   SXE = REAL (SXED - ECNTRD,4)
   SXN = REAL (SXND - NCNTRD,4)
   SXZ = REAL (GND_LVL - SXZD,4)
   IF (KSYMM == 1) THEN
     SXE = SXE - TE
     SXN = SXN - TN
   END IF

   IF (SURVEY_TYPE /= 4) THEN
     RXE = REAL (RXED - ECNTRD,4)
     RXN = REAL (RXND - NCNTRD,4)
     RXZ = REAL (GND_LVL - RXZD,4)

     IF (KSYMM == 1) THEN
       RXE = RXE - TE
       RXN = RXN - TN
     END IF

   ELSE               ! Set up coincident loop midpoints in REAL KIND 8
     DO JS = 1,NTXE
       JV = N_VRTX(JS)
       CLCD(1,JS) = SUM (SXND(1:JV,JS)) / REAL (JV,8)
       CLCD(2,JS) = SUM (SXED(1:JV,JS)) / REAL (JV,8)
       CLCD(3,JS) = SUM (SXZD(1:JV,JS)) / REAL (JV,8)
     END DO
   END IF

   END SUBROUTINE SET_SURVEY

   SUBROUTINE SET_TRP
!  ------------------

!  Sets up interpolation times for FD -> TD transform which use the
!  exact 6 points per decade frequency-domain data plus 6 per decade
!  interpolated values.  These are based on a 12 point per decade
!  cosine filter derived from the Niels Christensen routine FILCOA
!  with OMEGA = .3 PI and shift 0.

!***  Called by: MAIN program
!***       Uses:  MODULE MG_Filter_coefficients

!             OUTPUT
!             ------

!        TRP - array of time values for FD -> TD transformations
!      NTYRP - number of values in TRP
!     EXTENT - the latest time for which time-domain output is required.
!      PULSE - time length of one signal pulse
!     NTYPLS - number of TRP values in 1 PULSE


 IMPLICIT NONE
 REAL, PARAMETER :: TWOPI=6.2831853, T0_MIN=0.1E-6
 INTEGER MXTYM,J1
 REAL EXTENT
 REAL,ALLOCATABLE :: QQQ(:)
 REAL(KIND=8) TBASE,QTYM, TQ

 MXTYM=200
 ALLOCATE (QQQ(MXTYM))
 QQQ = 0.

 QTYM = LOG (10.D0) /12.D0
 QTYM = EXP (QTYM)
 NPULS = 5
 EXTENT = 2.0 * NPULS * PULSE

 TBASE = 1.D0 / DBLE (TWOPI)
 DO J1 = 1,MXTYM
   IF (REAL (TBASE) < T0_MIN) EXIT
   TBASE = TBASE / QTYM
 END DO

 TQ = TBASE
 QQQ(1) = REAL (TQ,4)
 DO J1 = 2, MXTYM
   NTYRP = J1
   TQ = TQ * QTYM
   QQQ(J1) = REAL(TQ)
   IF (QQQ(J1) < PULSE) NTYPLS = J1+2
   IF( QQQ(J1) > EXTENT) EXIT
 END DO

 ALLOCATE (TRP(NTYRP))
 TRP(1:NTYRP) = QQQ(1:NTYRP)
 DEALLOCATE (QQQ)

   END SUBROUTINE SET_TRP

!======================================

END MODULE MG_Input_routines

 PROGRAM MAIN
!------------

!*** Calls FDREAD, HSBOSS, HSBOSS_FRQ, MARCO_3D, SET_SOURCE, TDEM_3D
!          TDEM_3D, WRITE_FD, WRITE_TD, WRYT_LOG_FILE

!*** Calls from MG_Input_routines:
!          READ_READ_SYSTEMY_DATA, READ_MODEL_DATA, SET_TRP, SET_FRQ,

 USE MG_Input_routines

 IMPLICIT NONE
 INTEGER CMPDX
 COMPLEX, PARAMETER :: ZERO=(0.,0.)
 INTEGER JF
 REAL, DIMENSION(:,:,:,:), ALLOCATABLE :: BTD,BTD_SCAT
 COMPLEX,DIMENSION(:,:,:,:),ALLOCATABLE :: BFD_SCAT,BFD
 REAL CMP_START, CMP_final, CMP_delta, DXPRM(3,3), SXAZ1,SXDP1
 LOGICAL AMX_PPM

 CALL CPU_TIME (CMP_START)

 CALL READ_SYSTEM_DATA  ! Set up airborne system & layered earth model.
 CALL READ_MODEL_DATA
 CLOSE (NR)
! Put arrays in body centred system.  Change order of loop vertices
! to clockwise if they have been entered in counter-clockwise order.

 CALL SET_SURVEY
 IF (SOURCE_TYPE == 1) CALL LP_VERTEX_ORDER (NTXE,MXVRTX,N_VRTX,SXN,SXE,SXZ)
 CALL SHOW_MODEL        ! Set & Print array & model coordinates in body-centred system

 !============================================================================
 !
 ! Error checkpoint
 Select Case (MXERR)
 Case (0)
    Write (*, 90) Trim(PNAME)
 Case (1)
    Write (*, 91) Trim(PNAME), Trim(PNAME), Trim(PNAME)
 Case (2)
    Write (*, 92) Trim(PNAME)
 End Select
!============================================================================
 IF (ISTOP == 1 .or. MXERR .eq. 2) STOP
!============================================================================

! For loop or grounded wire receivers, component JC = 1 contains the voltage and
! the other components (JC = 2,3) are zero.

!  For time-domain, set up frequencies, interpolation times

 IF (TDFD == 1) THEN   ! Time-Domain
   CALL SET_SOURCE (NSX,SWX,SWY,T0SX)  ! Compute dI/dt at the receiver
   CALL SET_TRP
   CALL SET_FRQ
 END IF

 ALLOCATE (BFD_SCAT(NFRQ,LRX,NTXE,3),BFD(NFRQ,LRX,NTXE,3))
 BFD_SCAT = ZERO
 BFD = ZERO

!  If symmetry, then transmitters and receivers have been shifted to the centre of symmetry
!  in SUBROUTINE SET_SURVEY.   There is no need to shift them back since the "real world"
!  are used for printout.

!  Since Marco_3D has ot be called even for 1D computations, this version will
!  save the frequency-domain output for both half space and 3D part.

 IF (DO3D < 2) THEN

   CALL MARCO_3D (NW,DO3D,NFRQ,FREQ,SURVEY_TYPE,SOURCE_TYPE,NTXE,MXVRTX,N_VRTX, &
                  SXE,SXN,SXZ,SXDIP,SXAZ,NRXG,NRGTX,RX_TYPE,RGTXID,NRXTX,NRX,   &
                  MRX,LRX,MQVR,RXE,RXN,RXZ,NLYR,THK,RES,RMU,REPS,CHRG,CTAU,     &
                  CFREQ,KSYMM,NPRISM,PRISM_ZMID,PRISM_EAST,PRISM_NORTH,         &
                  PRSM_SIZE_EW,PRSM_SIZE_NS,PRSM_SIZE_Z,NCELL_EW,NCELL_NS,      &
                  NCELL_Z,PRSM_RES,RMUP,REPSP,PRSM_CHRG,PRSM_TAU,PRSM_CFR,      &
                  KACC,SOLVER,BFD,BFD_SCAT)

   CLOSE (NLG)

!  End of frequency stepping.
!  Write out the total frequency-domain scattered magnetic fields for each to UNIT ND.

   ! IF (TDFD == 1) THEN
   ! WRITE(ND,'(I3)') DO3D
     DO JS = 1, NTXE
       DO JR = 1, NRXTX(JS)
         DO JF = 1,NFRQ  !  Write 1D and scattered alternately.

           WRITE(ND,'(6(1PE16.7),3X,A,G12.4,2I4)') BFD(JF,JR,JS,1:3),'frq, jr, js',FREQ(JF),JR,JS
           IF (DO3D == 1) WRITE(ND,'(6(1PE16.7),3X,A,G12.4,2I4)') BFD_SCAT(JF,JR,JS,1:3),'frq, jr, js',FREQ(JF),JR,JS
         END DO
       END DO
     END DO
     CLOSE (ND)
     WRITE(*, 10)
   ! END IF

!  If BFD_SCAT has been computed, construct the total frequency-domain response.
!  Otherwise, this must be done after FDREAD is called since the 1D and scattered
!  parts are stored rather than total and scattered parts.

   IF (DO3D == 1) BFD = BFD + BFD_SCAT

 END IF

 AMX_PPM = .FALSE.
 IF (TDFD == 1) THEN   ! Time-Domain.  Compute BTD_SCAT, the Scattering Response

   ALLOCATE ( BTD(NCHNL,LRX,NTXE,3), BTD_SCAT(NCHNL,LRX,NTXE,3))
   BTD = 0.;  BTD_SCAT = 0.

   IF (DO3D == 2) THEN
     CALL FDREAD (ND,NFRQ,NTXE,LRX,NRXTX,NCMP,BFD,BFD_SCAT,OUTPUT)  !  Read old frequency-domain data
     BFD = BFD + BFD_SCAT
     CLOSE (ND)

   END IF

   CALL TDEM_3D (STEP,NSX,SWX,SWY,NPULS,PULSE,NTYPLS,NTYRP,TRP,NCHNL,TOPN, &
                 TCLS,FREQ,NFRQ,KFRQE,NTXE,LRX,NRXTX,RXID,NCMP,BFD,BTD)

   IF ( DO3D /= 0 )   &
     CALL TDEM_3D (STEP,NSX,SWX,SWY,NPULS,PULSE,NTYPLS,NTYRP,TRP,NCHNL,TOPN, &
                   TCLS,FREQ,NFRQ,KFRQE,NTXE,LRX,NRXTX,RXID,NCMP,BFD_SCAT,BTD_SCAT)

   DEALLOCATE (BFD_SCAT, BFD)

!  Rotate to borehole system if applicable. (Default rotation is null)

   CALL BH_ROTATE (NCHNL,LRX,NTXE,NRXTX,BHR,BHAZ,BHDIP,BTD)
   IF (DO3D > 0) CALL BH_ROTATE (NCHNL,LRX,NTXE,NRXTX,BHR,BHAZ,BHDIP,BTD_SCAT)

   CALL WRITE_TD (NW,PRFL,STEP,NCHNL,TMS,SURVEY_TYPE,SOURCE_TYPE,NTXE,SXMNT,NRXG, &
                  NRGTX,RGTXID,NRX,LRX,MRX,UNITS,RX_TYPE,NCMPG,PRTCMP,RXMNT,RXED,  &
                  RXND,RXZD,MQVR,CLCD,PRTSEC,TITLE,BTD,BTD_SCAT)

   CALL WRITE_TAMX (TITLE,STEP,OUTPUT,SOURCE_TYPE,SURVEY_TYPE,NCHNL,TMS,NTXE, &
                    MXVRTX,N_VRTX,SXE,SXN,SXZ,SXDIP,SXAZ,SXMNT,NRGTX,NRXG,RGTXID,  &
                    NCMPG,PRTCMP,LRX, MRX,NRX,MQVR,RX_TYPE,UNITS,RXED,RXND,RXZD,   &
                    RXDIP,RXAZ,RXMNT,CLCD,BTD,BTD_SCAT)
 ELSE

!  BFD has been defined as the total response,
!  Rotate to borehole system if applicable. (Default rotation is null)

   CALL BHC_ROTATE (NFRQ,LRX,NTXE,NRXTX,BHR,BHAZ,BHDIP,BFD)
   IF (DO3D > 0) CALL BHC_ROTATE (NFRQ,LRX,NTXE,NRXTX,BHR,BHAZ,BHDIP,BFD_SCAT)

!  Multiply FD response per amp by transmitter current

   CALL FD_CURNT (NFRQ,LRX,NTXE,CURNT,BFD)
   IF (DO3D > 0) CALL FD_CURNT (NFRQ,LRX,NTXE,CURNT,BFD_SCAT)

!  PPM normalisation for single offset magnetic dipole survey

   IF (SOURCE_TYPE == 3 .AND. SURVEY_TYPE == 2 .AND. CMP(1) > 0) THEN
     IF (OUTPUT > 0) AMX_PPM = .TRUE.
     CMPDX = 3; SXDP1 = SXDIP(1); SXAZ1 = SXAZ(1)
     IF (CMP(1) == 1) CMPDX = 1
     CALL MD_PRM (NW,SXDP1,SXAZ1,RXON,RXOE,RXOZ,CMPDX,DXPRM)
     CALL WRITE_FD_PPM (NW,NFRQ,FREQ,NTXE,CMPDX,RXED,RXND,RXZD,TITLE,BFD,CURNT,DXPRM)
   END IF

   CALL WRITE_FD (NW,PRFL,STEP,NFRQ,FREQ,SURVEY_TYPE,SOURCE_TYPE,NTXE,SXMNT,NRXG, &
                  NRGTX,RGTXID,LRX,MRX,NRX,UNITS,RX_TYPE,NCMPG,PRTCMP,RXMNT,RXED, &
                  RXND,RXZD,MQVR,PRTSEC,TITLE,BFD,BFD_SCAT)

   IF (AMX_PPM) THEN
       OUTPUT = ABS(OUTPUT)
       CALL WRITE_FAMX_PPM (TITLE, STEP, OUTPUT, SOURCE_TYPE, SURVEY_TYPE, NFRQ, FREQ, &
               NTXE, MXVRTX, SXE, SXN, SXZ, SXDIP, SXAZ, SXMNT, NRXG, NCMPG, PRTCMP,   &
               LRX, MRX, MQVR, RXED, RXND, RXZD, RXDIP, RXAZ, RXMNT, BFD, BFD_SCAT,    &
               DXPRM, CURNT, CMPDX)
   ELSE
       OUTPUT = ABS(OUTPUT)
       CALL WRITE_FAMX (TITLE,STEP,OUTPUT,SOURCE_TYPE,SURVEY_TYPE,NFRQ,FREQ,NTXE, &
                        MXVRTX,N_VRTX,SXE,SXN,SXZ,SXDIP,SXAZ,SXMNT,NRGTX,NRXG,RGTXID,  &
                        NCMPG,PRTCMP,LRX,MRX,NRX,MQVR,RX_TYPE,UNITS,RXED,RXND,RXZD,    &
                        RXDIP,RXAZ,RXMNT,BFD,BFD_SCAT)
   END IF

 END IF

 CALL CPU_TIME (CMP_Final)
 Call date_and_time(Values = tvals)
 CMP_Delta = CMP_Final - CMP_Start

 ! Write (np, 11) trim(PNAME), 'forward model', tvals(1:3), tvals(5:7), CMP_delta
 Write (nw, 12) trim(PNAME), 'forward model', tvals(1:3), tvals(5:7), CMP_delta
 Write ( *, 12) trim(PNAME), 'forward model', tvals(1:3), tvals(5:7), CMP_delta
 
 STOP

!
! Formats
10 Format (/, 2x, 'Frequency-domain calculations finished ...', &
           /, 2x, 'Starting convolution for time-domain calculations ...')
11  Format ('/', / &
            '/ ', a, ' ', a, ' run completed: ', i4.4, '-', i2.2, '-', i2.2, 'T', i2.2, ':', i2.2, ':', i2.2, / &
            '/ Runtime: ', f12.2, ' secs')
12  Format (/, 2x, a, ' ', a, ' run completed: ', i4.4, '-', i2.2, '-', i2.2, 'T', i2.2, ':', i2.2, ':', i2.2, &
		    /, 2x, 'Runtime: ', f12.2, ' seconds', /)
90 Format (/, 2x, 'Completed sanity check on entries in ', a, '.cfl ...', &
           /, 2x, 'Computation begining ...')
91 Format (/, 2x, 'WARNING', &
           /, 2x, a, '.cfl may contain errors. Please check ', a, '.log and ', a, '.out')
92 Format (/, 2x, 'FATAL ERROR', &
           /, 2x, a, '.cfl contains errors. Please correct these before restarting.')
 END PROGRAM MAIN

 SUBROUTINE BH_ROTATE (NCHNL,LRX,NTXE,NRXTX,BHR,DXAZ,DXDIP,BTD)
!-------------------------------------------------------------

!***  Called by MAIN
!***  Calls NIL

! Rotates REAL (time-domain) North, East, Vertical response
! components into Axial, Slope & Horizontal components.

!     The Axial component points in the direction of the borehole axis, defined by DXDIP.
!          If the hole is vertical, it points down.
!          If the hole is horizontal, it points towards DXAZ.
!
!     The Slope component lies perpendicular to the borehole in the vertical plane
!     containing the borehole.
!          If the hole is vertical, it points North.   (12 o'clock)
!          If the hole is horizontal, it is the vertical component.
!
!     The Horizontal component lies perpendicular to the azimuth.
!          If the hole is vertical, it points West.  (9 o'clock)
!          If the hole is horizontal, it points towards DXAZ - PI / 2.


!               INPUT
!               -----
!      NCHNL - number of time domain receibver channels
!        LRX - number of receivers for each transmitter position
!       NTXE - number of transmitter positions
!   NRXTX(J) - number of receivers belonging to transmitter J
!        BHR - if false, don't rotate
!       DXAZ - assigned borehole azimuth in radians(= 0 due north)
!      DXDIP - assigned borehole dip in radians (vertical down = 0)
!        BTD - time domain step or impulse response expressed in
!              North, East, and Vertical components
!
!               OUTPUT
!               ------
!      BTD(JT,JR,JS,K) - time domain step or impulse response at time JT,
!                        at receiver, JR, for transmitter, JS, expressed
!                        in borehole components: K = 1, 2, 3

!         K = 1 => Horizontal;  K = 2 => Slope;  K = 3 => Axial
!

 REAL, PARAMETER :: TOL = 0.001
 INTEGER NCHNL, LRX, NTXE, NRXTX(NTXE),JR,JS,JT
 REAL DXAZ(LRX,NTXE), DXDIP(LRX,NTXE), BTD(NCHNL,LRX,NTXE,3), &
      SL,HR,AX,BX,BY,BZ,SPHI,CPHI,STH,CTH
 LOGICAL BHR(LRX,NTXE)

 DO JS = 1,NTXE
   DO JR = 1,NRXTX(JS)
     IF (.NOT. BHR(JR,JS)) CYCLE     !  Do not rotate unless BHR is true.
     CTH = COS (DXDIP(JR,JS))
     STH = SIN (DXDIP(JR,JS))
     CPHI = COS (DXAZ(JR,JS))
     SPHI = SIN (DXAZ(JR,JS))

     DO JT = 1,NCHNL
       BX = BTD(JT,JR,JS,1)
       BY = BTD(JT,JR,JS,2)
       BZ = BTD(JT,JR,JS,3)

       IF (ABS (DXDIP(JR,JS)) < TOL) THEN
         AX = BZ
         SL = BX
         HR = -BY
       ELSE
         AX = CTH * BZ + STH * (CPHI*BX + SPHI*BY)
         SL = STH * BZ - CTH * (CPHI*BX + SPHI*BY)
         HR =        SPHI*BX - CPHI*BY
       END IF
       BTD(JT,JR,JS,1) = HR
       BTD(JT,JR,JS,2) = SL
       BTD(JT,JR,JS,3) = AX
     END DO

   END DO
 END DO
END SUBROUTINE BH_ROTATE

 SUBROUTINE BHC_ROTATE (NFRQ,LRX,NTXE,NRXTX,BHR,DXAZ,DXDIP,BFD)
!--------------------------------------------------------------

!***  Called by MAIN
!***  Calls NIL

! Rotates COMPLEX (frequency-domain) North, East, Vertical response
! components into Axial, Slope & Horizontal components.

!     The Axial component points in the direction of the borehole axis, defined by DXDIP.
!          If the hole is vertical, it points down.
!          If the hole is horizontal, it points towards DXAZ.
!
!     The Slope component lies perpendicular to the borehole in the vertical plane
!     containing the borehole.
!          If the hole is vertical, it points North.   (12 o'clock)
!          If the hole is horizontal, it is the vertical component.
!
!     The Horizontal component lies perpendicular to the azimuth.
!          If the hole is vertical, it points West.  (9 o'clock)
!          If the hole is horizontal, it points towards DXAZ - PI / 2.


!               INPUT
!               -----
!       NFRQ - number of time domain receibver channels
!        LRX - number of receivers for each transmitter position
!       NTXE - number of transmitter positions
!   NRXTX(J) - number of receivers belonging to transmitter J
!        BHR - if false, don't rotate
!       DXAZ - assigned borehole azimuth in radians(= 0 due north)
!      DXDIP - assigned borehole dip in radians(vertical = 0)
!        BFD - frequency domain step or impulse response expressed in
!              North, East, and Vertical components
!
!               OUTPUT
!               ------
!      BFD(JF,JR,JS,K) - frequency domain response at frequency JF, at
!                        receiver, JR, for transmitter, JS, expressed
!                        in borehole components: K = 1, 2, 3

!         K = 1 => Horizontal;  K = 2 => Slope;  K = 3 => Axial
!

 REAL, PARAMETER :: TOL = 0.001
 INTEGER NFRQ, LRX, NTXE, NRXTX(NTXE),JR,JS,JF
 REAL DXAZ(LRX,NTXE), DXDIP(LRX,NTXE),SPHI,CPHI,STH,CTH
 COMPLEX BFD(NFRQ,LRX,NTXE,3), SL,HR,AX,BX,BY,BZ
 LOGICAL BHR(LRX,NTXE)

 DO JS = 1,NTXE
   DO JR = 1,NRXTX(JS)
     IF (.NOT. BHR(JR,JS)) CYCLE     !  Do not rotate unless BHR is true.

     CTH = COS (DXDIP(JR,JS))
     STH = SIN (DXDIP(JR,JS))
     CPHI = COS (DXAZ(JR,JS))
     SPHI = SIN (DXAZ(JR,JS))

     DO JF = 1,NFRQ
       BX = BFD(JF,JR,JS,1)
       BY = BFD(JF,JR,JS,2)
       BZ = BFD(JF,JR,JS,3)

       IF (ABS (DXDIP(JR,JS)) < TOL) THEN
         AX = BZ
         SL = BX
         HR = -BY
       ELSE
         AX = CTH * BZ + STH * (CPHI*BX + SPHI*BY)
         SL = STH * BZ - CTH * (CPHI*BX + SPHI*BY)
         HR =        SPHI*BX - CPHI*BY
       END IF

       BFD(JF,JR,JS,1) = HR
       BFD(JF,JR,JS,2) = SL
       BFD(JF,JR,JS,3) = AX
     END DO

   END DO
 END DO
END SUBROUTINE BHC_ROTATE

 SUBROUTINE CHK_SYMMETRY (NPRISM,NP11,LBLK,PBLK,TE,TN,KSYMM)
!-----------------------------------------------------------

!  Created for MARCO_AIR 2.0, November, 1999

!  Checks to see if the structure of NPRISM prisms is symmetric about some
!  point (TE,TN) in the horizontal plane.  If so, KSYMM is set to 1, the
!  coordinate system is shifted to (TE,TN) Otherwise, KSYMM = 0

!  TE & TN are the east & north coordinates of the geometric centre projected
!  onto the 2D horizontal plane.  NPRNE is the number of prisms wholly or
!  partially within the NE quadrant in the (TE,TN) centred system.

!    ENTRY
!    -----
!
!   PBLK(J,1) = PRISM_EAST, east coordinate of PRISM J
!   PBLK(J,2) = PRISM_NORTH
!   PBLK(J,3) = PRISM_TOP, depth (from air-earth interface) to top of PRISM J
!   PBLK(J,4) = PRISM_SIZE_EW, for PRISM J
!   PBLK(J,5) = PRISM_SIZE_NS, for PRISM J
!   PBLK(J,6) = PRISM_SIZE_Z, vertical dimension of PRISM J
!   PBLK(J,7) = CELL_SIZE_EW, for PRISM J
!   PBLK(J,8) = CELL_SIZE_NS, for PRISM J
!   PBLK(J,9) = CELL_SIZE_Z, vertical dimension of PRISM J

!   LBLK(J,1) = lithology index PRISM J
!   NP11 = 11 * original value of NPRISM

!  On EXIT, if the system is symmetrical, NPRISM is redefined to be NPRNE
!  and prism sizes adjusted to their size and location in NE quadrant
!  in accordance with the KSYMM = 1 description in pre 2.0 versions.
!  The new PRISM structure is shifted to be in the first NPRNE rows of
!  PBLK & LBLK.

!  If the system is not symmetric, no change is made.

 REAL, PARAMETER :: EWNS= 0.1  ! Spatial tolerance = 0.1 m
 INTEGER NPRISM,NP11,LBLK(NP11,2),KSYMM,NPRNE,NQ,N4SYM,N2SYMEW,N2SYMNS,N1SYM, &
         J,J1,JS,KSTRT,KFIN,MATCH,MATCH3,JN
 REAL PBLK(NP11,9),TE,TN,E_CHK(5),N_CHK(5),QE,QN,QS,QW,TMPE,TMPN
 INTENT (IN) NP11
 INTENT (OUT) TE,TN,KSYMM
 INTENT (INOUT) NPRISM,LBLK,PBLK


!  For the trivial case of 1 prism, restructure to fit MARCO_3D and RETURN.

 KSYMM = 1
 IF (NPRISM == 1) THEN
   TE = PBLK(1,1)
   TN = PBLK(1,2)
   PBLK(1,4) = PBLK(1,4) / 2.  !  Reduce size to 1/4 of original
   PBLK(1,5) = PBLK(1,5) / 2.
   PBLK(1,1) = PBLK(1,4) / 2.  !  New east and north coordinates are
   PBLK(1,2) = PBLK(1,5) / 2.  !  the centre of the reduced PRISM

!===========================
   RETURN
!===========================

 END IF

!  Compute TE & TN

 TN = 0
 TE = 0
 DO J = 1, NPRISM
   TE = TE + PBLK(J,1)
   TN = TN + PBLK(J,2)
 END DO
 TN = TN / REAL (NPRISM)
 TE = TE / REAL (NPRISM)

!  Transform into model centre coordinates and look for trivial symmetry violation.
!  Reorder so that the first NPRNE prisms are in the NE quadrant.

 NPRNE = 0     ! number of prisms partially or wholly within NE quadrant
 NQ = 0        ! NPRISM - NPRNE
 N4SYM = 0     ! number of prisms centred on origin
 N2SYMEW = 0   ! number of prisms centred on E-W axis only
 N2SYMNS = 0   ! number of prisms centred on N-S axis only
 N1SYM = 0     ! number of prisms entirely in upper right quadrant (URHQ)

 SL1: DO J = 1, NPRISM
   TMPE = PBLK(J,1) - TE
   TMPN = PBLK(J,2) - TN

!  If the prism straddles N-S axis but isn't centred on it, or
!  if the prism straddles E-W axis but isn't centred on it, the model
!  isn't symmetric.  In this case, EXIT SL1

   QE = TMPE + PBLK(J,4) / 2.    ! Prism size E-W
   QW = TMPE - PBLK(J,4) / 2.
   IF (QE * QW < -EWNS .AND. ABS (TMPE) > EWNS) KSYMM = 0
   IF (KSYMM == 0) EXIT SL1

   QN = TMPN + PBLK(J,5) / 2.    ! Prism size N-S
   QS = TMPN - PBLK(J,5) / 2.
   IF (QN * QS < -EWNS .AND. ABS (TMPN) > EWNS) KSYMM = 0
   IF (KSYMM == 0) EXIT SL1

   IF (TMPE > -EWNS .AND. TMPN > -EWNS) THEN
     NPRNE = NPRNE + 1           ! centre is in or on boundary of NE quadrant
     JN = NPRISM + NPRNE
     IF (TMPE < EWNS) THEN       ! centre is on upper N-S axis
       IF (TMPN < EWNS) THEN     ! centre is at origin
         N4SYM = N4SYM + 1
         LBLK(JN,2) = 4
       ELSE                      ! centre is on upper N-S axis but not at origin
         N2SYMEW = N2SYMEW + 1       ! East-West symmetry for this block
         LBLK(JN,2) = 21         ! Need to find match south of E-W axis
       END IF
     ELSE IF (TMPN < EWNS) THEN  ! centre is on right E-W axis but not at origin
       N2SYMNS = N2SYMNS + 1       ! East-West symmetry for this block
       LBLK(JN,2) = 22           ! Need to find match west of N-S axis
     ELSE
       N1SYM = N1SYM + 1         ! centre is entirely in NE quadrant
       LBLK(JN,2) = 1            ! Need to find matches in other 3 quadrants
     END IF
   ELSE
     NQ = NQ + 1                 ! no part of the prism is in the NE quadrant
     JN = 2*NPRISM + 1 - NQ      ! fill in from 2*MPRISM upwards
   END IF

   LBLK(JN,1) = LBLK(J,1)
   PBLK(JN,1) = TMPE
   PBLK(JN,2) = TMPN
   PBLK(JN,3:9) = PBLK(J,3:9)
 END DO SL1

 IF (N4SYM + 2* (N2SYMNS + N2SYMEW) + 4* N1SYM /= NPRISM) KSYMM = 0

!===========================
 IF (KSYMM == 0) RETURN
!===========================

! Look for matches

 KSTRT = NPRISM + NPRNE + 1
 KFIN = 2*NPRISM

 SL3: DO J = NPRISM + 1, NPRISM + NPRNE
   E_CHK(1) = 0.          ! Find matching prism south of E-W axis
   N_CHK(1) = -PBLK(J,2)

   E_CHK(2) = -PBLK(J,1)  ! Find matching prism west of N-S axis
   N_CHK(2) = 0.

   E_CHK(3) =  PBLK(J,1)  ! Find matching prism in SE quadrant
   N_CHK(3) = -PBLK(J,2)

   E_CHK(4) = -PBLK(J,1)  ! Find matching prism in SW quadrant
   N_CHK(4) = -PBLK(J,2)

   E_CHK(5) = -PBLK(J,1)  ! Find matching prism in NE quadrant
   N_CHK(5) =  PBLK(J,2)

   MATCH = 1
   IF (LBLK(J,2) == 4) CYCLE SL3 ! prism centred on origin

   IF (LBLK(J,2) == 21) THEN     ! look for EW symmetric prism
     DO J1 = KSTRT, KFIN         ! centred on negative NS axis
       CALL CHK_SYM_PROP (J,J1,N_CHK(1),E_CHK(1),MATCH)
       IF (MATCH == 1) CYCLE SL3
     END DO
     IF (MATCH == 0) EXIT SL3

   ELSE IF (LBLK(J,2) == 22) THEN  ! look for NS symmetric prism
     DO J1 = KSTRT, KFIN           ! centred on negative EW axis
       CALL CHK_SYM_PROP (J,J1,N_CHK(2),E_CHK(2),MATCH)
       IF (MATCH == 1) CYCLE SL3
     END DO
     IF (MATCH == 0) EXIT SL3

   ELSE IF (LBLK(J,2) == 1) THEN
     MATCH3 = 0
     SL4: DO JS = 3,5           ! Find matches in other three quadrants
       DO J1 = KSTRT, KFIN
         CALL CHK_SYM_PROP (J,J1,N_CHK(JS),E_CHK(JS),MATCH)
         IF (MATCH == 1) THEN
           MATCH3 = MATCH3 + 1  ! Success in quadrant I = JS - 2
           CYCLE SL4
         END IF
       END DO
       IF (MATCH == 0) EXIT SL3
     END DO SL4
   END IF
 END DO SL3

 KSYMM = MATCH
 IF (KSYMM == 1) THEN  !  Set up NPRNE prisms as stand alone
   DO J = 1, NPRNE     !  Relocate to top of matrix
     JS = NPRISM + J
     LBLK(J,1:2) = LBLK(JS,1:2)
     PBLK(J,3) = PBLK(JS,3)
     PBLK(J,6:9) = PBLK(JS,6:9)

     IF (LBLK(JS,2) == 4) THEN      !  Reduce block currently centred at origin
       PBLK(J,4) = PBLK(JS,4) / 2.  !  Reduce size to 1/4 of original
       PBLK(J,5) = PBLK(JS,5) / 2.
       PBLK(J,1) = PBLK(J,4) / 2.   !  Relocate reduced block centre to NE quadrant
       PBLK(J,2) = PBLK(J,5) / 2.   !

     ELSE IF (LBLK(JS,2) == 21) THEN !  Reduce block currently in NE & NW quadrants
       PBLK(J,4) = PBLK(JS,4) / 2.   !  Reduce size to 1/2 of original
       PBLK(J,5) = PBLK(JS,5)
       PBLK(J,1) = PBLK(J,4) / 2.    !  Relocate reduced block centre to NE quadrant
       PBLK(J,2) = PBLK(JS,2)        !

     ELSE IF (LBLK(JS,2) == 22) THEN !  Reduce block currently in NE & SE quadrants
       PBLK(J,4) = PBLK(JS,4)
       PBLK(J,5) = PBLK(JS,5) / 2.   !  Reduce size to 1/2 of original
       PBLK(J,1) = PBLK(JS,1)
       PBLK(J,2) = PBLK(J,5) / 2.    !  Relocate reduced block centre to NE quadrant

     ELSE IF (LBLK(JS,2) == 1) THEN
       PBLK(J,1:5) = PBLK(JS,1:5)
     END IF
   END DO
   NPRISM = NPRNE
 END IF

 CONTAINS

   SUBROUTINE CHK_SYM_PROP (L1,L2,N1,E1,MATCH)
!  -------------------------------------------

!  Compares locations, depth to top and dimensions of prisms L1 * L2.
!  If all agree within tolerance EWNS, MATCH = 1
!  If one property is outside the tolerance, MATCH = 0

   INTEGER L1,L2,MATCH,JD
   REAL DIFF1,N1,E1

   MATCH = 1
   IF (LBLK(L1,1) /= LBLK(L2,1) ) MATCH = 0

   DIFF1 = ABS (E1 - PBLK(L2,1))
   IF (DIFF1 > EWNS) MATCH = 0

   DIFF1 = ABS (N1 - PBLK(L2,2))
   IF (DIFF1 > EWNS) MATCH = 0

   DO JD = 3,9
     DIFF1 = ABS (PBLK(L1,JD) - PBLK(L2,JD))
     IF (DIFF1 > EWNS) MATCH = 0
   END DO

   END SUBROUTINE CHK_SYM_PROP

 END SUBROUTINE CHK_SYMMETRY

 REAL FUNCTION COSTRN (WF,YFRQ,NFRQ,KFRQ,T)
!------------------------------------------

!***  Calls CUBVAL
!***  Called by TDEM_3D

! LAST MODIFICATION DATE: June, 2001

! Produces time-domain value at time T by cosine transformation of NFRQ
! frequency-domain values contained in cubic spline array YFRQ.
! KFRQ is the high frequency cutoff, less than or equal to NFRQ.
! Array WF contains the LOG (base e) of the angular frequency values.

! The routine uses filter coefficients derived from the Niels Christensen
! fast Hankel transform routine FILCOA at a spacing of 12 points per decade
! and omega = 0.3.  Various filters were tested using a vertical magnetic
! dipole receiver in a very large circular for which accurate frequency
! and time-domain solutions were programmed.  This particular filter gave
! the overall best accuracy for 1/2 spaces ranging in resistivity from
! .1 to 10,000 ohm-m for times ranging from .01 to 50 msec.


!  K(W,T) = (2/PI) * F(W) * COS(WT) dW

! Letting X = WT, the above becomes
!
!  K(W,T) = (2/PI*T) * F(X/T) * COS(X) dX
!
! From Abramowitz and Stegun, COS(X) = SQRT(X*PI/2) * J(-1/2:X).
! Filter Coefficients are used to represent X**(1/2) * J(-1/2:X)
!
!  COSTRN = SQRT (2/PI) * SUM(i) { WCOS(i) * F [X(i) /T] }

 USE MG_Filter_coefficients

 IMPLICIT NONE
 INTEGER, PARAMETER :: NDEC_COS=12, KFLOW=-200, KFHIGH=99
 REAL, PARAMETER :: FAC=.7978846, TOL=1.0E-4
 INTEGER J1,NFRQ,KFRQ
 REAL WF(NFRQ),YFRQ(4,NFRQ),T,YTYM,YS,VAL,CUBVAL
 DOUBLE PRECISION DELTA,Y1,Y,TD

 INTENT (IN) WF,YFRQ,NFRQ,T


 DELTA = LOG (10.D0)/ DBLE (NDEC_COS)
 TD = DBLE(T)
 YTYM = 0.
 Y1 = -LOG (TD) - DBLE (DELCOS)

! Begin right side convolution at weight 0.
! Stop when frequency domain array is exhausted.

 MOVE_HIGH: DO J1 = 0, KFHIGH

   Y = Y1 + J1 * DELTA
   YS = REAL(Y)
   IF (YS > WF(KFRQ)) EXIT MOVE_HIGH
   IF (YS < WF(1)) YS = WF(1)
   VAL = WCOS(J1) * CUBVAL (WF,YFRQ,NFRQ,YS)
   YTYM = YTYM + VAL
 END DO MOVE_HIGH

 Y = Y1

! Begin left side convolution at weight -1.
! When log angular frequency is less than WF(3), check convergence.
! Continue left using the fact that impulse B is inversely proportional to
! frequency as freq -> 0; i.e., step response B is constant.

 MOVE_LOW: DO J1 = -1, KFLOW, -1

   Y = Y1 + J1 * DELTA
   YS = REAL(Y)
   IF (YS > WF(KFRQ)) CYCLE
   IF (YS < WF(1)) YS = WF(1)
   VAL = WCOS(J1) * CUBVAL (WF,YFRQ,NFRQ,YS)
   YTYM = YTYM + VAL
   IF ((Y < WF(3))) THEN
     IF (ABS (VAL) < TOL * ABS (YTYM)) EXIT MOVE_LOW
   END IF
 END DO MOVE_LOW

 COSTRN = FAC * YTYM / T

END FUNCTION COSTRN

  REAL FUNCTION CUBINT (XKNOT, COEF, KNOT, X1, X2)
! ------------------------------------------------

!  Integrates a function from X1 to X2 using its cubic spline representation.

!***  Called by  TXCNVD, TXCNVL
!***  Calls INTERV.  On exit from INTERV
!
!       MFLAG = -1  => X is to the left of interpolated range
!             =  1  => X is to the right of interpolated range
!             =  0  => X is in the interpolated range

!      KNOT - total number of knots including endpoints.
!
!     XKNOT(I), I = 1,KNOT - Location of the knots.  The rightmost data
!                            point used to calculate coefficients is not
!                            included.
!
!     COEF(J,I), J = 1,4; I = 1,KNOT
!
!              The coefficients of the cubic spline represent the
!              indefinite integral of F, on the I'th interval, as:
!
!       INTGR [ F(X) ] = COEF(4,I)/24 * H**4  +  COEF(3,I)/6 * H**3  +
!                        COEF(2,I)/2 * H**2  +  COEF(1,I) * H
!
!                          WITH  H = X - XKNOT(K)
!
!  This is a modification of the FUNCTION PPVALU in the book
!  "A PRACTICAL GUIDE TO SPLINES"  by C. DE BOOR

!*********************************************************************

  IMPLICIT NONE
  INTEGER I,I1,I2,MFLAG,KNOT
  REAL H,H1,H2,X1,X2,XKNOT(KNOT), COEF(4,KNOT)

!  Find the indices I1 and I2 of largest breakpoints to the left of X1
!  and X2 respectively.
!
  CALL INTERV ( XKNOT, KNOT-1, X1, I1, MFLAG )
  CALL INTERV ( XKNOT, KNOT-1, X2, I2, MFLAG )
  H1 = X1 - XKNOT(I1)
  IF (MFLAG == -1) H1 = 0.

  H2 = X2 - XKNOT(I2)
  CUBINT = (((COEF(4,I2)*H2/4.0 + COEF(3,I2) )*H2/3.0 + &
              COEF(2,I2) )*H2/2.0 + COEF(1,I2) )*H2 &
         - (((COEF(4,I1)*H1/4.0 + COEF(3,I1) )*H1/3.0 + &
              COEF(2,I1) )*H1/2.0 + COEF(1,I1) )*H1

!  Include integrals over intervening intervals.

  IF (I2 > I1) THEN
    DO I = I1, I2-1
      H = XKNOT(I+1) - XKNOT(I)
      CUBINT = CUBINT + (((COEF(4,I)*H/4.0 + COEF(3,I) )*H/3.0 + &
                           COEF(2,I) )*H/2.0 + COEF(1,I) )*H
    END DO
  END IF

END FUNCTION CUBINT

  SUBROUTINE CUBSPL (XNOT, C, N, IBCBEG, IBCEND)
! ----------------------------------------------

!***  Called by FOLD_AND_CONVOLVE, READ_SYSTEM_AND_LAYER_DATA, TXCNVD

!  Calculates coefficients for cubic spline interpolation.
!  Call function CUBVAL to evaluate function values after interpolation.
!  From  * A PRACTICAL GUIDE TO SPLINES *  by Carl de Boor.

!             INPUT
!             -----
!
!     N = number of data points. assumed to be > 1.
!
!  (XNOT(I), C(1,I), I=1,...,N) = abscissae and ordinates of the data points.
!                                 XNOT is assumed to be strictly increasing.
!
!     IBCBEG, IBCEND = boundary condition indicators, and
!     C(2,1), C(2,N) = boundary condition information. Specifically,
!
!     IBCBEG = 0  No boundary condition at XNOT(1) is given.  In this case,
!                 the not-a-knot condition is used, i.e. the jump in the
!                 third derivative across XNOT(2) is forced to zero.  Thus
!                 first and the second cubic polynomial pieces are made to
!                 coincide.
!     IBCBEG = 1  the slope at XNOT(1) is made to equal C(2,1),
!                 supplied by input.
!     IBCBEG = 2  the second derivative at XNOT(1) is made to equal C(2,1),
!                 supplied by input.
!
!     IBCEND = 0, 1, or 2 has analogous meaning concerning the boundary
!                 condition at XNOT(n), with the additional information
!                 taken from C(2,n).
!
!          OUTPUT
!          ------
!
!     C(J,I), J=1,...,4; I=1,...,L (= N-1) = the polynomial coefficients
!         of the cubic interpolating spline with interior knots (or joints)
!         XNOT(2), ..., XNOT(N-1).
!
!        In the interval: (XNOT(I) - XNOT(I+1)), the spline F is given by:
!
!        F(X) = C(1,I) + H* (C(2,I) + H* (C(3,I) + H* C(4,I)/3.) /2.)
!
!     where H = X - XNOT(I).  FUNCTION  *CUBVAL* may be
!     used to evaluate F or its derivatives from XNOT,C, L = N-1,
!     AND K=4.
!******************************************************************************
!******************************************************************************
  IMPLICIT NONE
  INTEGER IBCBEG,IBCEND,N,I,J,L,M
  REAL C(4,N),XNOT(N),DIVDF1,DIVDF3,DXNOT,G

  INTENT (IN) XNOT, N, IBCBEG, IBCEND
  INTENT (INOUT) C
  SAVE

!  A tridiagonal linear system for the unknown slopes S(I) of F at
!  XNOT(I), I=1,...,N, is generated and then solved by Gauss elimination,
!  with S(I) ending up in C(2,I), ALL I.
!  C(3,.) AND C(4,.) are used initially for temporary storage.

!  Compute first differences of XNOT sequence and store in C(3,.).
!  Also, compute first divided difference of data and store in C(4,.).

  L = N - 1
  DO M = 2,N
    C(3,M) = XNOT(M) - XNOT(M-1)
    C(4,M) = (C(1,M) - C(1,M-1)) /C(3,M)
  END DO

!  Construct first equation from the boundary condition, of the form
!  C(4,1)*S(1) + C(3,1)*S(2) = C(2,1)

      IF (IBCBEG < 1) THEN
        IF (N > 2) THEN

!  Not-a-knot condition at left end and N > 2.

          C(4,1) = C(3,3)
          C(3,1) = C(3,2) + C(3,3)
          C(2,1) = ((C(3,2) + 2.* C(3,1)) * C(4,2)*C(3,3) &
                  + C(3,2)**2 * C(4,3)) /C(3,1)
          GOTO 100
        ELSE

!  No condition at left end and N = 2.

          C(4,1) = 1.
          C(3,1) = 1.
          C(2,1) = 2. * C(4,2)
          GOTO 300
        END IF
      ELSE IF (IBCBEG == 1) THEN

!  Slope prescribed at left end.

        C(4,1) = 1.
        C(3,1) = 0.
      ELSE

!  Second derivative prescribed at left end.

        C(4,1) = 2.
        C(3,1) = 1.
        C(2,1) = 3.* C(4,2) - C(3,2) * C(2,1) /2.
      END IF
      IF (N == 2) GOTO 300

!  if there are interior knots, generate the corresponding equations and
!  perform the forward pass of Gauss elimination, after which the M-TH
!  equation reads    C(4,M)*S(M) + C(3,M)*S(M+1) = C(2,M).

  100 DO M = 2,L
        G = -C(3,M+1) / C(4,M-1)
        C(2,M) = G*C(2,M-1) &
                + 3.* (C(3,M)*C(4,M+1) + C(3,M+1)*C(4,M))
        C(4,M) = G* C(3,M-1) + 2.* (C(3,M) + C(3,M+1))
      END DO

!  Construct last equation from the second boundary condition, of the form
!  (-G*C(4,N-1))*S(N-1) + C(4,N)*S(N) = C(2,N)
!  If slope is prescribed at right end, one can go directly to back-
!  substitution, since C array happens to be set up just right for it
!  at this point.

      IF (IBCEND < 1) THEN
        IF ( N /=3 .OR. IBCBEG /=0 ) THEN

!  Not-a-knot and N > 2, and either N > 3 or also not-a-knot at
!  left end point.

          G = C(3,N-1) + C(3,N)
          C(2,N) = ((C(3,N) + 2.*G) *C(4,N)*C(3,N-1) + C(3,N)**2 &
                  *(C(1,N-1) - C(1,N-2)) /C(3,N-1))/G
          G = -G / C(4,N-1)
          C(4,N) = C(3,N-1)
          GOTO 350
        END IF
      ELSE IF (IBCEND == 1) THEN
        GOTO 400
      ELSE
        GOTO 250
      END IF

!  Either (N=3 and not-a-knot also at left) or (N=2 and not not-a-
!  knot at left end point).

  200 C(2,N) = 2. * C(4,N)
      C(4,N) = 1.
      G = -1. / C(4,N-1)
      GOTO 350

!  Second derivative prescribed at right endpoint.

  250 C(2,N) = 3.*C(4,N) + C(3,N)*C(2,N)/2.
      C(4,N) = 2.
      G = -1. / C(4,N-1)
      GOTO 350
  300 IF (IBCEND < 1) THEN
        IF (IBCBEG > 0) GOTO 200

!  Not-a-knot at right endpoint and at left endpoint and N = 2.

        C(2,N) = C(4,N)
        GOTO 400
      ELSE IF (IBCEND == 1) THEN
        GOTO 400
      ELSE
        GOTO 250
      END IF

!  Complete forward pass of Gauss elimination.

  350 C(4,N) = G*C(3,N-1) + C(4,N)
      C(2,N) = (G*C(2,N-1) + C(2,N)) /C(4,N)

!  Perform back substitution.

  400 J = L
  450 C(2,J) = (C(2,J) - C(3,J) *C(2,J+1)) /C(4,J)
      J = J - 1
      IF (J > 0) GOTO 450

!  Generate cubic coefficients in each interval, i.e., the derivatives at its
!  left endpoint, from value and slope at its endpoints.

  DO I = 2,N
    DXNOT = C(3,I)
    DIVDF1 = (C(1,I) - C(1,I-1)) /DXNOT
    DIVDF3 = C(2,I - 1) + C(2,I) - 2.*DIVDF1
    C(3,I-1) = 2.* (DIVDF1 - C(2,I-1) - DIVDF3) /DXNOT
    C(4,I-1) = (DIVDF3/DXNOT) * (6./DXNOT)
  END DO
END SUBROUTINE CUBSPL

  REAL FUNCTION CUBVAL (XKNOT, COEF, KNOT, X1)
! --------------------------------------------

!  Evaluates a function at X1 from from its cubic spline representation.

!***  Called by COSTRN, FOLD_AND_CONVOLVE, TXCNVD, TXCNVL
!***  Calls INTERV.  On exit from INTERV
!
!       MFLAG = -1  => X is to the left of interpolated range
!             =  1  => X is to the right of interpolated range
!             =  0  => X is in the interpolated range

!      KNOT - total number of knots including endpoints.
!
!     XKNOT(I), I = 1,KNOT - location of the knots.  The rightmost data
!                            point used to calculate coefficients is not
!                            included.
!
!     COEF(J,I), J = 1,4; I = 1,KNOT
!
! The coefficients of the cubic spline on the I'th interval represent F as:
!
!                F(X) = COEF(4,I)/6 * H**3  +  COEF(3,I)/2 * H**2  +
!                       COEF(2,I) * H  +  COEF(1,I)
!
!                          with  H = X - XKNOT(I)
!
!  This is a modification of the FUNCTION PPVALU in the book
!  "A PRACTICAL GUIDE TO SPLINES"  by C. DE Boor
!
!             METHOD
!             ------
!
!  The interval index I, appropriate for X, is found through a call to INTERV.
!  The formula for F is evaluated using nested multiplication.
!******************************************************************************

  IMPLICIT NONE
  INTEGER I,MFLAG,KNOT
  REAL XKNOT(KNOT),COEF(4,KNOT),X1,H

  INTENT (IN) XKNOT, COEF, KNOT, X1
!
!  Find index I of largest breakpoint to the left of X1.
!
  CALL INTERV ( XKNOT, KNOT-1, X1, I, MFLAG )
  H = X1 - XKNOT(I)
  IF (MFLAG == -1) H = 0.

  CUBVAL = ((COEF(4,I)*H/3.0 + COEF(3,I) )*0.5*H + COEF(2,I) )*H + COEF(1,I)

END FUNCTION CUBVAL

 SUBROUTINE FD_CURNT (NFRQ,LRX,NTXE,CURNT,RFD)
!---------------------------------------------

!*** Called by MAIN
!  Multiplies FD response per amp by transmitter current

 IMPLICIT NONE
 INTEGER JR,JF,JC,JS,NFRQ,LRX,NTXE
 REAL CURNT(NFRQ)
 COMPLEX RFD(NFRQ,LRX,NTXE,3)

 DO JC = 1, 3
   DO JS = 1, NTXE
     DO JR = 1, LRX
       DO JF = 1,NFRQ
         RFD(JF,JR,JS,JC) = CURNT(JF) * RFD(JF,JR,JS,JC)
       END DO
     END DO
   END DO
 END DO

 END SUBROUTINE FD_CURNT

 SUBROUTINE FDREAD (ND,NFRQ,NTXE,LRX,NRXTX,NCMP,BFD,BFD_SCAT,OUTPUT)
!------------------------------------------------------------------

!  Reads frequency-domain scattered impulse magnetic field data
!  (real & imaginary components) from logical UNIT ND into
!  array BFD_SCAT for conversion to time-domain by SUBROUTINE TDEM_OUT.
!
!  THIS SUBROUTINE HAS A SPECIAL FEATURE FOR MARCO.
!      It first reads the original DO3D value.  If this DO3D0 = 1
!      then half space and 3D data are read. Otherwise, only halfspace
!      data are read and OUTPUT is set to 10.

!*** Called by MAIN

!            NFRQ - number of frequencies
!            NTXE - number of transmitter positions
!             LRX - maximum number of receivers for any transmitter
!           NRXTX - number of receivers for each transmitter position
!            NCMP - number of components for each receiver
!   BFD1(I,J,K,L) - Lth component of the complex frequency-domain impulse
!                   response at receiver J, corresponding to transmitter K
!                   for frequency I.  Usually L = 1,2,3 => North, East, & vertical
!                   components respectively.  If NCMP = 1 as is the case for loop,
!                   electric dipole of coupled magnetic dipoles then the relevant
!                   component is stored in L=1 position
!          OUTPUT - set to print only total (=halfspace) field if the original computation had DO3D = 0

  IMPLICIT NONE
  INTEGER OUTPUT,DO3D0,ND,NFRQ,NTXE,LRX,NRXTX(NTXE),NCMP(LRX,NTXE),JF,JS,JR,JC,NC,NC2
  REAL A(6)
  COMPLEX BFD_SCAT(NFRQ,LRX,NTXE,3),BFD(NFRQ,LRX,NTXE,3)

  READ(ND,*) DO3D0
  DO JS = 1, NTXE
    DO JR = 1, NRXTX(JS)
      NC = NCMP(JR,JS)
      NC2 = 2*NC
      DO JF = 1,NFRQ
        READ(ND,*) A(1:NC2)
        DO JC = 1,NC
          BFD(JF,JR,JS,JC) = CMPLX (A(2*JC-1), A(2*JC))
        END DO
        IF (DO3D0 > 0) THEN
          READ(ND,*) A(1:6)
          DO JC = 1,NC
            BFD_SCAT(JF,JR,JS,JC) = CMPLX (A(2*JC-1), A(2*JC))
          END DO
        ELSE
          OUTPUT = 10
        END IF
      END DO
    END DO
  END DO
END SUBROUTINE FDREAD

 SUBROUTINE INTERV (XT, LXT, X, LEFT, MFLAG)
!-------------------------------------------

!***   Called by CUBVAL, CUBINT

!********  Restructured April, 1997

!  from  * A PRACTICAL GUIDE TO SPLINES *  by C. DE BOOR
!  computes  LEFT = MAX( I , 1 <= I <= LXT  .AND.  XT(I) <= X )  .
!
!             INPUT
!             -----
!       XT - a real sequence, of length  LXT, assumed to be non-decreasing.
!      LXT - number of terms in the sequence  XT .
!        X - the point whose location with respect to the sequence XT is
!            to be determined.
!
!             OUTPUT
!             ------
!      LEFT, MFLAG.....are both integers, whose value is:
!
!        1     -1      IF               X <  XT(1)
!        I      0      IF   XT(I)  <= X < XT(I+1)
!       LXT     1      IF  XT(LXT) <= X
!
!        In particular, MFLAG = 0 is the 'usual' case.  MFLAG /= 0
!        indicates that X  lies outside the halfopen interval
!        XT(1) <= Y < XT(LXT) . The asymmetric treatment of the
!        interval is due to the decision to make all pp functions
!        continuous from the right.
!
!             METHOD
!             ------
!
!  The program is designed to be efficient in the common situation that
!  it is called repeatedly, with  X  taken from an increasing or decreasing
!  sequence. This will happen, e.g., when a pp function is to be grapged.
!  The first guess for  LEFT  is therefore taken to be the value returned at
!  the previous call and stored in the  L O C A L  variable ILO. A first
!  check ascertains that  ILO < LXT (This is necessary since the present
!  call may have nothing to do with the previous call).
!  Then, if XT(ILO) <= XT(ILO+1),
!  we set  LEFT = ILO  and are done after just three comparisons.
!  Otherwise, we repeatedly double the difference  ISTEP = IHI - ILO
!  while also moving  ILO  AND  IHI  in the direction of  X , until
!                      XT(ILO) <= X < XT(IHI) ,
!  after which we use bisection to get, in addition, ILO+1 = IHI .
!  LEFT = ILO  is then returned.
!******************************************************************************
!******************************************************************************

  IMPLICIT NONE
  INTEGER LEFT,LXT,MFLAG,IHI,ILO,ISTEP,MIDDLE,J1
  REAL X,XT(LXT)
  SAVE ILO

  DATA ILO /1/

!***********************************************************
!  Trivial returns when X is not in the range.

  IF ( (X <= XT(1)) .OR. (LXT <= 1) ) THEN
    MFLAG = -1
    LEFT = 1
    RETURN
  END IF

  IF (X >= XT(LXT)) THEN
    MFLAG = 1
    LEFT = LXT
    RETURN
  END IF

  MFLAG = 0
  IF (ILO >= LXT) ILO = LXT-1
  IHI = ILO + 1

!  Trivial return when X is already in the interval.

  IF ( (X <= XT(IHI)) .AND. (X >= XT(ILO)) ) THEN
    LEFT = ILO
    RETURN
  END IF
!***********************************************************

  IF (X <= XT(ILO)) THEN  ! decrease ILO  to capture X.
    ISTEP = 1
    DO J1 = 1,LXT
      IHI = ILO
      ILO = IHI - ISTEP
      ILO = MAX(1, ILO)
      IF ( (X >= XT(ILO)) .OR. (ILO == 1) ) EXIT
      ISTEP = ISTEP*2
    END DO

  ELSE IF ( X >= XT(IHI)) THEN  ! increase IHI to capture X

    ISTEP = 1
    DO J1 = 1,LXT
      ILO = IHI
      IHI = ILO + ISTEP
      IHI = MIN (IHI,LXT)
      IF ( (X <= XT(IHI)) .OR. (IHI == LXT) ) EXIT
      ISTEP = ISTEP*2
    END DO

  END IF

!  Now XT(ILO) <= X < XT(IHI) . Narrow the interval.

  DO J1 = 1,LXT
    MIDDLE = (ILO + IHI)/2
    IF (MIDDLE == ILO) EXIT
    IF (X < XT(MIDDLE)) THEN
      IHI = MIDDLE
    ELSE
      ILO = MIDDLE
    END IF
  END DO

! Task complete

  LEFT = ILO
  RETURN

END SUBROUTINE INTERV

 SUBROUTINE MD_PRM (NW,SXDP1,SXAZ1,RXON,RXOE,RXOZ,CMPDX,DXPRM)
!-------------------------------------------------------------

!***  Called by MAIN

! Computes three components of the direct DC free space magnetic field B in the
! orthogonal borehole system defined by SXAZ & SXDIP, expressed in Teslas.
! For time-domain applications, multiply it by current and get T.
! Multiply it by dI/dt and get volts per unit area which is the same as T/s.
!
! This version considers only a single probe with fixed offset.
!
!               INPUT
!               -----
!  RXON, RXOE, RXOZ - north, east & depth offsets of dipole receiver
!             CMPDX = 3 => 3 borehole components
!             CMPDX = 1 => axial component only
!
!               OUTPUT
!               ------
!
!   DXPRM(K,1) - Kth component of the direct field in teaslas
!   DXPRM(1:3,2) = absolute value of normalising component
!
!      Components:  K = 1 => Horizontal,  K = 2 => Slope,  K = 3 => Axial
!
!      The Axial component lies along the borehole axis, defined by SXDIP.
!         If the hole is vertical, it contains the vertical component.
!         If the hole is horizontal, with azimuth = 0, it points north.
!      The Slope component lies in the vertical plane containing the borehole.
!         If the hole is vertical, it points North. (12 o'clock)
!         If the hole is horizontal, it contains the vertical component.
!      The Horizontal component is perpendicular to Slope and Axial.
!         If the hole is vertical, it points West. (9 o'clock)

!        Current default OUTPUT:
!          If the magnitude of DXPRM(K,1) > 0.1 Total field
!               DXPRM(K,2) = absolute value of DXPRM(K,1)
!          Otherwise
!               DXPRM(K,2) = Total field

 IMPLICIT NONE
 INTEGER NW,CMPDX
 REAL SXDP1,SXAZ1,RXON,RXOE,RXOZ,SNDP,CSDP,SNAZ,CSAZ,BFAC,FAC3,XRX,YRX, &
      ZRX,R,ZR,TOL,DXPRM(3,2),TOTAL

!  BFAC = MU / (4 * PI) for time domain => output is in Teslas

 BFAC = 1.E-7

 SNDP = SIN (SXDP1)
 CSDP = COS (SXDP1)
 SNAZ = SIN (SXAZ1)
 CSAZ = COS (SXAZ1)

!  Rotate the components into the transmitter dip & azimuth system

 XRX = RXON * CSAZ + RXOE * SNAZ
 YRX = RXOE * CSAZ - RXON * SNAZ
 ZRX = RXOZ * CSDP + XRX * SNDP
 XRX = XRX * CSDP - RXOZ * SNDP

 R = SQRT (ZRX**2 + XRX**2 + YRX**2)
 ZR = ZRX / R
 FAC3 = BFAC / R**3

 DXPRM(1,1) = FAC3 * (3.* ZR * YRX/R)
 DXPRM(2,1) = FAC3 * (3.* ZR * XRX/R)
 DXPRM(3,1) = FAC3 * (3.* ZR * ZR - 1.)
 TOTAL = FAC3 * SQRT (3.* ZR * ZR + 1.)

 TOL = 0.1 * TOTAL
 DXPRM(1:3,2) = ABS (DXPRM(1:3,1))

 IF (CMPDX == 3) THEN
   WRITE(NW,4) 1.E12*DXPRM(3,1),1.E12*DXPRM(2,1),1.E12*DXPRM(1,1),1.E12*TOTAL

   IF (DXPRM(1,2) < TOL) THEN
     DXPRM(1,2) = TOTAL
     WRITE(NW,1)
   END IF
   IF (ABS (DXPRM(2,2)) < TOL) THEN
     DXPRM(2,2) = TOTAL
     WRITE(NW,2)
   END IF
 ELSE
   WRITE(NW,5) 1.E12*DXPRM(3,1),1.E12*TOTAL
 END IF
 IF (ABS (DXPRM(3,2)) < TOL) THEN
   DXPRM(3,2) = TOTAL
   WRITE(NW,3)
 END IF

 1 FORMAT(T3,'The Horizontal component will be normalised by the TOTAL field.')
 2 FORMAT(T3,'The Slope component will be normalised by the TOTAL field.')
 3 FORMAT(T3,'The Axial component will be normalised by the TOTAL field.')
 4 FORMAT(//T7,'PPM OUTPUT for constant offset frequency-domain system' &
           /T7,'------------------------------------------------------' &
          //T7,'DC magnetic field (in Teslas) used for PPM normalisation' &
          //T3,'     Axial field =',G12.4,' picoTeslas.' &
           /T3,'     Slope field =',G12.4,' picoTeslas.' &
           /T3,'Horizontal field =',G12.4,' picoTeslas.' &
           /T3,'  Total DC field =',G12.4,' picoTeslas.' &
          //T3,'All fields will be normalised by the corresponding DC component unless' &
           /T3,'that DC component is less than 10 percent of the total DC field'/)
 5 FORMAT(//T7,'PPM OUTPUT for constant offset frequency-domain system' &
           /T7,'------------------------------------------------------' &
          //T7,'DC magnetic field (in Teslas) used for PPM normalisation' &
          //T3,'     Axial field =',G12.4,' picoTeslas.' &
           /T3,'  Total DC field =',G12.4,' picoTeslas.' &
          //T3,'the Axial fields will be normalised by the Axial DC component.'/)

 END SUBROUTINE MD_PRM

 SUBROUTINE SET_OUTPUT_FACTORS (NRXG,MRX,SURVEY_TYPE,RX_TYPE,RXMNT,STEP,UNITS,OUTTXT,OUTFAC, &
                                AMR_UNITS)
!-------------------------------------------------------------------------------------------

!  Determines output conversion factors and text output units for each receiver group.
!  For magnetic dipole and loop receivers, a factor of MU0 is necessary to convert
!  from H to B

!*** Called by: WRITE_TD, WRITE_FD
!***     Calls: nil

 IMPLICIT NONE
 INTEGER NRXG,MRX,SURVEY_TYPE,STEP,JG
 INTEGER, DIMENSION(NRXG) :: RX_TYPE,UNITS
 REAL, DIMENSION(MRX,NRXG) :: OUTFAC,RXMNT
 CHARACTER(LEN=16) OUTTXT(NRXG)
 CHARACTER (LEN = 06) :: AMR_UNITS(NRXG)

 DO JG = 1,NRXG

   IF (SURVEY_TYPE == 4 .OR. RX_TYPE(JG) > 1) THEN  !  Loop or electrode receivers
     IF (UNITS(JG) == 1) THEN
       OUTFAC(1:MRX,JG) = 1.
       OUTTXT(JG) = 'VOLTS.          '
       AMR_UNITS(JG) = '(V)  '
     ELSE IF (UNITS(JG) == 2) THEN
       OUTFAC(1:MRX,JG) = 1000.
       OUTTXT(JG) = 'MILLIVOLTS.     '
       AMR_UNITS(JG) = '(mV)  '
     ELSE IF (UNITS(JG) == 3) THEN
       OUTFAC(1:MRX,JG) = 1.E6
       OUTTXT(JG) = 'MICROVOLTS.     '
       AMR_UNITS(JG) = '(uV)  '
     ELSE IF (UNITS(JG) == 4) THEN
       OUTFAC(1:MRX,JG) = 1.E9
       OUTTXT(JG) = 'NANOVOLTS.      '
       AMR_UNITS(JG) = '(nV)  '
     END IF

   ELSE IF (STEP == 0 .AND. RX_TYPE(JG) == 1) THEN   ! Measure dB/dt or volts for magnetic dipole receivers

     IF (UNITS(JG) == 1) THEN
       OUTFAC(1:MRX,JG) = 1.E9
       OUTTXT(JG) = 'NANOTESLAS /SEC.'
       AMR_UNITS(JG) = '(nT/s)'
     ELSE IF (UNITS(JG) == 2) THEN
       OUTFAC(1:MRX,JG) = 1.E12
       OUTTXT(JG) = 'PICOTESLAS /SEC.'
       AMR_UNITS(JG) = '(pT/s)'
     ELSE IF (UNITS(JG) == 3) THEN
       OUTFAC(1:MRX,JG) = 1.E6 * RXMNT(1:MRX,JG)
       OUTTXT(JG) = 'MICROVOLTS.     '
       AMR_UNITS(JG) = '(uV)  '
     ELSE IF (UNITS(JG) == 4) THEN
       OUTFAC(1:MRX,JG) = 1.E9 * RXMNT(1:MRX,JG)
       OUTTXT(JG) = 'NANOVOLTS.      '
       AMR_UNITS(JG) = '(nV)  '
     END IF

   ELSE IF (STEP == 1 .AND. RX_TYPE(JG) == 1) THEN

     IF (UNITS(JG) == 1) THEN
       OUTFAC(1:MRX,JG) = 1.E9
       OUTTXT(JG) = 'NANOTESLAS      '
       AMR_UNITS(JG) = '(nT)  '
     ELSE IF (UNITS(JG) == 2) THEN
       OUTFAC(1:MRX,JG) = 1.E12
       OUTTXT(JG) = 'PICOTESLAS      '
       AMR_UNITS(JG) = '(pT)  '
     ELSE IF (UNITS(JG) == 3) THEN
       OUTFAC(1:MRX,JG) = 1.E15
       OUTTXT(JG) = 'FEMTOTESLAS     '
       AMR_UNITS(JG) = '(fT)  '
     END IF

   END IF
 END DO

 END SUBROUTINE SET_OUTPUT_FACTORS

 SUBROUTINE SET_SOURCE (NSX,SWX,SWY,T0SX)
!----------------------------------------

! For time-domain, SET_SOURCE computes dI/dt at the transmitter using
!
! SWY will be in amps / sec * Tx area * NTRN
!  Computes SWY to be dI(t)/dt
!  The units of SWY are amps / s

!*** Called by MAIN

!             INPUT
!             -----
!
!          NSX - number of source points in waveform
!          SWX - time abscissae for input waveform in seconds
!     SWY(*,3) - waveform in amps
!   SWY(*,1:2) = 0
!
!             OUTPUT
!             ------
!
!     SWY(*,2) = delta I(t)  amps
!     SWY(*,1) = dI(t)/dt  amps/s
!         T0SX = latest time at which dI/dt /= 0

 IMPLICIT NONE
 REAL, PARAMETER :: T0_MIN=1.E-7
 INTEGER NSX,JT
 REAL SWX(NSX),SWY(NSX,3),DELT,T0SX

 INTENT (IN) NSX, SWX
 INTENT (INOUT) SWY


! Compute delta I in SWY(*,2) and dI/dt if it exists in SW(*,1).
! Compute the negative derivative so that dI/dt will be positive
! just before signal turn-off.  Store on right node (27.01.00)

 DO JT = 2, NSX
   SWY(JT,2) = SWY(JT-1,3) - SWY(JT,3)
   DELT = SWX(JT) - SWX(JT-1)
   IF (DELT > T0_MIN) THEN
     SWY(JT,1) = SWY(JT,2) / DELT
   END IF
 END DO

 T0SX = SWX(NSX)
 DO JT = NSX-1, 1, -1
   IF ( ABS (SWY(JT,1)) > 1.E-3) EXIT
   T0SX = SWX(JT)
 END DO
END SUBROUTINE SET_SOURCE

 SUBROUTINE TDEM_3D (STEP,NSX,SWX,SWY,NPULS,PULSE,NTYPLS,NTYRP,TRP,NCHNL,TOPN, &
                     TCLS,FREQ,NFRQ,KFRQE,NTXE,LRX,NRXTX,RXID,NCMP,BFD1,BTD1)
!----------------------------------------------------------------------------------

!***  Called by MAIN
!***  Calls CUBSPL, COSTRN, FOLD_CONVOLVE

!  Computes BTD1, the time domain response for the input frequency_domain data.
!  It computes voltage (volts) or dB/dt (teslas/sec) if STEP = 0) or magnetic
!  field B (in teslas) if STEP = 1)  by convolving the step response of the
!  earth with the negative time-derivative of the current waveform.
!  For magnetic field, this is averaged across the receiver window.  For db/dt,
!  or voltage, this is differenced across the  receiver window.  The negative
!  dI/dt is used so that current switch off corresponds to positive response.
!
!  On entry, the imaginary component of the frequency-domain data in array BFD1
!  is divided by frequency and then cosine transformed into time-domain step
!  response data out to NPULS bipolar cycles.  For each receiver position for
!  for each transmitter, FOLD_AND_CONVOLVE is called to fold the positive &
!  negative parts of the bipolar current pulse into a half-cycle (length PULSE)
!  decay curve.  This result is convolved with the dI/dt waveform.
!
!        STEP = 1 iff step response is to be computed
!         NSX - number of points used to discretise transmitter signal
!         SWX - abscissae (seconds) of current waveform
!         SWY - dI/dt at times SWX
!       NPULS - number of bipolar pulses of length PULSE
!       PULSE - length single on pulse plus off-time
!       NTYRP - number of values in TRP for total signal length: 2 * NPULS *PULSE
!         TRP - array of time values for FD -> TD transformations
!      NTYPLS - number of TRP values in 1 PULSE
!       NCHNL - number of channels
!        TOPN - time at which receiver channel I opens.
!        TCLS - time at which receiver channel I closes.
!        FREQ - array of NFRQ frequencies.
!        NTXE - number of transmitter positions.
!         LRX - maximum number of receiver positions for any transmitter position
!    NRXTX(J) = number of receivers FOR transmitter J
!   RXID(I,J) = RX_TYPE of receiver I for transmitter J
!   NCMP(I,J) = number of components for receiver I for transmitter J
!        NCMP = number of components, = 3 or 1 usually
!   BFD1(I,J,K,L) - Lth component of the complex frequency-domain impulse
!                   response at receiver J, corresponding to transmitter K
!                   for frequency I.  Usually L = 1,2,3 => North, East, & vertical
!                   components respectively.  If NCMP = 1 as is the case for loop,
!                   electric dipole or coupled magnetic dipoles then the relevant
!                   component is stored in L=1 position

 IMPLICIT NONE
 REAL, PARAMETER :: TWOPI=6.283185
 INTEGER STEP,NSX,NPULS,NTYPLS,NTYRP,NCHNL,NFRQ,KFRQE,KFRQ,NTXE,LRX,NRXTX(NTXE), &
         NCMP(LRX,NTXE),STEPC,RXID(LRX,NTXE),JR,JS,JF,JC,JT,KC
 REAL, DIMENSION(:,:), ALLOCATABLE ::  YSCAT,YFRQ
 REAL PULSE,FREQ(NFRQ),WF(NFRQ),SWX(NSX),SWY(NSX,3), &
      COSTRN,T,YCUM(NCHNL),TOPN(NCHNL),TCLS(NCHNL),TRP(NTYRP), &
      BTD1(NCHNL,LRX,NTXE,3)
 COMPLEX BFD1(NFRQ,LRX,NTXE,3)

 BTD1 = 0.

 ALLOCATE (YSCAT(4,NTYRP), YFRQ(4,NFRQ) )
 YSCAT=0; YFRQ=0

!  The - sign below is a consequence of using the sine transform for a
!  +iwt sign convention

 WF(1:NFRQ) = ALOG (TWOPI * FREQ(1:NFRQ))

!  For each component at each receiver, compute the time-domain step response
!  by splining the imaginary part of the frequency-domain response, converting
!  it to time-domain step function response and folding the NPULS bipolar decay
!  curve into a combined pulse decay curve of length PULSE.  Convolve this with
!  the TX waveform to produce BTD1, the 'observable" stripped response for the
!  system.

 DO JS = 1,NTXE
   DO JR = 1, NRXTX(JS)
     KC = NCMP(JR,JS)
     STEPC = STEP
     KFRQ = NFRQ
     IF (RXID(JR,JS) == 2) STEPC = 1  ! Transform imaginary B / w to TD step response
     IF (RXID(JR,JS) == 3) THEN
       STEPC = 3                      ! Electrode E field Transform INTEGRAL { E dl } to TD
       KFRQ = KFRQE
     END IF
     DO JC = 1,KC
       DO JF = 1,NFRQ     ! Divide by -iw to set up step response
         IF (STEPC == 3) THEN
           YFRQ(1,JF) = REAL ( BFD1(JF,JR,JS,JC) )
         ELSE
           YFRQ(1,JF) = -AIMAG ( BFD1(JF,JR,JS,JC) ) / (TWOPI * FREQ(JF))
         END IF
       END DO
       CALL CUBSPL (WF,YFRQ,NFRQ,0,0)

       YSCAT = 0.
       DO JT = 1, NTYRP   !  Convert to step-function time-domain.
         T = TRP(JT)
         YSCAT(1,JT) = COSTRN (WF,YFRQ,NFRQ,KFRQ,T)
       END DO

       CALL FOLD_AND_CONVOLVE (STEPC,NSX,SWX,SWY,NPULS,PULSE,TRP,NTYRP,NTYPLS, &
                               NCHNL,TOPN,TCLS,YSCAT,YCUM)

       BTD1(1:NCHNL,JR,JS,JC) = YCUM(1:NCHNL)
     END DO
   END DO
 END DO
 DEALLOCATE (YSCAT, YFRQ)

END SUBROUTINE TDEM_3D

 SUBROUTINE FOLD_AND_CONVOLVE (STEPC,NSX,SWX,SWY,NPULS,PULSE,TRP,NTYRP,NTYPLS, &
                               NCHNL,TOPN,TCLS,YPLS,YCUM)
!----------------------------------------------------------------------------

!  Computes the "observed" response YCUM by convolving the splined earth
!  response function, YPLS, with the TX waveform.

!***  Called by HSBOSS and TDEM_3D
!***  Calls: CUBVAL, CUBSPL, TXCNVL

!    STEPC = 1 => average convolved response over receiver windows.  This will
!                 be the case when input and desired output are both either
!                 step response or impulse response.
!          = 0 => difference convolved response over receiver windows. This will
!                 be the case when input is step and desired output is impulse.
!          = 3 => electrode voltage convolution with current
!      NSX - number of points used to discretise transmitter signal
!      SWX - abscissae (seconds) of current waveform
!      SWY - dI/dt at times SWX
!    NPULS - number of bipolar pulses of length PULSE
!    PULSE - length single on pulse plus off-time
!    NTYRP - number of values in TRP for total signal length: 2 * NPULS *PULSE
!      TRP - array of time values for FD -> TD transformations
!   NTYPLS - number of TRP values in 1 PULSE
!    NCHNL - number of channels
!     TOPN - time at which receiver channel I opens.
!     TCLS - time at which receiver channel I closes.
!

 IMPLICIT NONE
 INTEGER JT,NTYRP,NTYPLS,NPULS,NSX,NCHNL,JGL,JP,STEPC,MXCNV
 REAL PULSE,TRP(NTYRP),SWX(NSX),SWY(NSX,3),TOPN(NCHNL),TCLS(NCHNL),T1,T2,WIDTH, &
      HWIDTH,YC1,YC2,TC(3),GLX(3),GLW(3),YPLS(4,NTYRP),X,XP,YCUM(NCHNL),CUBVAL, &
      TXCNVL,TXCNVD,WT,FOLD(NTYRP)
 DATA GLW(1:3) /.5555556, .8888889, .5555556/, GLX(1:3) /-.7745967, 0., .7745967/

!  Accumulate the results of NPULS bipolar cycles by splining the instantaneous
!  response and folding the positive and negative parts of each cycle back
!  into a single pulse.  For on-time systems, compute a correction factor.
!  which will be based on the negative instantaneous response at .1 microsecond.

 CALL CUBSPL (TRP,YPLS,NTYRP,0,0)
 FOLD = 0.
 DO JT = 1,NTYPLS
   X = TRP(JT)
   XP = X + PULSE
   FOLD(JT) = CUBVAL (TRP,YPLS,NTYRP,X) - CUBVAL (TRP,YPLS,NTYRP,XP)
   FOLD(JT) = CUBVAL (TRP,YPLS,NTYRP,X) - CUBVAL (TRP,YPLS,NTYRP,XP)

   DO JP = 2, NPULS
     X = XP + PULSE
     XP = X + PULSE
     FOLD(JT) = CUBVAL (TRP,YPLS,NTYRP,X) - CUBVAL (TRP,YPLS,NTYRP,XP) &
              + FOLD(JT)
   END DO
 END DO

 YPLS = 0.
 YPLS(1,1:NTYPLS) = FOLD(1:NTYPLS)
 CALL CUBSPL (TRP,YPLS,NTYPLS,0,0)
 YCUM = 0.

 MXCNV = NTYPLS + NSX
 DO JT = 1, NCHNL
   T1 = TOPN(JT)
   T2 = TCLS(JT)
   WIDTH = T2 - T1
   HWIDTH = WIDTH /2.

   IF (STEPC == 0) THEN  ! Differentiate to compute impulse response for step input
     YC1 = TXCNVL (T1,NTYPLS,TRP,YPLS,NSX,SWX,SWY)
     YC2 = TXCNVL (T2,NTYPLS,TRP,YPLS,NSX,SWX,SWY)
     YCUM(JT) = (YC1 - YC2) / WIDTH

   ELSE

! Step response for step input or impulse response for impulse input
! Average the response over receiver windows using 3 point Gaussian integration.

     TC(2) = (TCLS(JT) + TOPN(JT)) /2.
     TC(1) = TC(2) + HWIDTH * GLX(1)
     TC(3) = TC(2) + HWIDTH * GLX(3)

     DO JGL = 1, 3
       T1 = TC(JGL)
       WT = GLW(JGL) / 2.
       IF (STEPC == 1) THEN                                    ! Magnetic dipole or loop receiver
         YC1 = TXCNVL (T1,NTYPLS,TRP,YPLS,NSX,SWX,SWY)
       ELSE IF (STEPC == 3) THEN                                ! Electrode receiver
         YC1 = TXCNVD (MXCNV,T1,NTYPLS,TRP,YPLS,NSX,SWX,SWY,3)  ! Current is in SWY(*,3)
       END IF
       YCUM(JT) = YCUM(JT) + (WT * YC1)
     END DO
   END IF
 END DO

END SUBROUTINE FOLD_AND_CONVOLVE

 SUBROUTINE LP_VERTEX_ORDER (NTXE,MXVRTX,N_VRTX,SXN,SXE,SXZ)
!----------------------------------------------------------

! Assumes that the vertices have been entered in order, either clockwise or
! counter-clockwise.  If counter-clockwise, it reorders them.

!          NTXE - number of loop transmitters
!        MXVRTX - maximum number of vertices for any loop
!     N_VRTX(J) - number of vertices for transmitter J
!      SXE(I,J) = local east coordinate of vertex I for loop position J
!      SXN(I,J) = local coordinate of vertex I for loop position J
!      SXZ(I,J) = local (z positive down) depth of vertex I for loop position J

 IMPLICIT NONE
 INTEGER NTXE,MXVRTX,N_VRTX(NTXE),NV,KS,KS1,JV,J1,JS
 REAL, DIMENSION (MXVRTX,NTXE) :: SXN,SXE,SXZ
 REAL, DIMENSION (NTXE) :: TEMPN,TEMPE,TEMPZ,XN,YE
 REAL R,RMAX,XN_CNTR,YE_CNTR,CTH,STH,EMID

 DO JS = 1,NTXE
   NV = N_VRTX(JS)
   KS = 0
   RMAX = 0.
   DO JV = 1,NV
     J1 = JV + 1
     IF (JV == NV) J1 = 1
     R = (SXN(J1,JS) - SXN(JV,JS))**2 + (SXE(J1,JS) - SXE(JV,JS))**2
     IF (R > RMAX) THEN
       RMAX = R               ! Find longest segment
       KS = JV
     END IF
   END DO

   RMAX = SQRT (RMAX)
   KS1 = KS + 1
   IF (KS1 > NV) KS1 = 1

!  Renumber loop vertices such that order is maintained but the longest segment
!  goes from new verex index NV to 1.  Rotate & translate loop such that vertex
!  NV is at the origin and vetex 1 is north on the axis.

   XN_CNTR = SXN(KS,JS)
   YE_CNTR = SXE(KS,JS)
   CTH = (SXN(KS1,JS) - XN_CNTR) / RMAX
   STH = (SXE(KS1,JS) - YE_CNTR) / RMAX

   XN(NV) = 0.;  YE(NV) = 0.;  XN(1) = RMAX;  YE(1) = 0.
   DO JV = 2, NV - 1
     J1 = JV + KS
     IF (J1 > NV) J1 = J1 - NV
     XN(JV) = CTH * (SXN(J1,JS) - XN_CNTR) + STH * (SXE(J1,JS) - YE_CNTR)
     YE(JV) = CTH * (SXE(J1,JS) - YE_CNTR) - STH * (SXN(J1,JS) - XN_CNTR)
   END DO


   RMAX = 0
   DO JV = 2, NV-1
     R = XN(JV) - XN(JV+1)
     IF (R > RMAX) THEN      ! Find segment with longest north to south extent
       RMAX = R
       EMID = (YE(JV) + YE(JV+1)) /2.
     END IF
   END DO

   IF (EMID < 0 ) THEN
     TEMPN(1:NV) = SXN(1:NV,JS)
     TEMPE(1:NV) = SXE(1:NV,JS)
     TEMPZ(1:NV) = SXZ(1:NV,JS)
     DO JV = 1,NV
       SXN(JV,JS) = TEMPN(NV+1-JV)
       SXE(JV,JS) = TEMPE(NV+1-JV)
       SXZ(JV,JS) = TEMPZ(NV+1-JV)
     END DO
   END IF
 END DO

 END SUBROUTINE LP_VERTEX_ORDER

 REAL FUNCTION TXCNVD (MXCNV,T,NTYPLS,TRP,YPLS,NSX,SWX,SWY,K1)
!-------------------------------------------------------------
!
!***  Called by FOLD_AND_CONVOLVE
!***  Calls CUBINT, CUBSPL, CUBVAL, LINVAL, TXCMRG

!  Convolves earth response function (ERF) with the source waveform
!  contained in SWY(*,K1) at NSX points to produce the system response
!  of the earth.  In Marco, it is used for electric field computations.
!  The source current function is contained in component K1 = 3
!
!       MXCNV = NTYPLS + NSX
!           T - convolution time in sec measured from the beginning
!               of the source waveform.
!   TRP, YPLS - abscissa & ordinate values of earth response function to
!               be convolved.
!      NTYPLS - number of values in TRP and YPLS
!         SWX - abscissa of time values of source waveform in sec.
!    SWY(*,K1) - source current values
!         NSX - number of points in SWX & in each waveform stored in SWY
!
!  Defining  T1 = MIN {T, signal length,}, the convolution is formally
!  computed as
!
!   TXCNVD (T) = INT (T0 -> T) { YPLS (tau) * SWY (T-tau)  d tau }

!  where T0 = MAX { TRP(1), T - SWX (NSX)}
!
!       ONTIME RESPONSE
!       ---------------
!  For response in the on-time period, ( T < signal length) a correction to
!  account for the response from 0 -> T0 is needed.  Analysis and subsequent
!  numerical experiments confirm that as T -> 0, step dB/dt -> A * T**(-1/2).
!  Thus ERFINT, the integral of YPLS from 0 to TRP(1), is simply
!  2 * TRP(1) * YPLS (TRP(1)) if TRP(1) is chosen sufficiently early.
!  The convolution correction factor is SWY(T) * ERFINT.

!  Alternatively, we can difference the step B field from 0 to TRP(1) which
!  is a lot easier since the step B field at T = 0 is simply the DC field due
!  to a transmitter image buried at z = ALT; i.e., the z+z' term.  In this case,
!  the bigger TRP(1) is, the more accurate the difference in B but this must be
!  sufficiently small so that the change in dI/dt is negligable.  Thus, TRP(1)
!  is chosen to be .1 microsecond.

 IMPLICIT NONE
 INTEGER K1,MXCNV,NTYPLS,NSX,N1,J1,N2,J2,NCNV
 REAL T,TC,T0,TRP(NTYPLS),YPLS(4,NTYPLS),SWX(NSX),SWY(NSX,3),YCNV(4,MXCNV), &
      XCNV(MXCNV),X1(MXCNV),Y1(MXCNV),X2(MXCNV),Y2(MXCNV),CUBVAL,CUBINT,LINVAL

 INTENT (IN) MXCNV,T,NTYPLS,TRP,YPLS,NSX,SWX,SWY

!  Set up X1,Y1, the N1 values of SWX, SWY * YPLS for signal ontime < T.
!  where X1, the conjugate signal time, contains T-SWX values.
!  Set up X2,Y2, the N2 values of TRP, YPLS * SWY for ERF points  <= T.

!  Return TXCNVD = 0 if N1 + N2 < 4 or if NCNV < 4

 TXCNVD = 0.0
 N1 = 0
 DO J1 = NSX, 1, -1
   TC = T - SWX(J1)
   IF (TC < 0.) CYCLE
   N1 = N1 + 1
   X1(N1) = TC
   Y1(N1) = SWY(J1,K1) * CUBVAL (TRP,YPLS,NTYPLS,TC)
 END DO

 T0 = T - SWX(NSX)
 T0 = MAX (T0, TRP(1))/ 1.0001
 N2 = 0
 DO J2 = 1,NTYPLS
   IF ((TRP(J2) > T0) .AND. (TRP(J2) < T)) THEN
     N2 = N2 + 1
     X2(N2) = TRP(J2)
     TC = T - TRP(J2)
     Y2(N2) = YPLS(1,J2) * LINVAL(NSX,SWX,SWY,K1,TC)
   END IF
 END DO

!  Merge the two lists into XCNV, YCNV of length NCNV.
!  Then spline and integrate

!+++++++++++++++++++++++++++++++++
 IF (N1 + N2 < 4) RETURN
!+++++++++++++++++++++++++++++++++

 CALL TXCMRG (MXCNV,X1,Y1,N1,X2,Y2,N2,XCNV,YCNV,NCNV)

!+++++++++++++++++++++++++++++++++
 IF (NCNV < 4) RETURN
!+++++++++++++++++++++++++++++++++

 CALL CUBSPL (XCNV,YCNV,NCNV,0,0)
 TXCNVD = CUBINT (XCNV,YCNV,NCNV,T0,T)

END FUNCTION TXCNVD

 REAL FUNCTION TXCNVL (T,NTYPLS,TRP,YPLS,NSX,SWX,SWY)
!----------------------------------------------------

!***  Called by FOLD_AND_CONVOLVE
!***  Calls CUBINT, CUBVAL

!  Computes the system dB/dt response by convolving the computed dI/dt with
!  the impulse B response of the earth.  For step current drops, system dB/dt
!  is computed asthe product of instantaneous current drop times the
!  earth step dB/dt.

!  This routine assumes that the source waveform is composed of NSX linear
!  segments.  Thus NSX-1 constant dI/dt values are contained in SWY(*,1).

!  The input earth response function (step dB/dt or equivalently, impulse B)
!  must be contained in a splined array of NTYPLS values of time (abscissa) TRP
!  and ordinate YPLS.  System dB/dt is computed by integrating YPLS between
!  the SWX points of constant dI/dt segments.

!              T - convolution time in sec measured from the beginning
!                  of the source waveform.
!      TRP, YPLS - abscissa & ordinate values of earth response function to
!                  be convolved.
!         NTYPLS - number of values in TRP and YPLS
!            SWX - abscissa of time values of source waveform in sec.
!       SWY(*,1) - dI/dt if it exists (0 otherwise)
!       SWY(*,2) - first difference values of source waveform
!                  (-delta I) in amps.
!            NSX - number of points in SWX & WAVEFORM

 IMPLICIT NONE
 REAL, PARAMETER :: T0_MIN=1.E-7
 INTEGER NTYPLS,NSX,JT
 REAL T,TF,CNV,TB,DELT,SEG,TRP(NTYPLS),YPLS(4,NTYPLS),SWX(NSX),SWY(NSX,3),TEND, &
      CUBINT,CUBVAL
 LOGICAL DER

 TF = T - TRP(1)
 CNV = 0.
 DO JT = 2, NSX
   IF (SWX(JT) < T0_MIN) CYCLE
   IF (SWX(JT-1) > TF) EXIT
   TB = T - MIN (TF, SWX(JT))
   DELT = SWX(JT) - SWX(JT-1)
   DER = .FALSE.
   IF (DELT > T0_MIN) THEN
     TEND = T - SWX(JT-1)
     DER = .TRUE.
   END IF

!  For an instantaneous step drop in current, SEG is YPLS times SWY(*,2),
!  since YPLS is already the dB/dt step response.  Otherwise SEG is the
!  integral of YPLS * constant dI/dt SWY(*,1) since YPLS is also impulse B.

   IF (DER) THEN
     SEG = SWY(JT,1) * CUBINT (TRP,YPLS,NTYPLS,TB,TEND)
   ELSE
     SEG = SWY(JT,2) * CUBVAL (TRP,YPLS,NTYPLS,TB)
   END IF
   CNV = CNV + SEG
 END DO
 TXCNVL = CNV

END FUNCTION TXCNVL

 REAL FUNCTION LINVAL (NX,XVAL,YVAL,K1,X1)
!-----------------------------------------

!  Evaluates a function at X1 from from its linear representation.

!***  Called by TXCNVD
!
!***  Calls INTERV.  On exit from INTERV
!
!       MFLAG = -1  => X is to the left of interpolated range
!             =  1  => X is to the right of interpolated range
!             =  0  => X is in the interpolated range

!
!     XVAL(1:NX) - location of the abscissa knots.  The rightmost data point
!                  used to calculate coefficients is not included.
!
!  YVAL(1:NX,K1) = function values.
!
!
!     The value is a linear interpolation between the knots.
!
!             METHOD
!             ------
!
!  The interval index I, appropriate for X, is found through a call to INTERV.
!  The formula for F is evaluated using nested multiplication.
!******************************************************************************

 IMPLICIT NONE
 INTEGER K1,I,MFLAG,NX
 REAL XVAL(NX),YVAL(NX,3),X1,H

 INTENT (IN) NX,XVAL,YVAL,X1
!
!  Find index I of largest breakpoint to the left of X1.
!
 CALL INTERV ( XVAL, NX-1, X1, I, MFLAG )

 H = X1 - XVAL(I)
 IF (MFLAG == -1) H = 0.
 LINVAL = YVAL(I,K1) + H * (YVAL(I+1,K1) - YVAL(I,K1)) / (XVAL(I+1) - XVAL(I))

END FUNCTION LINVAL


 SUBROUTINE TXCMRG (MXCNV,X1,Y1,N1,X2,Y2,N2,XCNV,YCNV,NCNV)
!----------------------------------------------------------

!  Merges two previously sorted list pairs X1, Y1 of length N1 and X2, Y2 of
!  length N2 into list pair XCNV, YCNV of length NCNV into ascending values of
!  XCNV.

!***  Called by TXCNVD

 IMPLICIT NONE
 REAL, PARAMETER :: TOL=1.E-3
 INTEGER MXCNV,N1,N2,NCNV,K1,K2,N,J1
 REAL DELT,TL1,XCNV(MXCNV),X1(MXCNV),Y1(MXCNV),X2(MXCNV),Y2(MXCNV),YCNV(4,MXCNV)
 LOGICAL LIST1, LIST2

 INTENT (IN) MXCNV,X1,Y1,N1,X2,Y2,N2
 INTENT (OUT) XCNV,YCNV,NCNV

 LIST1 = .TRUE.
 LIST2 = .TRUE.
 K1 = 1
 K2 = 1
 N = N1 + N2

 DO J1 = 1, N
   IF (LIST1 .AND. LIST2) THEN
     IF (X1(K1) < X2(K2)) THEN
       XCNV(J1) = X1(K1)
       YCNV(1,J1) = Y1(K1)
       K1 = K1 + 1
       IF (K1 > N1) LIST1 = .FALSE.
     ELSE
       XCNV(J1) = X2(K2)
       YCNV(1,J1) = Y2(K2)
       K2 = K2 + 1
       IF (K2 > N2) LIST2 = .FALSE.
     END IF
   ELSE IF (LIST1) THEN
     XCNV(J1) = X1(K1)
     YCNV(1,J1) = Y1(K1)
     K1 = K1 + 1
     IF (K1 > N1) LIST1 = .FALSE.
   ELSE IF (LIST2) THEN
     XCNV(J1) = X2(K2)
     YCNV(1,J1) = Y2(K2)
     K2 = K2 + 1
     IF (K2 > N2) LIST2 = .FALSE.
   END IF
 END DO

 NCNV = 1      !  Clean up list
 DO J1 = 2, N
   DELT = XCNV(J1) - XCNV(NCNV)
   TL1 = TOL * XCNV(J1)
   IF (DELT > TL1) THEN
     NCNV = NCNV + 1
     XCNV(NCNV) = XCNV(J1)
     YCNV(1,NCNV) = YCNV(1,J1)
   END IF
 END DO

END SUBROUTINE TXCMRG

 SUBROUTINE WRITE_TD (NW,PRFL,STEP,NCHNL,TMS,SURVEY_TYPE,SOURCE_TYPE,NTXE,SXMNT,NRXG,  &
                      NRGTX,RGTXID,NRX,LRX,MRX,UNITS,RX_TYPE,NCMPG,PRTCMP,RXMNT,RXED,  &
                      RXND,RXZD,MQVR,CLCD,PRTSEC,TITLE,BTD,BTD_SCAT)
!--------------------------------------------------------------------------------------

!  Prints out time domain output
!
!*** Called by: MAIN
!***     Calls: SET_OUTPUT_FACTORS, WRTDP
!
!              NW - output unit number
!            PRFL = 1 for profile output; = 0 for temporal output
!            STEP = 0 for dB/dt output and 1 for B output
!                 = 0 for grounded wire and coincident loop receivers
!             TMS - time midpoints (ms) for NCHNL windows
!     SURVEY_TYPE - indicates seperate Tx-Rx arrays (1), fixed offset (2),
!                   central loop (3), coincident loop (4)
!     SOURCE_TYPE - indicates loop (1), grounded wire (2), magnetic dipole(3) or
!                   plane wave sources (4)
!            NTXE - number of transmitter positions
!        SXMNT(J) - turns * area for magnetic dipole transmitter J
!            NRXG - number of receiver groups
!        NRGTX(J) - number of receiver groups for transmitter J
!     RGTXID(I,J) - receiver group index for Ith group for transmitter J
!          NRX(J) - the number of receivers in receiver group J.  MRX = MAXVAL (NRX)
!             LRX - maximum number of receivers assigned to any transmitter position
!             MRX - maximum number of receivers in any receiver group
!           UNITS - output unit indicator for each receiver group
!         RX_TYPE - receiver type: mag dipole (1); finite loop (2); electric dipole (3)
!      RXMNT(I,J) - receiver moment for receiver I of group J if it is a mag dipole
!     RXED(I,J,K) - "real world" east coordinate of vertex K for receiver I of Rx Group J
!      RXND, RXZD - "real world" north and vertical locations of these vertices.
!            MQVR - Maximum number of vertices for all receiver groups (1, 2 or 4)
!       CLCD(3,J) - North (1), East (2), Vertical (3) coincident loop centre of Tx position J.
!         PRTSECT - print measured response only if FALSE
!                 - plus PERCENT TARGET EFFECT and scattered fields if TRUE
!
!    BTD(I,J,K,L) - the Lth component measured response at channel I from receiver J,
!                   transmitter K, component L
!        BTD_SCAT - the scattered response; ie measured response minus
!                   the layered half-space response.

 IMPLICIT NONE
 INTEGER NW,PRFL,STEP,NCHNL,SURVEY_TYPE,SOURCE_TYPE,NTXE,NRXG,NRGTX(NTXE),RGTXID(NRXG,NTXE), &
         RX_TYPE(NRXG),NCMPG(NRXG),PRTCMP(10,NRXG),UNITS(NRXG),NRX(NRXG),LRX,MRX,MQVR,KRG,   &
         KRGT,NRCNR,NRX1,JR,JRP,NLOC,JC,JC1,JRG,JS,JT,KRFIN,PRTYP,KC
 REAL TMS(NCHNL),OUTFAC(MRX,NRXG),RXMNT(MRX,NRXG),FAC,SXMNT(NTXE)
 REAL, ALLOCATABLE, DIMENSION(:,:) :: YTR, YTR_SCAT, YTR_PTR
 REAL, DIMENSION(NCHNL,LRX,NTXE,3) :: BTD, BTD_SCAT
 REAL(KIND=8), DIMENSION (MRX,NRXG,MQVR) :: RXED,RXND,RXZD
 REAL(KIND=8) CLCD(3,NTXE)
 REAL(KIND=8), ALLOCATABLE :: RXPLT(:,:)
 LOGICAL PRTSEC
 CHARACTER(LEN=120) TITLE
 CHARACTER(LEN=16) OUTTXT(NRXG),SXTXT(3)
 CHARACTER(LEN=17) RXTXT(3)
 CHARACTER (LEN = 06) AMR_UNITS(NRXG)

 DATA SXTXT /'loop.           ','grounded wire.  ','magnetic dipole.'/
 DATA RXTXT /'magnetic dipoles.','loops.           ','grounded wires.  '/

 WRITE(NW,'(/T3,A)') TITLE
 CALL SET_OUTPUT_FACTORS (NRXG,MRX,SURVEY_TYPE,RX_TYPE,RXMNT,STEP,UNITS, &
                          OUTTXT,OUTFAC,AMR_UNITS)

 IF (SURVEY_TYPE == 1) THEN
   NLOC = MRX
   ALLOCATE (RXPLT(3,NLOC),YTR(NCHNL,NLOC),YTR_SCAT(NCHNL,NLOC),YTR_PTR(NCHNL,NLOC))
   DO JS = 1, NTXE
     KRFIN = 0
     DO JRG = 1, NRGTX(JS)
       KRG = RGTXID(JRG,JS)  ! Receiver Group index for group JRG for Tx JS
       KRGT = RX_TYPE(KRG)
       WRITE(NW,1) JS, KRG, SXTXT(SOURCE_TYPE), RXTXT(KRGT),OUTTXT(KRG)

       NRX1 = NRX(KRG)      ! Number of receivers in receiver group KRG
       NRCNR = 1            ! set receiver midpoints
       IF (RX_TYPE(KRG) == 2) NRCNR = 4
       IF (RX_TYPE(KRG) == 3) NRCNR = 2
       DO JR = 1,NRX1
         RXPLT(1,JR) = SUM (RXND(JR,KRG,1:NRCNR) ) / REAL (NRCNR,8)
         RXPLT(2,JR) = SUM (RXED(JR,KRG,1:NRCNR) ) / REAL (NRCNR,8)
         RXPLT(3,JR) = SUM (RXZD(JR,KRG,1:NRCNR) ) / REAL (NRCNR,8)
       END DO
       DO JC = 1, NCMPG(KRG)
         IF (KRGT > 1) THEN         ! Loop or wire receiver (single component)
           JC1 = 7                  ! No label on output component
           KC = 1                   ! Output is in first component position
         ELSE
           JC1 = PRTCMP(JC,KRG)     !  Sum is now over specified components
           KC = JC1
           IF (JC1 > 3 ) KC = JC1-3 !  Assign borehole component
         END IF

         YTR = 0; YTR_SCAT = 0; YTR_PTR = 0;
         DO JR = 1,NRX1
           FAC = SXMNT(JS) * OUTFAC(JR,KRG)
           JRP = JR + KRFIN

           YTR(1:NCHNL,JR) = FAC * BTD(1:NCHNL,JRP,JS,KC)
           IF (PRTSEC) THEN
             YTR_SCAT(1:NCHNL,JR) = FAC * BTD_SCAT(1:NCHNL,JRP,JS,KC)
             DO JT = 1,NCHNL
               IF (ABS (YTR(JT,JR)) > 1.E-20)  &
                 YTR_PTR(JT,JR) = 100. * YTR_SCAT(JT,JR) / YTR(JT,JR)
             END DO
           END IF
         END DO
         PRTYP = 1
         CALL WRTDP (NW,PRFL,PRTYP,NCHNL,TMS,NLOC,NRX1,JC1,RXPLT,YTR)
         IF (PRTSEC) THEN
           PRTYP = 2
           CALL WRTDP (NW,PRFL,PRTYP,NCHNL,TMS,NLOC,NRX1,JC1,RXPLT,YTR_SCAT)
           PRTYP = 3
           CALL WRTDP (NW,PRFL,PRTYP,NCHNL,TMS,NLOC,NRX1,JC1,RXPLT,YTR_PTR)
         END IF
       END DO
       KRFIN = KRFIN + NRX1  ! Set index for next group
     END DO                 ! End of Rx groups for transmitter JS
   END DO

 ELSE
   NLOC = NTXE
   ALLOCATE (RXPLT(3,NLOC),YTR(NCHNL,NLOC),YTR_SCAT(NCHNL,NLOC),YTR_PTR(NCHNL,NLOC))
   IF (SURVEY_TYPE == 2) WRITE(NW,2) SXTXT(SOURCE_TYPE), OUTTXT(1)
   IF (SURVEY_TYPE == 3) WRITE(NW,3) OUTTXT(1)
   IF (SURVEY_TYPE == 4) WRITE(NW,4) OUTTXT(1)

   DO JS = 1,NTXE
     IF (SURVEY_TYPE == 2 .OR. SURVEY_TYPE == 3) THEN
       RXPLT(1,JS) = RXND(1,JS,1)
       RXPLT(2,JS) = RXED(1,JS,1)
       RXPLT(3,JS) = RXZD(1,JS,1)
     ELSE IF (SURVEY_TYPE == 4) THEN
       RXPLT(1:3,JS) = CLCD(1:3,JS)
     END IF
   END DO

   DO JC = 1, NCMPG(1)
     IF (RX_TYPE(1) > 1 .OR. SURVEY_TYPE == 4) THEN
       JC1 = 7
       KC = 1
     ELSE
       JC1 = PRTCMP(JC,1)         !  Sum is now over specified components
       KC = JC1
       IF (JC1 > 3 ) KC = JC1-3    !  Assign borehole component
     END IF
     DO JS = 1,NTXE
       FAC = OUTFAC(1,JS) * SXMNT(JS)
       YTR(1:NCHNL,JS) = FAC * BTD(1:NCHNL,1,JS,KC)
       IF (PRTSEC) THEN
         YTR_SCAT(1:NCHNL,JS) = FAC * BTD_SCAT(1:NCHNL,1,JS,KC)
         DO JT = 1,NCHNL
           IF (ABS (YTR(JT,JS)) > 1.E-20)  &
             YTR_PTR(JT,JS) = 100. * YTR_SCAT(JT,JS) / YTR(JT,JS)
         END DO
       END IF
     END DO
     PRTYP = 1
     CALL WRTDP (NW,PRFL,PRTYP,NCHNL,TMS,NLOC,NTXE,JC1,RXPLT,YTR)
     IF (PRTSEC) THEN
       PRTYP = 2
       CALL WRTDP (NW,PRFL,PRTYP,NCHNL,TMS,NLOC,NTXE,JC1,RXPLT,YTR_SCAT)
       PRTYP = 3
       CALL WRTDP (NW,PRFL,PRTYP,NCHNL,TMS,NLOC,NTXE,JC1,RXPLT,YTR_PTR)
     END IF
   END DO

 END IF

 1 FORMAT(//T3,'Time-domain output for Transmitter Position',I3,' & Receiver Group',I3 &
           /T3,'------------------------------------------------------------------'   &
           /T3,'The source is a ',A                                                  &
           /T3,'The receivers in this group are ',A                                  &
           /T3,'For each receiver position, the output is printed in ',A/)
 2 FORMAT(//T3,'Time-domain output for a single magnetic dipole receiver moving with' &
           /T3,'constant offset with respect to the transmitter.'                    &
           /T3,'The source is a ',A                                                  &
           /T3,'For each receiver position, the output is printed in ',A/)
 3 FORMAT(//T3,'Time-domain output for a central loop survey.' &
           /T3,'For each loop centre position, the output is printed in ',A/)
 4 FORMAT(//T3,'Time-domain output for a coincident loop survey.' &
           /T3,'For each loop centre position, the output is printed in ',A/)

 END SUBROUTINE WRITE_TD

 SUBROUTINE WRTDP (NW,PRFL,PRTYP,NCHNL,TMS,NLOC,NRX1,JC,RXPLT,YTR)
!-----------------------------------------------------------------

!***  Called by: WRITE_TD
!***      CallS: nil

!  Writes time-domain output in profile form.

 IMPLICIT NONE
 INTEGER NW,PRFL,PRTYP,NCHNL,NLOC,NRX1,JC,JR,NBLKS,J1,JB,JF,NCOL
 REAL TMS(NCHNL),YTR(NCHNL,NLOC)
 REAL(KIND=8) RXPLT(3,NLOC)

 CHARACTER(LEN=8) CHN(150)
 CHARACTER(LEN=23) DIRECTION(6)
 CHARACTER(LEN=50) RESPONSE(3)
 DATA DIRECTION /'NORTH COMPONENT        ','EAST COMPONENT         ','VERTICAL COMPONENT     ', &
                 'BH HORIZONTAL COMPONENT','BH SLOPE COMPONENT     ','BH AXIAL COMPONENT     '/
 DATA RESPONSE /'STANDARD OUTPUT - LAYERED EARTH + SCATTERED FIELDS', &
                'SCATTERED FIELD - INDUCED PLUS CURRENT GATHERING  ', &
                'PERCENT TARGET EFFECT                             '/
 DATA CHN(1:150) &
   /' CHNL 1 ',' CHNL 2 ',' CHNL 3 ',' CHNL 4 ',' CHNL 5 ',' CHNL 6 ', &
    ' CHNL 7 ',' CHNL 8 ',' CHNL 9 ','CHNL 10 ','CHNL 11 ','CHNL 12 ', &
    'CHNL 13 ','CHNL 14 ','CHNL 15 ','CHNL 16 ','CHNL 17 ','CHNL 18 ', &
    'CHNL 19 ','CHNL 20 ','CHNL 21 ','CHNL 22 ','CHNL 23 ','CHNL 24 ', &
    'CHNL 25 ','CHNL 26 ','CHNL 27 ','CHNL 28 ','CHNL 29 ','CHNL 30 ', &
    'CHNL 31 ','CHNL 32 ','CHNL 33 ','CHNL 34 ','CHNL 35 ','CHNL 36 ', &
    'CHNL 37 ','CHNL 38 ','CHNL 39 ','CHNL 40 ','CHNL 41 ','CHNL 42 ', &
    'CHNL 43 ','CHNL 44 ','CHNL 45 ','CHNL 46 ','CHNL 47 ','CHNL 48 ', &
    'CHNL 49 ','CHNL 50 ','CHNL 51 ','CHNL 52 ','CHNL 53 ','CHNL 54 ', &
    'CHNL 55 ','CHNL 56 ','CHNL 57 ','CHNL 58 ','CHNL 59 ','CHNL 60 ', &
    'CHNL 61 ','CHNL 62 ','CHNL 63 ','CHNL 64 ','CHNL 65 ','CHNL 66 ', &
    'CHNL 67 ','CHNL 68 ','CHNL 69 ','CHNL 70 ','CHNL 71 ','CHNL 72 ', &
    'CHNL 73 ','CHNL 74 ','CHNL 75 ','CHNL 76 ','CHNL 77 ','CHNL 78 ', &
    'CHNL 79 ','CHNL 80 ','CHNL 81 ','CHNL 82 ','CHNL 83 ','CHNL 84 ', &
    'CHNL 85 ','CHNL 86 ','CHNL 87 ','CHNL 88 ','CHNL 89 ','CHNL 90 ', &
    'CHNL 91 ','CHNL 92 ','CHNL 93 ','CHNL 94 ','CHNL 95 ','CHNL 96 ', &
    'CHNL 97 ','CHNL 98 ','CHNL 99 ','CHNL 100','CHNL 101','CHNL 102', &
    'CHNL 103','CHNL 104','CHNL 105','CHNL 106','CHNL 107','CHNL 108', &
    'CHNL 109','CHNL 110','CHNL 111','CHNL 112','CHNL 113','CHNL 114', &
    'CHNL 115','CHNL 116','CHNL 117','CHNL 118','CHNL 119','CHNL 120', &
    'CHNL 121','CHNL 122','CHNL 123','CHNL 124','CHNL 125','CHNL 126', &
    'CHNL 127','CHNL 128','CHNL 129','CHNL 130','CHNL 131','CHNL 132', &
    'CHNL 133','CHNL 134','CHNL 135','CHNL 136','CHNL 137','CHNL 138', &
    'CHNL 139','CHNL 140','CHNL 141','CHNL 142','CHNL 143','CHNL 144', &
    'CHNL 145','CHNL 146','CHNL 147','CHNL 148','CHNL 149','CHNL 150'/

 IF (PRFL == 0) THEN  ! Forget profiles, write output in temporal form.
   CALL WRTDT (NW,PRTYP,NCHNL,TMS,NLOC,NRX1,JC,RXPLT,YTR)
   RETURN
 END IF

 IF (JC < 7) THEN
   WRITE(NW,'(/T7,2A)') 'PROFILE OUTPUT:  ',DIRECTION(JC)
 ELSE
   WRITE(NW,'(/T7,2A)') 'PROFILE OUTPUT:  '
 END IF
 WRITE(NW,'(T7,A)') RESPONSE(PRTYP)

 NCOL = MIN (NCHNL, 35)
 NBLKS = 1
 IF (NCHNL > 35) THEN
   NBLKS = NCHNL / NCOL
   IF (MOD (NCHNL,NCOL) > 0) NBLKS = NBLKS + 1
 END IF

 DO J1 = 1,NBLKS
   JB = 1 + (J1-1) * NCOL
   JF = JB + NCOL - 1
   JF = MIN (JF,NCHNL)

   WRITE(NW,1) CHN(JB:JF)
   WRITE(NW,2) TMS(JB:JF)
   WRITE(NW,'(3X)')
   DO JR = 1, NRX1
     WRITE(NW,3) JR,RXPLT(1:3,JR),YTR(JB:JF,JR)
   END DO
 END DO

 1 FORMAT(/T11,'RECEIVER POSITIONS',6X,35(:5X,A))
 2 FORMAT(T8,'Northing     Easting     Elev',T37,35G13.4)
 3 FORMAT(I3,2F12.2,F9.2,35G13.4)

END SUBROUTINE WRTDP

 SUBROUTINE WRTDT (NW,PRTYP,NCHNL,TMS,NLOC,NRX1,JC,RXPLT,YTR)
!------------------------------------------------------------

!***  Called by WRITE_TD
!***  Calls WRSLVP

!  Writes time-domain output in temporal form.

 IMPLICIT NONE
 INTEGER NW,PRTYP,NCHNL,NLOC,NRX1,JC,JT,NBLKS,J1,JB,JF,NCOL
 REAL TMS(NCHNL),YTR(NCHNL,NLOC)
 REAL(KIND=8) RXPLT(3,NLOC)
 CHARACTER(LEN=23) DIRECTION(6)
 CHARACTER(LEN=50) RESPONSE(3)
 DATA DIRECTION /'NORTH COMPONENT        ','EAST COMPONENT         ','VERTICAL COMPONENT     ', &
                 'BH HORIZONTAL COMPONENT','BH SLOPE COMPONENT     ','BH AXIAL COMPONENT     '/
 DATA RESPONSE /'STANDARD OUTPUT - LAYERED EARTH + SCATTERED FIELDS', &
                'SCATTERED FIELD - INDUCED PLUS CURRENT GATHERING  ', &
                'PERCENT TARGET EFFECT                             '/

 IF (JC < 7) THEN
   WRITE(NW,'(/T7,2A)') 'TEMPORAL OUTPUT:  ',DIRECTION(JC)
 ELSE
   WRITE(NW,'(/T7,2A)') 'TEMPORAL OUTPUT:  '
 END IF

 WRITE(NW,'(T7,A)') RESPONSE(PRTYP)
 WRITE(NW,4)

 NCOL = MIN (NRX1, 35)
 NBLKS = 1
 IF (NRX1 > 35) THEN
   NBLKS = NRX1 / NCOL
   IF (MOD (NRX1,NCOL) > 0) NBLKS = NBLKS + 1
 END IF

 DO J1 = 1,NBLKS
   JB = 1 + (J1-1) * NCOL
   JF = JB + NCOL - 1
   JF = MIN (JF,NRX1)
   WRITE(NW,1) RXPLT(1,JB:JF)
   WRITE(NW,2) RXPLT(2,JB:JF)
   WRITE(NW,3) RXPLT(3,JB:JF)
   WRITE(NW,'(3X)')

   DO JT = 1,NCHNL
     WRITE(NW,'(I4,F10.3,T18,35G13.4)') JT,TMS(JT),YTR(JT,JB:JF)
   END DO
 END DO

 1 FORMAT(/T2,'       Window',T16,35F13.2)
 2 FORMAT( T2,'      Centres',T16,35F13.2)
 3 FORMAT( T2,'Chnl   (ms)  ',T16,35F13.2)
 4 FORMAT(/T20,'RECEIVER COORDINATES (Top to Bottom): Northing, Easting, Elevation')

END SUBROUTINE WRTDT

 SUBROUTINE WRITE_FD_PPM (NW,NFRQ,FREQ,NTXE,CMPDX,RXED,RXND,RXZD,TITLE,BFD,CURNT,DXPRM)
!--------------------------------------------------------------------------------------

!  Prints out frequency-domain output in PPM for magnetic dipole-dipole surveys
!
!              NW - output unit number
!            FREQ - frequencies for NFRQ responses
!            NTXE - number of transmitter-receiver positions
!           CMPDX - number of components: 1 or 3
!     RXED(I,J,K) - "real world" east coordinate of vertex K for receiver I of Rx Group J
!    BFD(I,1,K,L) - the Lth component measured response at frequency I from receiver J,
!        CURNT(I) - transmitter current at frequency I
!      DXPRM(I,1) - Ith component of the DC field
!      DXPRM(I,2) - DC field used to normalise Ith component.
!             I,J = 1,3 implies the slopw, horizontal & axial components respectively.

 IMPLICIT NONE
 INTEGER NW,NFRQ,NTXE,CMPDX,JC,KC,JS,JRI
 REAL FREQ(NFRQ),CURNT(NFRQ),RXPLT(3,NTXE),YTR(NFRQ),DXPRM(3,3)
 REAL(KIND=8), DIMENSION (1,NTXE,1) :: RXED,RXND,RXZD
 COMPLEX, DIMENSION(NFRQ,1,NTXE,3) :: BFD
 COMPLEX BFD1(NFRQ)
 CHARACTER(LEN=120) TITLE
 CHARACTER(LEN=29) DIRECTION(3)
 DATA DIRECTION /'HORIZONTAL BOREHOLE COMPONENT', &
                 'SLOPE BOREHOLE COMPONENT     ', &
                 'AXIAL BOREHOLE COMPONENT     '/

 WRITE(NW,'(//T3,A,A)') 'TITLE:  ',TITLE

 DO JS = 1,NTXE
   RXPLT(1,JS) = REAL (RXND(1,JS,1))
   RXPLT(2,JS) = REAL (RXED(1,JS,1))
   RXPLT(3,JS) = REAL (RXZD(1,JS,1))
 END DO
 DO JC = 1, CMPDX
   KC = 4-JC

   DO JRI = 1,2
     YTR = 0
     IF (JRI == 1) WRITE(NW,'(//T3,A,5X,A/T3,A)') 'INPHASE RESPONSE in PPM',DIRECTION(KC), &
                                                  '-----------------------'
     IF (JRI == 2) WRITE(NW,'(//T3,A,5X,A/T3,A)') 'QUADRATURE RESPONSE in PPM',DIRECTION(KC), &
                                                  '--------------------------'
     WRITE(NW,2)
     WRITE(NW,3) FREQ(1:NFRQ)
     WRITE(NW,'(3X)')
     DO JS = 1,NTXE
       BFD1(1:NFRQ) = BFD(1:NFRQ,1,JS,KC) / CURNT(1:NFRQ)
       IF (JRI == 1) THEN
         YTR(1:NFRQ) = 1.E6 *  REAL (BFD1(1:NFRQ)) / DXPRM(KC,2)
       ELSE
         YTR(1:NFRQ) = 1.E6 * AIMAG (BFD1(1:NFRQ)) / DXPRM(KC,2)
       END IF
       WRITE(NW,4) JS,RXPLT(1:3,JS),YTR(1:NFRQ)
     END DO
   END DO
 END DO
 WRITE(NW,1)

 1 FORMAT(//T3,'END OF PPM OUTPUT'/T3,'=================' )
 2 FORMAT(/T11,'RECEIVER POSITIONS',T40,'FREQUENCIES')
 3 FORMAT(T5,'Northing     Easting     Elev',T37,35G13.4)
 4 FORMAT(I3,2F12.2,F9.2,35F13.2)

 END SUBROUTINE WRITE_FD_PPM

 SUBROUTINE WRITE_FD (NW,PRFL,STEP,NFRQ,FREQ,SURVEY_TYPE,SOURCE_TYPE,NTXE,SXMNT,NRXG, &
                      NRGTX,RGTXID,LRX,MRX,NRX,UNITS,RX_TYPE,NCMPG,PRTCMP,RXMNT,RXED,  &
                      RXND,RXZD,MQVR,PRTSEC,TITLE,BFD,BFD_SCAT)
!------------------------------------------------------------------------------------

!  Prints out time domain output
!
!              NW - output unit number
!            PRFL = 1 for profile output; = 0 for spectral output
!            STEP = 0 for dB/dt output and 1 for B output
!                   (ignored for grounded wire receivers
!            FREQ - frequencies for NFRQ responses
!     SURVEY_TYPE - indicates seperate Tx-Rx arrays (1), fixed offset (2),
!                   central loop (3)
!     SOURCE_TYPE - indicates loop (1), grounded wire (2), magnetic dipole(3) or
!                   plane wave sources (4)
!            NTXE - number of transmitter positions
!        SXMNT(J) - turns * area for magnetic dipole transmitter J
!            NRXG - number of receiver groups
!        NRGTX(J) - number of receiver groups for transmitter J
!     RGTXID(I,J) - receiver group index for Ith group for transmitter J
!          NRX(J) - the number of receivers in receiver group J.  MRX = MAXVAL (NRX)
!             LRX - maximum number of receivers assigned to any transmitter position
!             MRX - maximum number of receivers in any receiver group
!           UNITS - output unit indicator for each receiver group
!         RX_TYPE - receiver type: mag dipole (1); finite loop (2); electric dipole (3)
!             CMP = 0 or 2 => compute 3 components, = 1 => compute 1 component,
!      RXMNT(I,J) - receiver moment for receiver I of group J if it is a mag dipole
!     RXED(I,J,K) - "real world" east coordinate of vertex K for receiver I of Rx Group J
!      RXND, RXZD - "real world" north and vertical locations of these vertices.
!            MQVR - Maximum number of vertices for all receiver groups (1, 2 or 4)
!         PRTSECT - print measured response only if FALSE
!                 - plus PERCENT TARGET EFFECT and scattered fields if TRUE
!
!    BFD(I,J,K,L) - the Lth component measured response at channel I from receiver J,
!                   transmitter K
!        BFD_SCAT - the scattered response; ie measured response minus
!                   the layered half-space response.


!    NOTE:  BFD & BFD_SCAT are: B if RX_TYPE = 1  (magnetic dipole)
!                                  Multiply by iw for voltage (STEP = 0)

!                               B integrated over area if RX_TYPE = 2  (loops and coincident loop)
!                                  Multiply by iw

!                               voltage if RX_TYPE = 3  (integrated electric field along grounded wire)


 IMPLICIT NONE
 COMPLEX, PARAMETER :: I2PI= (0.,6.283185)  ! 2 * pi * i
 INTEGER NW,PRFL,STEP,NFRQ,SURVEY_TYPE,SOURCE_TYPE,NTXE,NRXG,NRGTX(NTXE),RGTXID(NRXG,NTXE), &
         RX_TYPE(NRXG),NCMPG(NRXG),PRTCMP(10,NRXG),UNITS(NRXG),NRX(NRXG),LRX,MRX,JRI,KC,    &
         MQVR,KRG,KRGT,NRCNR,NRX1,JR,JRP,NLOC,JC,JC1,JRG,JS,JF,KRFIN,PRTYP
 REAL FREQ(NFRQ),OUTFAC(MRX,NRXG),RXMNT(MRX,NRXG),FAC,SXMNT(NTXE)
 REAL, ALLOCATABLE, DIMENSION(:,:) :: YTR, YTR_SCAT, YTR_PTR
 REAL(KIND=8), DIMENSION (MRX,NRXG,MQVR) :: RXED,RXND,RXZD
 REAL(KIND=8), ALLOCATABLE :: RXPLT(:,:)
 COMPLEX, DIMENSION(NFRQ,LRX,NTXE,3) :: BFD, BFD_SCAT
 LOGICAL CONVERT, PRTSEC
 CHARACTER(LEN=120) TITLE
 CHARACTER(LEN=16) OUTTXT(NRXG),SXTXT(3)
 CHARACTER(LEN=17) RXTXT(3)
 CHARACTER (LEN = 06) :: AMR_UNITS(NRXG)

 DATA SXTXT /'loop.           ','grounded wire.  ','magnetic dipole.'/
 DATA RXTXT /'magnetic dipoles.','loops.           ','grounded wires.  '/

 WRITE(NW,'(/T3,A)') TITLE
 CALL SET_OUTPUT_FACTORS (NRXG,MRX,SURVEY_TYPE,RX_TYPE,RXMNT,STEP,UNITS,OUTTXT,OUTFAC, &
     AMR_UNITS)

 IF (SURVEY_TYPE == 1) THEN
   NLOC = MRX
   ALLOCATE (RXPLT(3,NLOC),YTR(NFRQ,NLOC),YTR_SCAT(NFRQ,NLOC),YTR_PTR(NFRQ,NLOC))
   DO JS = 1, NTXE
     KRFIN = 0
     DO JRG = 1, NRGTX(JS)
       KRG = RGTXID(JRG,JS)  ! Receiver Group index for group JRG for Tx JS
       KRGT = RX_TYPE(KRG)   ! Identify RX_TYPE of group KRG
       WRITE(NW,1) JS, KRG, SXTXT(SOURCE_TYPE), RXTXT(KRGT),OUTTXT(KRG)

       NRX1 = NRX(KRG)      ! Number of receivers in receiver group KRG
       NRCNR = 1            ! set receiver midpoints
       IF (KRGT == 2) NRCNR = 4
       IF (KRGT == 3) NRCNR = 2

!  Set up plot points and multiply by iw to convert to voltage if necessary

       DO JR = 1,NRX1
         RXPLT(1,JR) = SUM (RXND(JR,KRG,1:NRCNR) ) / REAL (NRCNR,8)
         RXPLT(2,JR) = SUM (RXED(JR,KRG,1:NRCNR) ) / REAL (NRCNR,8)
         RXPLT(3,JR) = SUM (RXZD(JR,KRG,1:NRCNR) ) / REAL (NRCNR,8)

         CONVERT = .FALSE.
         IF (KRGT == 2) CONVERT = .TRUE.                  ! Loop voltage
         IF (KRGT == 1 .AND. STEP == 0) CONVERT = .TRUE.  ! db/dt for magnetic dipole
         IF (CONVERT) THEN   !  multiply by iw
           JRP = JR + KRFIN
           DO JF = 1,NFRQ
             BFD(JF,JRP,JS,1:3) = FREQ(JF) * I2PI * BFD(JF,JRP,JS,1:3)
             IF (PRTSEC) BFD_SCAT(JF,JRP,JS,1:3) = FREQ(JF) * I2PI * BFD_SCAT(JF,JRP,JS,1:3)
           END DO
         END IF

       END DO
       DO JC = 1, NCMPG(KRG)
         IF (RX_TYPE(KRG) > 1) THEN
           JC1 = 7
           KC = 1
         ELSE
           JC1 = PRTCMP(JC,KRG)     !  Sum is now over specified components
           KC = JC1
           IF (JC1 > 3 ) KC = JC1-3 !  Assign borehole component
         END IF

         DO JRI = 1,2
           YTR = 0; YTR_SCAT = 0; YTR_PTR = 0;
           IF (JRI == 1) THEN
             WRITE(NW,'(//T3,A/T3,A)') 'INPHASE RESPONSE','----------------'
             DO JR = 1,NRX1
               FAC = SXMNT(JS) * OUTFAC(JR,KRG)
               JRP = JR + KRFIN
               YTR(1:NFRQ,JR) = FAC * REAL (BFD(1:NFRQ,JRP,JS,KC))
               IF (PRTSEC) YTR_SCAT(1:NFRQ,JR) = FAC * REAL (BFD_SCAT(1:NFRQ,JRP,JS,KC))
             END DO
           ELSE
             WRITE(NW,'(//T3,A/T3,A)') 'QUADRATURE RESPONSE','-------------------'
             DO JR = 1,NRX1
               FAC = SXMNT(JS) * OUTFAC(JR,KRG)
               JRP = JR + KRFIN
               YTR(1:NFRQ,JR) = FAC * AIMAG (BFD(1:NFRQ,JRP,JS,KC))
               IF (PRTSEC) YTR_SCAT(1:NFRQ,JR) = FAC * AIMAG (BFD_SCAT(1:NFRQ,JRP,JS,KC))
             END DO
           END IF
           DO JR = 1,NRX1
             JRP = JR + KRFIN
             IF (PRTSEC) THEN
               DO JF = 1,NFRQ
                 IF (ABS (YTR(JF,JR)) > 1.E-20)  &
                   YTR_PTR(JF,JR) = 100. * YTR_SCAT(JF,JR) / YTR(JF,JR)
               END DO
             END IF
           END DO
           PRTYP = 1
           CALL WRFDP (NW,PRFL,PRTYP,NFRQ,FREQ,NLOC,NRX1,JC1,RXPLT,YTR)
           IF (PRTSEC) THEN
             PRTYP = 2
             CALL WRFDP (NW,PRFL,PRTYP,NFRQ,FREQ,NLOC,NRX1,JC1,RXPLT,YTR_SCAT)
             PRTYP = 3
             CALL WRFDP (NW,PRFL,PRTYP,NFRQ,FREQ,NLOC,NRX1,JC1,RXPLT,YTR_PTR)
           END IF
         END DO
       END DO
       KRFIN = KRFIN + NRX1  ! Set index for next group
     END DO                 ! End of Rx groups for transmitter JS
   END DO

 ELSE
   NLOC = NTXE
   ALLOCATE (RXPLT(3,NLOC),YTR(NFRQ,NLOC),YTR_SCAT(NFRQ,NLOC),YTR_PTR(NFRQ,NLOC))
   IF (SURVEY_TYPE == 2) WRITE(NW,2) SXTXT(SOURCE_TYPE), OUTTXT(1)
   IF (SURVEY_TYPE == 3) WRITE(NW,3) OUTTXT(1)

   DO JS = 1,NTXE
     RXPLT(1,JS) = RXND(1,JS,1)
     RXPLT(2,JS) = RXED(1,JS,1)
     RXPLT(3,JS) = RXZD(1,JS,1)
     IF (STEP == 0) THEN
       DO JF = 1,NFRQ
         BFD(JF,1,JS,1:3) = FREQ(JF) * I2PI * BFD(JF,1,JS,1:3)
         IF (PRTSEC) BFD_SCAT(JF,1,JS,1:3) = FREQ(JF) * I2PI * BFD_SCAT(JF,1,JS,1:3)
       END DO
     END IF
   END DO
   DO JC = 1, NCMPG(1)
     IF (RX_TYPE(1) > 1 .OR. SURVEY_TYPE == 4) THEN
       JC1 = 7
       KC = 1
     ELSE
       JC1 = PRTCMP(JC,1)        !  Sum is now over specified components
       KC = JC1
       IF (JC1 > 3 ) KC = JC1-3  !  Assign borehole component
     END IF

     DO JRI = 1,2
       YTR = 0; YTR_SCAT = 0; YTR_PTR = 0;
       IF (JRI == 1) WRITE(NW,'(//T3,A/T3,A)') 'INPHASE RESPONSE','----------------'
       IF (JRI == 2) WRITE(NW,'(//T3,A/T3,A)') 'QUADRATURE RESPONSE','-------------------'
       DO JS = 1,NTXE
         FAC = OUTFAC(1,JS) * SXMNT(JS)
         IF (JRI == 1) THEN
           YTR(1:NFRQ,JS) = FAC * REAL (BFD(1:NFRQ,1,JS,KC))
           IF (PRTSEC) YTR_SCAT(1:NFRQ,JS) = FAC * REAL (BFD_SCAT(1:NFRQ,1,JS,KC))
         ELSE
           YTR(1:NFRQ,JS) = FAC * AIMAG (BFD(1:NFRQ,1,JS,KC))
           IF (PRTSEC) YTR_SCAT(1:NFRQ,JS) = FAC * AIMAG (BFD_SCAT(1:NFRQ,1,JS,KC))
         END IF
         IF (PRTSEC) THEN
           DO JF = 1,NFRQ
             IF (ABS (YTR(JF,JS)) > 1.E-20)  &
               YTR_PTR(JF,JS) = 100. * YTR_SCAT(JF,JS) / YTR(JF,JS)
           END DO
         END IF
       END DO

       PRTYP = 1
       CALL WRFDP (NW,PRFL,PRTYP,NFRQ,FREQ,NLOC,NTXE,JC1,RXPLT,YTR)
       IF (PRTSEC) THEN
         PRTYP = 2
         CALL WRFDP (NW,PRFL,PRTYP,NFRQ,FREQ,NLOC,NTXE,JC1,RXPLT,YTR_SCAT)
         PRTYP = 3
         CALL WRFDP (NW,PRFL,PRTYP,NFRQ,FREQ,NLOC,NTXE,JC1,RXPLT,YTR_PTR)
       END IF
     END DO
   END DO

 END IF

 1 FORMAT(//T3,'Frequency-domain output for Transmitter Position',I3,' & Receiver Group',I3 &
           /T3,'-----------------------------------------------------------------------'   &
           /T3,'The source is a ',A                             &
           /T3,'The receivers in this group are ',A             &
           /T3,'For each position, the output is printed in ',A)
 2 FORMAT(//T3,'Frequency-domain output for a single magnetic dipole receiver moving with' &
           /T3,'constant offset with respect to the transmitter.'                    &
           /T3,'The source is a ',A                                                  &
           /T3,'For each position, the output is printed in ',A)
 3 FORMAT(//T3,'Frequency-domain output for a central loop survey.' &
           /T3,'For each position, the output is printed in ',A)

 END SUBROUTINE WRITE_FD

 SUBROUTINE WRFDP (NW,PRFL,PRTYP,NFRQ,FREQ,NLOC,NRX1,JC,RXPLT,YTR)
!------------------------------------------------------------------

!***  Called by WRSLV

!  Writes time-domain output in profile form.

 IMPLICIT NONE
 INTEGER NW,PRFL,PRTYP,NFRQ,NLOC,NRX1,JC,JR,NBLKS,J1,JB,JF,NCOL
 REAL FREQ(NFRQ),YTR(NFRQ,NLOC)
 REAL(KIND=8) RXPLT(3,NLOC)

 CHARACTER(LEN=23) DIRECTION(6)
 CHARACTER(LEN=50) RESPONSE(3)
 DATA DIRECTION /'NORTH COMPONENT        ','EAST COMPONENT         ','VERTICAL COMPONENT     ', &
                 'BH HORIZONTAL COMPONENT','BH SLOPE COMPONENT     ','BH AXIAL COMPONENT     '/
 DATA RESPONSE /'STANDARD OUTPUT - LAYERED EARTH + SCATTERED FIELDS', &
                'SCATTERED FIELD - INDUCED PLUS CURRENT GATHERING  ', &
                'PERCENT TARGET EFFECT                             '/

 IF (PRFL == 0) THEN  ! Forget profiles, write output in spectral form.
   CALL WRFDS (NW,PRTYP,NFRQ,FREQ,NLOC,NRX1,JC,RXPLT,YTR)
   RETURN
 END IF

 IF (JC < 7) THEN
   WRITE(NW,'(/T7,2A)') 'PROFILE OUTPUT:  ',DIRECTION(JC)
 ELSE
   WRITE(NW,'(/T7,2A)') 'PROFILE OUTPUT:  '
 END IF
 WRITE(NW,'(T7,A)') RESPONSE(PRTYP)

 NCOL = MIN (NFRQ, 35)
 NBLKS = 1
 IF (NFRQ > 35) THEN
   NBLKS = NFRQ / NCOL
   IF (MOD (NFRQ,NCOL) > 0) NBLKS = NBLKS + 1
 END IF

 DO J1 = 1,NBLKS
   JB = 1 + (J1-1) * NCOL
   JF = JB + NCOL - 1
   JF = MIN (JF,NFRQ)

   WRITE(NW,1)
   WRITE(NW,2) FREQ(JB:JF)
   WRITE(NW,'(3X)')
   DO JR = 1, NRX1
     WRITE(NW,3) JR,RXPLT(1:3,JR),YTR(JB:JF,JR)
   END DO
 END DO

 1 FORMAT(/T11,'RECEIVER POSITIONS',T40,'FREQUENCIES')
 2 FORMAT(T5,'Northing     Easting     Elev',T37,35G13.4)
 3 FORMAT(I3,2F12.2,F9.2,35G13.4)

END SUBROUTINE WRFDP

 SUBROUTINE WRFDS (NW,PRTYP,NFRQ,FREQ,NLOC,NRX1,JC,RXPLT,YTR)
!-------------------------------------------------------------

!***  Called by WRITE_FD
!***  Calls WRSLVP

!  Writes time-domain output in spectral form.

 IMPLICIT NONE
 INTEGER NW,PRTYP,NFRQ,NLOC,NRX1,JC,NBLKS,J1,JB,JE,JF,NCOL
 REAL FREQ(NFRQ),YTR(NFRQ,NLOC)
 REAL(KIND=8) RXPLT(3,NLOC)
 CHARACTER(LEN=23) DIRECTION(6)
 CHARACTER(LEN=50) RESPONSE(3)
 DATA DIRECTION /'NORTH COMPONENT        ','EAST COMPONENT         ','VERTICAL COMPONENT     ', &
                 'BH HORIZONTAL COMPONENT','BH SLOPE COMPONENT     ','BH AXIAL COMPONENT     '/
 DATA RESPONSE /'STANDARD OUTPUT - LAYERED EARTH + SCATTERED FIELDS', &
                'SCATTERED FIELD - INDUCED PLUS CURRENT GATHERING  ', &
                'PERCENT TARGET EFFECT                             '/

 IF (JC < 7) THEN
   WRITE(NW,'(/T7,2A)') 'SPECTRAL OUTPUT:  ',DIRECTION(JC)
 ELSE
   WRITE(NW,'(/T7,2A)') 'SPECTRAL OUTPUT:  '
 END IF
 WRITE(NW,'(T7,A)') RESPONSE(PRTYP)
 WRITE(NW,4)

 NCOL = MIN (NRX1, 35)
 NBLKS = 1
 IF (NRX1 > 35) THEN
   NBLKS = NRX1 / NCOL
   IF (MOD (NRX1,NCOL) > 0) NBLKS = NBLKS + 1
 END IF

 DO J1 = 1,NBLKS
   JB = 1 + (J1-1) * NCOL
   JE = JB + NCOL - 1
   JE = MIN (JE,NRX1)
   WRITE(NW,1) RXPLT(1,JB:JE)
   WRITE(NW,2) RXPLT(2,JB:JE)
   WRITE(NW,3) RXPLT(3,JB:JE)
   WRITE(NW,'(3X)')

   DO JF = 1,NFRQ
     WRITE(NW,'(I4,G12.4,T18,35G13.4)') JF,FREQ(JF),YTR(JF,JB:JE)
   END DO
 END DO

 1 FORMAT(/T16,35F13.2)
 2 FORMAT(T16,35F13.2)
 3 FORMAT( T6,'Frequency',T16,35F13.2)
 4 FORMAT(/T20,'RECEIVER COORDINATES (Top to Bottom): Northing, Easting, Elevation')

END SUBROUTINE WRFDS

  SUBROUTINE WRYT_LOG_FILE (NLG,MSG,MXERR,ERR_LVL)
! -------------------------------------------------

! This subroutine prints out warning and fatal error messages on the LOG file.
!
! NLG = output unit index
! MSG refers to error message index
! ERR_LVL = 1 for warnings;  = 2 for fatal errors
! MXERR = MAX (ERR_LVL)

 INTEGER ERR_LVL, MSG, NLG, MXERR

 MXERR = MAX (ERR_LVL,MXERR)
 IF (ERR_LVL == 1) WRITE(NLG,101)
 IF (ERR_LVL == 2) WRITE(NLG,102)
 IF (ERR_LVL == 3) WRITE(NLG,103)


 IF (MSG == 1) WRITE(NLG,1)
 IF (MSG == 2) WRITE(NLG,2)
 IF (MSG == 3) WRITE(NLG,3)
 IF (MSG == 4) WRITE(NLG,4)
 IF (MSG == 5) WRITE(NLG,5)
 IF (MSG == 6) WRITE(NLG,6)
 IF (MSG == 7) WRITE(NLG,7)
 IF (MSG == 8) WRITE(NLG,8)
 IF (MSG == 9) WRITE(NLG,9)
 IF (MSG == 10) WRITE(NLG,10)
 IF (MSG == 11) WRITE(NLG,11)
 IF (MSG == 12) WRITE(NLG,12)
 IF (MSG == 13) WRITE(NLG,13)
 IF (MSG == 14) WRITE(NLG,14)
 IF (MSG == 15) WRITE(NLG,15)
 IF (MSG == 16) WRITE(NLG,16)
 IF (MSG == 17) WRITE(NLG,17)
 IF (MSG == 21) WRITE(NLG,21)
 IF (MSG == 22) WRITE(NLG,22)
 IF (MSG == 23) WRITE(NLG,23)
 IF (MSG == 51) WRITE(NLG,51)
 IF (MSG == 90) THEN
   WRITE(NLG,90)
   STOP
 END IF
  1 FORMAT(T3,'The value for TDFD is outside the permitted range.' &
          /T3,'The allowed values are: 1 for time-domain or 2 for frequency domain.')
  2 FORMAT(T3,'The allowed values for PRFL are: 1 for profile mode, 0 otherwise.' &
          /T3,'PRFL has been set to 1.')
  3 FORMAT(T3,'The value for DO3D is outside the permitted range OF 0, 1, or 2.' &
          /T3,'DO3D has been reset to 1.  A new model will be computed.')
  4 FORMAT(T3,'The value for STEP is outside the permitted range.' &
          /T3,'The allowed values are: 0 or 1.')
  5 FORMAT(T3,'The value for KRXW is outside the permitted range.' &
          /T3,'The allowed values are: 1 or 2.')
  6 FORMAT(T3,'Central loop option is only available for loop sources.')
  7 FORMAT(T3,'This value for TOPN is outside the permitted range.' &
          /T3,'It must be > 0.')
  8 FORMAT(T3,'SOURCE_TYPE is only allowed values: 1, 2, 3, or 4.')
  9 FORMAT(T3,'FLAT_TX is only allowed values of 0 and 1')
 10 FORMAT(T3,'SURVEY_TYPE is only allowed values: 1, 2, 3, or 4.')
 11 FORMAT(T3,'There must be at least one receiver group if SURVEY_TYPE = 1.')
 12 FORMAT(T3,'No events (Tx-Rx combinations) have been specified.')
 13 FORMAT(T3,'Not all of the transmitter positions have been specified by events.' &
          /T3,'Is this intended?')
 14 FORMAT(T3,'The constant offset option is not available for grounded wire sources.')
 15 FORMAT(T3,'The offset between magnetic dipole sources and magnetic dipole recaivers' &
          /T3,'should not be less than 0.01 m')
 16 FORMAT(T3,'The coincident loop option is available only for loop sources.'/)
 17 FORMAT(T3,'The coincident loop option is available only for time-domain'/)
 21 FORMAT(T3,'This lithology index is invalid.' &
          /T3,'No resistivity or conductance has been specified.')
 22 FORMAT(T3,'Layer lithology indices must be an integer between 1 & NLITH')
 23 FORMAT(T3,'Layer resistivities must be positive.')
 51 FORMAT(T3,'The magnetotelluric option has not yet been implemented in this code' &
          /T3,'Please choose another source type option')
 90 FORMAT(//T3,'MESSAGE FROM SCAT_MTRX_LU_DCMP: THE MATRIX IS SINGULAR.', &
            /T3,'COMPUTATION HALTED.  SEEK HELP.')
 101 FORMAT(/T2,'INFORMATION'/T2,'-----------')
 102 FORMAT(/T2,'WARNING'/T2,'-------')
 103 FORMAT(/T2,'FATAL ERROR'/T2,'----- -----')

END SUBROUTINE  WRYT_LOG_FILE


!=================================================
!  Start of extended AMIRA format routines: Marco
!=================================================
!
!  SUBROUTINE WRITE_FAMX
!  SUBROUTINE WRITE_FAMX_PPM
!      SUBROUTINE FEM_PERC
!      SUBROUTINE WFAMX_HEADER
!  SUBROUTINE WRITE_TAMX
!      SUBROUTINE TEM_PERC
!      SUBROUTINE WAMX_CLDIST
!      SUBROUTINE WAMX_POS
!      SUBROUTINE WTAMX_HEADER
!  SUBROUTINE SET_OUTPUT_SCALING
!
!  Notes
!  1.  Data are ALWAYS written in PROFILE mode
!  2.  Following the convention of AEM data, quadrature phase data are output before inphase data.
!      In the *.out file, the order is reversed ie. inphase, then quadrature.
!  3.  Blocked-mode ouput (OUTPUT > 12) must be accessed by editing Marco.cfl; it cannot be
!      enabled from EMGui
!  4.  FEM dipole-dipole data are written in units of ppm UNLESS OVERRIDDEN (by setting OUTPUT < 0)
!  5.  Contents of Marco.amx are determined by the variable OUTPUT as follows
!
!      OUTPUT      Contents
!      ------      ---------
!      10, 11      Total-field only
!      12          Total, scattered & percentage target effect data
!      20, 21      Blocked-mode total-field only
!      22          Blocked-mode total, scattered & percentage target effect data
!
!      OUTPUT is irrelevant for Arjuna & Loki as as neither program computes scattered fields
!

 SUBROUTINE WRITE_FAMX(TITLE, &
                STEP,OUTPUT,SOURCE_TYPE,SURVEY_TYPE, &
                NFRQ,FREQ, &
                NTXE, MXVRTX,N_VRTX, &
                SXE,SXN,SXZ,SXDIP,SXAZ,SXMNT,&
                NRGTX,NRXG,RGTXID,NCMPG,PRTCMP,LRX,MRX,NRX,MQVR,&
                RX_TYPE,UNITS,RXED,RXND,RXZD,RXDIP,RXAZ,RXMNT,&
                BFD,BFD_SCAT)
!---------------------------------------------------------------------------------

!  Calls       wfamx_header
!              set_output_scaling
!              wamx_pos
!              wamx_cldist
!              fem_perc
!  Called by:  main

   IMPLICIT NONE

   INTEGER, PARAMETER :: AMX_MAJOR = 2
   INTEGER, PARAMETER :: AMX_MINOR = 0
   INTEGER, PARAMETER :: NA = 30
   INTEGER, PARAMETER :: MAX_RCT = 3
   INTEGER, PARAMETER :: MAX_CMP = 3
   INTEGER, PARAMETER :: MAX_TYP = 3
   INTEGER, PARAMETER :: MAX_SRC = 4
   INTEGER, PARAMETER :: LBASE = 10000
   INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 80)

   INTEGER, INTENT (IN) :: STEP, OUTPUT
   INTEGER, INTENT (IN) :: SOURCE_TYPE, SURVEY_TYPE
   INTEGER, INTENT (IN) :: NFRQ
   INTEGER, INTENT (IN) :: NTXE, MXVRTX
   INTEGER, INTENT (IN) :: N_VRTX(NTXE)
   INTEGER, INTENT (IN) :: NRXG, LRX, MRX, MQVR

   INTEGER, INTENT (IN) :: NRGTX(NTXE)
   INTEGER, INTENT (IN) :: NRX(NRXG), UNITS(NRXG), RX_TYPE(NRXG), NCMPG(NRXG)
   INTEGER, INTENT (IN) :: PRTCMP(10, NRXG)

   INTEGER, INTENT (IN) :: RGTXID(NRXG, NTXE)

   INTEGER :: JD, JG, JS, JV, JX, JR, JC, JC1
   INTEGER :: KA, KZ, KT, KG, KC, KV
   INTEGER :: N_CORNR, NLOC, STNS, N_PRFL

   COMPLEX, INTENT (IN) :: BFD(NFRQ, LRX, NTXE, MAX_CMP)
   COMPLEX, INTENT (IN) :: BFD_SCAT(NFRQ, LRX, NTXE, MAX_CMP)

   COMPLEX, ALLOCATABLE :: OUT_TOTL(:,:), OUT_HOLD(:,:)
   COMPLEX, ALLOCATABLE :: OUT_SCAT(:,:), OUT_PERC(:,:)

   REAL, PARAMETER :: RAD2DEG = (180. / 3.14159265)

   REAL (KIND = DP), INTENT (IN) :: RXED(MRX, NRXG, MQVR), RXND(MRX, NRXG, MQVR), RXZD(MRX, NRXG, MQVR)

   REAL (KIND = DP), ALLOCATABLE :: RXPLT(:, :)
   REAL (KIND = DP), ALLOCATABLE :: SLENG(:)

   REAL, INTENT (IN) :: SXE(MXVRTX, NTXE), SXN(MXVRTX, NTXE), SXZ(MXVRTX, NTXE)
   REAL, INTENT (IN) :: RXDIP(MRX, NRXG), RXAZ(MRX, NRXG), RXMNT(MRX, NRXG)
   REAL, INTENT (IN) :: FREQ(NFRQ)
   REAL, INTENT (IN) :: SXDIP(NTXE), SXAZ(NTXE), SXMNT(NTXE)

   REAL :: OUT_SCALE(MRX, NRXG)

   CHARACTER (LEN = 120), INTENT (IN) :: TITLE

   CHARACTER (LEN = 05), PARAMETER :: PROG_NAME = "Marco"
   CHARACTER (LEN = 09), PARAMETER :: FILE_NAME = "Marco.amx"

   CHARACTER (LEN = 03) :: OUT_DTYPE(MAX_TYP)
   CHARACTER (LEN = 03) :: OUT_RXTYP2(MAX_RCT)
   CHARACTER (LEN = 03) :: OUT_COMP(10)
   CHARACTER (LEN = 04) :: OUT_UNITS(NRXG)
   CHARACTER (LEN = 15) :: OUT_RXTYP1(MAX_RCT)
   CHARACTER (LEN = 15) :: OUT_SURVEY(MAX_SRC)
   CHARACTER (LEN = 16) :: OUT_SOURCE(MAX_SRC + 1)

   DATA OUT_RXTYP2 / "MDP", "FLP", "EDP"/
   DATA OUT_SOURCE / "General_Loop    ", &
                     "Grounded_Wire   ", &
                     "Magnetic_Dipole ", &
                     "Magnetotellurics", &
                     "Coincident-loop "/
   DATA OUT_SURVEY / "Separate_Tx_Rx ", &
                     "Slingram       ", &
                     "Central_loop   ", &
                     "Coincident_loop" /
   DATA OUT_RXTYP1 / "Magnetic_dipole", &
                     "Finite_loop    ", &
                     "Electric_dipole"/
   DATA OUT_COMP   / " N", " E", " Z", &
                     "HR", "SL", "AX", &
                     "ED", "LP", "DZ", " Z"/
   DATA OUT_DTYPE  /"_TF", "_SF", "_PT"/

!
!  Enforce profile mode for output ...
   N_PRFL = 1

!
!  Code begins -- open output file & write first standard three lines ...
   OPEN (UNIT = NA, FILE = FILE_NAME, STATUS = "REPLACE")

   WRITE (NA, 1000) TRIM(TITLE)
   WRITE (NA, 1002) AMX_MAJOR, AMX_MINOR, PROG_NAME
   CALL WFAMX_HEADER(NA, OUTPUT, NFRQ)

!
!  Determine output scaling factors & units...
   CALL SET_OUTPUT_SCALING (NRXG, MRX, SURVEY_TYPE, RX_TYPE, RXMNT, STEP, UNITS, OUT_SCALE, OUT_UNITS)

!
!  Write header blocks ...
   WRITE (NA, 1003) N_PRFL, OUTPUT
   WRITE (NA, 1004) OUT_SURVEY(SURVEY_TYPE), OUT_SOURCE(SOURCE_TYPE)

   SELECT CASE (SURVEY_TYPE)
   CASE (1)
     NLOC = MRX
     WRITE (NA, 1005) NTXE
     DO JS = 1, NTXE
       WRITE (NA, 1001)
       IF (SOURCE_TYPE == 3) WRITE (NA, 1006) JS, SXE(1, JS), SXN(1, JS), SXZ(1, JS), &
                                                  SXMNT(JS), RAD2DEG * SXDIP(JS), RAD2DEG * SXAZ(JS)
       IF (SOURCE_TYPE /= 3) WRITE (NA, 1007) JS, N_VRTX(JS), (SXE(JV, JS), SXN(JV, JS), SXZ(JV, JS), JV = 1, N_VRTX(JS))
!
!      Now Rx groups for current transmitter ...
       DO JG = 1, NRGTX(JS)
           WRITE (NA, 1001)
           KG = RGTXID(JG, JS)
           KT = RX_TYPE(KG)
           JX = NRX(KG)

           IF (KT == 1) N_CORNR = 1        ! dipole ...
           IF (KT == 2) N_CORNR = 4        ! loop ...
           IF (KT == 3) N_CORNR = 2        ! bipole ...

           ALLOCATE (RXPLT(3, NRX(KG)))
           ALLOCATE (SLENG(NRX(KG)))
           CALL WAMX_POS(0, MRX, NRXG, MQVR, JX, KG, N_CORNR, RXED, RXND, RXZD, RXPLT, SLENG, STNS)

           WRITE (NA, 1008) JS, JG, OUT_RXTYP1(KT)
           IF ((OUTPUT == 10) .OR. (OUTPUT == 20)) WRITE (NA, 1009) JS, JG, TRIM(OUT_UNITS(JG))
           IF ((OUTPUT == 11) .OR. (OUTPUT == 21)) WRITE (NA, 1009) JS, JG, TRIM(OUT_UNITS(JG)), &
                                                                               TRIM(OUT_UNITS(JG)), "%"
           WRITE (NA, 1010) JS, JG, JX

!
!          Receiver parameters for current group ...
           WRITE (NA, 1001)
           IF (KT == 1) THEN
               DO JR = 1, JX
               WRITE (NA, 1011) JS, JG, JR, RXED(JR, KG, 1), RXND(JR, KG, 1), RXZD(JR, KG, 1), &
                                   RXMNT(JR, KG), RXDIP(JR, KG), RXAZ(JR, KG)
               END DO
           ELSE
               DO JR = 1, JX
               WRITE (NA, 1016) JS, JG, JR, N_CORNR, &
                                   (RXED(JR, KG, KV), RXND(JR, KG, KV), RXZD(JR, KG, KV), KV = 1, N_CORNR)
               END DO
           END IF

           DEALLOCATE (RXPLT, SLENG)

       END DO
     END DO


!
!    Usually, we'd branch for Profile / spectral mode, but for multiple receivers per transmitters, there seems
!    little point.  Instead, write frequencies no matter the mode.
     WRITE (NA, 1001)
     WRITE (NA, 1012) "/FREQSINGLE(Hz)=", FREQ(1: NFRQ)

!
!    We are now(!) in a position to write data ...
     DO JS = 1, NTXE
       KA = 1
       DO JG = 1, NRGTX(JS)

         KG = RGTXID(JG, JS)
         KT = RX_TYPE(KG)
         JX = NRX(KG)
         KZ = (KA + JX) - 1

         IF (KT == 1) N_CORNR = 1        ! dipole ...
         IF (KT == 2) N_CORNR = 4        ! loop ...
         IF (KT == 3) N_CORNR = 2        ! bipole ...

!
!        Set up plotting points ...
         ALLOCATE (RXPLT(3, NRX(KG)))
         ALLOCATE (SLENG(NRX(KG)))
         CALL WAMX_POS(0, MRX, NRXG, MQVR, JX, KG, N_CORNR, RXED, RXND, RXZD, RXPLT, SLENG, STNS)

!
!        Loop over components ...
         DO JC = 1, NCMPG(JG)
           WRITE (NA, 1001)
           IF (KT > 1) THEN
               KC = 1
               JC1 = 7
           ELSE
               JC1 = PRTCMP(JC, KG)
               KC = JC1
               IF (KC > 3) KC = KC - 3
           END IF

!
!          Fill output arrays & calculate percentage-target effect ...
           ALLOCATE (OUT_TOTL(NFRQ, JX), OUT_HOLD(NFRQ, JX))
           OUT_TOTL(1: NFRQ, 1: JX) = BFD(1: NFRQ, KA: KZ, JS, KC)
           DO JR = 1, JX
               OUT_TOTL(1: NFRQ, JR) = SXMNT(JS) * OUT_TOTL(1: NFRQ, JR) * OUT_SCALE(JR, KG)
           END DO

!
!          setup for target-effect calcs iff required ...
           IF (OUTPUT == 12) THEN
               ALLOCATE (OUT_SCAT(NFRQ, JX), OUT_PERC(NFRQ, JX))
               OUT_SCAT(1: NFRQ, 1: JX) = BFD_SCAT(1: NFRQ, KA: KZ, JS, KC)
               DO JR = 1, JX
                   OUT_SCAT(1: NFRQ, JR) = SXMNT(JS) * OUT_SCAT(1: NFRQ, JR) * OUT_SCALE(JR, KG)
               END DO
              CALL FEM_PERC(NFRQ, JX, OUT_SCAT, OUT_TOTL, OUT_PERC)
           END IF

           DO JR = 1, JX

               SELECT CASE (OUTPUT)
               CASE (10, 11)

                   WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), JS, JG, JR, &
                                                   SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(KT), NFRQ

                   WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_TOTL(1: NFRQ, JR))

               CASE (12)

                   WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), JS, JG, JR, &
                                                   SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(KT), NFRQ

                   WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "NO")  REAL(OUT_TOTL(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_SCAT(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "NO")  REAL(OUT_SCAT(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_PERC(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_PERC(1: NFRQ, JR))

               CASE (20, 21)

                   WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), "_TF", &
                                                   JS, JG, JR, &
                                                   SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(KT), NFRQ

                   WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_TOTL(1: NFRQ, JR))

               END SELECT

           END DO

           DEALLOCATE (OUT_TOTL, OUT_HOLD)
           IF (OUTPUT == 12) DEALLOCATE (OUT_SCAT, OUT_PERC)

         END DO

!
!        Special case of output == 21 (blocked mode, all data).  We need this because of the requirement to group
!        all data of a certain type together.  Without the special case, we get the different types printed at the
!        same station and this makes the file quite difficult to process
         IF (OUTPUT == 22) THEN
           DO JD = 1, MAX_TYP
             WRITE (NA, 1001)
             DO JC = 1, NCMPG(JG)
               WRITE (NA, 1001)
               IF (KT > 1) THEN
                 KC = 1
                 JC1 = 7
               ELSE
                 JC1 = PRTCMP(JC, KG)
                 KC = JC1
                 IF (KC > 3) KC = KC - 3
               END IF

!
!              Fill output arrays & calculate percentage-target effect ...
               ALLOCATE (OUT_TOTL(NFRQ, JX), OUT_HOLD(NFRQ, JX))
               ALLOCATE (OUT_SCAT(NFRQ, JX), OUT_PERC(NFRQ, JX))

               OUT_TOTL(1: NFRQ, 1: JX) = BFD(1: NFRQ, 1: JX, JS, KC)
               OUT_SCAT(1: NFRQ, 1: JX) = BFD_SCAT(1: NFRQ, 1: JX, JS, KC)

               DO JR = 1, JX
                 OUT_TOTL(1: NFRQ, JR) = SXMNT(JS) * OUT_TOTL(1: NFRQ, JR) * OUT_SCALE(JR, KG)
                 OUT_SCAT(1: NFRQ, JR) = SXMNT(JS) * OUT_SCAT(1: NFRQ, JR) * OUT_SCALE(JR, KG)
               END DO
               CALL FEM_PERC(NFRQ, JX, OUT_SCAT, OUT_TOTL, OUT_PERC)

               IF (JD == 1) OUT_HOLD = OUT_TOTL
               IF (JD == 2) OUT_HOLD = OUT_SCAT
               IF (JD == 3) OUT_HOLD = OUT_PERC

               DO JR = 1, JX
                   WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), OUT_DTYPE(JD), &
                                                       JS, JG, JR, &
                                                       SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                       OUT_COMP(JC1), OUT_RXTYP2(KT), NFRQ

                   WRITE (NA, 1015, ADVANCE = "NO")  AIMAG(OUT_HOLD(1: NFRQ, JR))
                   WRITE (NA, 1015, ADVANCE = "YES")  REAL(OUT_HOLD(1: NFRQ, JR))
               END DO

               DEALLOCATE (OUT_TOTL, OUT_HOLD)
               DEALLOCATE (OUT_SCAT, OUT_PERC)

             END DO
           END DO
         END IF

         DEALLOCATE (RXPLT, SLENG)
         KA = KZ + 1

       END DO
     END DO

   CASE DEFAULT
     NLOC = NTXE
     JG = 1; KT = 1

!
!    Write transmitter parameters ....
     WRITE (NA, 1005) NLOC
     WRITE (NA, 1001)
     SELECT CASE (SOURCE_TYPE)
     CASE (3)
       DO JS = 1, NLOC
         WRITE (NA, 1006) JS, SXE(1, JS), SXN(1, JS), SXZ(1, JS), SXMNT(JS), RAD2DEG * SXDIP(JS), RAD2DEG * SXAZ(JS)
       END DO
     CASE DEFAULT
       DO JS = 1, NLOC
         WRITE (NA, 1007) JS, N_VRTX(JS), (SXE(JV, JS), SXN(JV, JS), SXZ(JV, JS), JV = 1, N_VRTX(JS))
       END DO
     END SELECT

!
!    Write receiver parameters ...
     WRITE (NA, 1001)
     WRITE (NA, 1008)                   1, JG, OUT_RXTYP1(KT)
     IF ((OUTPUT == 12) .OR. (OUTPUT == 22)) THEN
       WRITE (NA, 1009) 1, JG, TRIM(OUT_UNITS(JG)), TRIM(OUT_UNITS(JG)), "%"
     ELSE
       WRITE (NA, 1009) 1, JG, TRIM(OUT_UNITS(JG))

     END IF

     WRITE (NA, 1010)                   1, JG, NLOC
     DO JR = 1, NLOC
       WRITE (NA, 1011) 1, JG, JR, &
                       RXED(1, JR, 1), RXND(1, JR, 1), RXZD(1, JR, 1), &
                       RXMNT(JR, 1), RXDIP(JR, 1), RXAZ(JR, 1)
     END DO

     ALLOCATE (RXPLT(3, NLOC))
     ALLOCATE (SLENG(NLOC))
     CALL WAMX_POS(1, MRX, NRXG, MQVR, NLOC, JG, N_CORNR, RXED, RXND, RXZD, RXPLT, SLENG, STNS)

!
!    Branch for profile / spectral mode ...
     WRITE (NA, 1001)
     WRITE (NA, 1012) "/FREQSINGLE(Hz)=", FREQ(1: NFRQ)

!
!    Completed writing header section; start on data ...
     DO JC = 1, NCMPG(1)
       WRITE (NA, 1001)
       IF (KT > 1) THEN
         KC = 1
         JC1 = 7
       ELSE
         JC1 = PRTCMP(JC, 1)
         KC = JC1
         IF (KC > 3) KC = KC - 3
       END IF

!
!      Fill output arrays
       ALLOCATE (OUT_TOTL(NFRQ, NLOC), OUT_HOLD(NFRQ, NLOC))
       OUT_TOTL(1: NFRQ, 1: NLOC) =  BFD(1: NFRQ, 1: NLOC, 1, KC)
       DO JR = 1, NLOC
         OUT_TOTL(1: NFRQ, JR) = OUT_TOTL(1: NFRQ, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
       END DO

!
!      Calculate target effect iff required ...
       IF (OUTPUT == 12) THEN
           ALLOCATE (OUT_SCAT(NFRQ, NLOC), OUT_PERC(NFRQ, NLOC))

           OUT_SCAT(1: NFRQ, 1: NLOC) =  BFD_SCAT(1: NFRQ, 1: NLOC, 1, KC)

           DO JR = 1, NLOC
             OUT_SCAT(1: NFRQ, JR) = OUT_SCAT(1: NFRQ, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
           END DO
           CALL FEM_PERC(NFRQ, NLOC, OUT_SCAT, OUT_TOTL, OUT_PERC)
       END IF

       DO JS = 1, NLOC

           SELECT CASE (OUTPUT)
           CASE (10, 11)

               WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 10 * JG), 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_TOTL(1: NFRQ, JS))

           CASE (12)
               WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 10 * JG), 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO")  REAL(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_SCAT(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO")  REAL(OUT_SCAT(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_PERC(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_PERC(1: NFRQ, JS))

           CASE (20, 21)

               WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 10 * JG), "_TF", 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_TOTL(1: NFRQ, JS))

           END SELECT

       END DO

       DEALLOCATE (OUT_TOTL, OUT_HOLD)
       IF (OUTPUT == 12 .OR. OUTPUT == 22) DEALLOCATE (OUT_SCAT, OUT_PERC)

     END DO

!
!    Special case of output == 22 (blocked mode, all data).  We need this because of the requirement to group
!    all data of a certain type together.  Without the special case, we get the different types printed at the
!    same station and this makes the file quite difficult to process
     IF (OUTPUT == 22) THEN
       DO JD = 1, MAX_TYP
         WRITE (NA, 1001)
         DO JC = 1, NCMPG(1)
           WRITE (NA, 1001)
           IF (KT > 1) THEN
             KC = 1
             JC1 = 7
           ELSE
             JC1 = PRTCMP(JC, 1)
             KC = JC1
             IF (KC > 3) KC = KC - 3
           END IF

!
!          Fill output arrays & calculate percentage-target effect ...
           ALLOCATE (OUT_TOTL(NFRQ, NLOC), OUT_HOLD(NFRQ, NLOC))
           ALLOCATE (OUT_SCAT(NFRQ, NLOC), OUT_PERC(NFRQ, NLOC))

           OUT_TOTL(1: NFRQ, 1: NLOC) =  BFD(1: NFRQ, 1: NLOC, 1, KC)
           OUT_SCAT(1: NFRQ, 1: NLOC) =  BFD_SCAT(1: NFRQ, 1: NLOC, 1, KC)

           DO JR = 1, NLOC
             OUT_TOTL(1: NFRQ, JR) = OUT_TOTL(1: NFRQ, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
             OUT_SCAT(1: NFRQ, JR) = OUT_SCAT(1: NFRQ, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
           END DO

           CALL FEM_PERC(NFRQ, NLOC, OUT_SCAT, OUT_TOTL, OUT_PERC)

           IF (JD == 1) OUT_HOLD = OUT_TOTL
           IF (JD == 2) OUT_HOLD = OUT_SCAT
           IF (JD == 3) OUT_HOLD = OUT_PERC

           DO JS = 1, NLOC
               WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 10 * JG), OUT_DTYPE(JD), 1, 1, JS, &
                                                   SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_HOLD(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_HOLD(1: NFRQ, JS))
           END DO

           DEALLOCATE (OUT_TOTL, OUT_HOLD)
           DEALLOCATE (OUT_SCAT, OUT_PERC)

         END DO

       END DO

     END IF

     DEALLOCATE (RXPLT, SLENG)

   END SELECT

   CLOSE (NA)

!  Formats ...
1000 FORMAT (a)
1001 FORMAT ("/")
1002 FORMAT ("AMX_VERSION=", i2.2, ".", i2.2, 2x, "PROGRAM_NAME:", a)
1003 FORMAT ("/", /, "/FILE_TYPE=", i2.2, /, "/FIELDS_FORMAT=", i2.2, /, "/")
1004 FORMAT ("/", /, "/SURVEY_TYPE=", a, /, "/SOURCE_TYPE=", a, /, "/")
1005 FORMAT ("/TX_TOTAL=", i3.3)
1006 FORMAT ("/TX", i3.3, "_COORDS(N,E,Z,M,Dip,Az)=", 6(f13.2, :, ", ", 2x))
1007 FORMAT ("/TX", i3.3, "_COORDS(NVRTxN,E,Z)=", i2.2, ", ", 256(f13.2, ", ", f13.2, ", ", f13.2, :, ", "))
1008 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_TYPE=", a)
1009 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_UNITS=", 3(a, :, ","))
1010 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_NUMBER=", i3.3)
1011 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_RXN", i3.3, "_PARAMS(N,E,Z,M,Dip,Az)=", 6(f13.2, :, ", "))
1012 FORMAT (a, 2x, 512(f13.2, :, ", "))
1014 FORMAT (2x, i6, 3(2x, i4), 5(2x, f13.2), 2x, a2, 2x, a3, 2x, i4)
1015 FORMAT (512(:, 2x, e15.6))
1016 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_RXN", i3.3, "_PARAMS(nv,Nv,Ev,Zv)=", &
             i2.2, ", ", 4(f13.2, ", ", f13.2, ", ", f13.2, :, ", "))
1018 FORMAT (2x, i6, a3, 3(2x, i4), 5(2x, f13.2), 2x, a2, 2x, a3, 2x, i4)

  END SUBROUTINE WRITE_FAMX
!--------------

 SUBROUTINE WRITE_FAMX_PPM(TITLE, &
               STEP, OUTPUT, SOURCE_TYPE, SURVEY_TYPE, &
               NFRQ, FREQ, &
               NTXE, MXVRTX, SXE, SXN, SXZ, SXDIP, SXAZ, SXMNT, &
               NRXG, NCMPG, PRTCMP, &
               LRX, MRX, MQVR, &
               RXED, RXND, RXZD, RXDIP, RXAZ, RXMNT, &
               BFD, BFD_SCAT, &
               DXPRM, CURNT, CMPDX)
!---------------------------------------------------------------------------------

!  Calls       wfamx_header
!              set_output_scaling
!              wamx_pos
!              wamx_cldist
!              fem_perc
!  Called by:  main

   IMPLICIT NONE

   INTEGER, PARAMETER :: AMX_MAJOR = 2
   INTEGER, PARAMETER :: AMX_MINOR = 0
   INTEGER, PARAMETER :: NA = 30
   INTEGER, PARAMETER :: MAX_RCT = 3
   INTEGER, PARAMETER :: MAX_CMP = 3
   INTEGER, PARAMETER :: MAX_TYP = 3
   INTEGER, PARAMETER :: MAX_SRC = 4
   INTEGER, PARAMETER :: LBASE = 10000
   INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 80)

   INTEGER, INTENT (IN) :: STEP, OUTPUT
   INTEGER, INTENT (IN) :: SOURCE_TYPE, SURVEY_TYPE
   INTEGER, INTENT (IN) :: NFRQ
   INTEGER, INTENT (IN) :: NTXE, MXVRTX
   INTEGER, INTENT (IN) :: NRXG, LRX, MRX, MQVR

   INTEGER, INTENT (IN) :: NCMPG(NRXG)
   INTEGER, INTENT (IN) :: PRTCMP(10, NRXG)

   INTEGER, INTENT (IN) :: CMPDX

   INTEGER :: JD, JG, JS, JR, JC, JC1, JF
   INTEGER :: KT, KC
   INTEGER :: NLOC, STNS, N_PRFL

   LOGICAL :: CONVERT

   COMPLEX, PARAMETER :: I2PI= (0.,6.283185)  ! 2 * pi * i

   COMPLEX, INTENT (IN) :: BFD(NFRQ, LRX, NTXE, MAX_CMP)
   COMPLEX, INTENT (IN) :: BFD_SCAT(NFRQ, LRX, NTXE, MAX_CMP)

   COMPLEX, ALLOCATABLE :: OUT_TOTL(:,:), OUT_HOLD(:,:)
   COMPLEX, ALLOCATABLE :: OUT_SCAT(:,:), OUT_PERC(:,:)

   REAL, PARAMETER :: RAD2DEG = (180. / 3.14159265)

   REAL (KIND = DP), INTENT (IN) :: RXED(MRX, NRXG, MQVR), RXND(MRX, NRXG, MQVR), RXZD(MRX, NRXG, MQVR)

   REAL (KIND = DP), ALLOCATABLE :: RXPLT(:, :)
   REAL (KIND = DP), ALLOCATABLE :: SLENG(:)

   REAL, INTENT (IN) :: SXE(MXVRTX, NTXE), SXN(MXVRTX, NTXE), SXZ(MXVRTX, NTXE)
   REAL, INTENT (IN) :: RXDIP(MRX, NRXG), RXAZ(MRX, NRXG), RXMNT(MRX, NRXG)
   REAL, INTENT (IN) :: FREQ(NFRQ), CURNT(NFRQ)
   REAL, INTENT (IN) :: SXDIP(NTXE), SXAZ(NTXE), SXMNT(NTXE)
   REAL, INTENT (IN) :: DXPRM(MAX_CMP, MAX_CMP - 1)

   REAL :: TOTAL_F, RTMP, QTMP

   CHARACTER (LEN = 120), INTENT (IN) :: TITLE

   CHARACTER (LEN = 05), PARAMETER :: PROG_NAME = "Marco"
   CHARACTER (LEN = 09), PARAMETER :: FILE_NAME = "Marco.amx"

   CHARACTER (LEN = 03) :: OUT_DTYPE(MAX_TYP)
   CHARACTER (LEN = 03) :: OUT_RXTYP2(MAX_RCT)
   CHARACTER (LEN = 03) :: OUT_COMP(10)
   CHARACTER (LEN = 04) :: OUT_UNITS(NRXG)
   CHARACTER (LEN = 10) :: OUT_ACTUAL(MAX_CMP + 1)
   CHARACTER (LEN = 11) :: OUT_NORMAL(MAX_CMP)
   CHARACTER (LEN = 15) :: OUT_RXTYP1(MAX_RCT)
   CHARACTER (LEN = 15) :: OUT_SURVEY(MAX_SRC)
   CHARACTER (LEN = 16) :: OUT_SOURCE(MAX_SRC + 1)

   DATA OUT_RXTYP2 / "MDP", "FLP", "EDP"/
   DATA OUT_SOURCE / "General_Loop    ", &
                     "Grounded_Wire   ", &
                     "Magnetic_Dipole ", &
                     "Magnetotellurics", &
                     "Coincident-loop "/
   DATA OUT_SURVEY / "Separate_Tx_Rx ", &
                     "Slingram       ", &
                     "Central_loop   ", &
                     "Coincident_loop" /
   DATA OUT_RXTYP1 / "Magnetic_dipole", &
                     "Finite_loop    ", &
                     "Electric_dipole"/
   DATA OUT_COMP   / " N", " E", " Z", &
                     "HR", "SL", "AX", &
                     "ED", "LP", "DZ", " Z"/
   DATA OUT_DTYPE  /"_TF", "_SF", "_PT"/
   DATA OUT_NORMAL /"TOTAL_FIELD", &
                    "UNUSED     ", &
                    "COMPONENT  "/
   DATA OUT_ACTUAL /"HORIZONTAL", &
                    "SLOPE     ", &
                    "AXIAL     ", &
                    "TOTAL     "/

!
!  Enforce profile mode for output ...
!   N_PRFL = PRFL
!   IF (PRFL == 0)    N_PRFL = 1
   N_PRFL = 1
   CONVERT = .FALSE.

!
!  This means that data have already been converted to voltages in WRITE_FD.  We need to convert
!  them back to fields so that normalisation works properly ...
   IF (STEP == 0) CONVERT = .TRUE.

!
!  Code begins -- open output file & write first standard three lines ...
   OPEN (UNIT = NA, FILE = FILE_NAME, STATUS = "REPLACE")

   WRITE (NA, 1000) TRIM(TITLE)
   WRITE (NA, 1002) AMX_MAJOR, AMX_MINOR, PROG_NAME
   CALL WFAMX_HEADER(NA, OUTPUT, NFRQ)

!
!  Write header blocks ...
   TOTAL_F = SQRT(DXPRM(1, 1)**2 + DXPRM(2, 1)**2 + DXPRM(3, 1)**2)
   WRITE (NA, 1003) N_PRFL, OUTPUT
   WRITE (NA, 1004) OUT_SURVEY(SURVEY_TYPE), OUT_SOURCE(SOURCE_TYPE)
   WRITE (NA, 1020) OUT_NORMAL(CMPDX)
   WRITE (NA, 1021) 1.e12 * DXPRM(3, 1), 1.e12 * DXPRM(2, 1), 1.e12 * DXPRM(1, 1), 1.e12 * TOTAL_F
   WRITE (NA, 1001)

!
!  Tell the user what we are _actually_ doing.  This is determined by equality of slots 1 & 2
!  in DXPRM ie.  DXPRM(i, 1) == DXPRM(i, 2) => component
!                DXPRM(i, 1) != DXPRM(i, 2) => total field
   IF (CMPDX == 3) THEN
     DO JC = 1, 3
       IF (ABS(DXPRM(JC, 1) - DXPRM(JC, 2)) < TINY(1.0)) THEN
         WRITE (NA, 1022) TRIM(OUT_ACTUAL(JC)), TRIM(OUT_ACTUAL(JC))
       ELSE
         WRITE (NA, 1022) TRIM(OUT_ACTUAL(JC)), TRIM(OUT_ACTUAL(4))
       END IF
     END DO
   END IF
   WRITE (NA, 1001)

!
!  Write units to array ...
   DO JR = 1, MRX
     DO JG = 1, NRXG
       OUT_UNITS(JG) = "ppm"
     END DO
   END DO

   SELECT CASE (SURVEY_TYPE)
   CASE DEFAULT
     NLOC = NTXE
     JG = 1; KT = 1

!
!    Write transmitter parameters ....

     WRITE (NA, 1005) NLOC
     WRITE (NA, 1001)
     DO JS = 1, NLOC
       WRITE (NA, 1006) JS, SXE(1, JS), SXN(1, JS), SXZ(1, JS), SXMNT(JS), RAD2DEG * SXDIP(JS), RAD2DEG * SXAZ(JS)
     END DO

!
!    Write receiver parameters ...
     WRITE (NA, 1001)
     WRITE (NA, 1008) 1, JG, OUT_RXTYP1(KT)
     IF ((OUTPUT == 12) .OR. (OUTPUT == 22)) THEN
       WRITE (NA, 1009) 1, JG, TRIM(OUT_UNITS(JG)), TRIM(OUT_UNITS(JG)), "%"
     ELSE
       WRITE (NA, 1009) 1, JG, TRIM(OUT_UNITS(JG))
     END IF


     DO JR = 1, NLOC
       WRITE (NA, 1011) 1, JG, JR, &
                       RXED(1, JR, 1), RXND(1, JR, 1), RXZD(1, JR, 1), &
                       RXMNT(JR, 1), RXDIP(JR, 1), RXAZ(JR, 1)
     END DO

     ALLOCATE (RXPLT(3, NLOC))
     ALLOCATE (SLENG(NLOC))
     CALL WAMX_POS(1, MRX, NRXG, MQVR, NLOC, JG, 1, RXED, RXND, RXZD, RXPLT, SLENG, STNS)

     WRITE (NA, 1001)
     WRITE (NA, 1012) "/FREQSINGLE(Hz)=", FREQ(1: NFRQ)

!
!    Completed writing header section; start on data ...
     DO JC = 1, NCMPG(1)
       WRITE (NA, 1001)
       IF (KT > 1) THEN
         KC = 1
         JC1 = 7
       ELSE
         JC1 = PRTCMP(JC, 1)
         KC = JC1
         IF (KC > 3) KC = KC - 3
       END IF

!
!      Fill output arrays & calculate percentage-target effect ...
       ALLOCATE (OUT_TOTL(NFRQ, NLOC), OUT_HOLD(NFRQ, NLOC))

       OUT_TOTL(1: NFRQ, 1: NLOC) =  BFD(1: NFRQ, 1: NLOC, 1, KC)
       DO JS = 1, NLOC

            IF (CONVERT) OUT_TOTL(1: NFRQ, JS) = OUT_TOTL(1: NFRQ, JS) / (FREQ(1: NFRQ) * I2PI)

            OUT_TOTL(1: NFRQ, JS) = OUT_TOTL(1: NFRQ, JS) / CURNT(1: NFRQ)
            DO JF = 1, NFRQ
               RTMP = REAL(OUT_TOTL(JF, JS))
               QTMP = AIMAG(OUT_TOTL(JF, JS))
               RTMP = RTMP / DXPRM(KC, 2)
               QTMP = QTMP / DXPRM(KC, 2)

               OUT_TOTL(JF, JS) = CMPLX(RTMP, QTMP)

            END DO
       END DO
       OUT_TOTL(1: NFRQ, 1: NLOC) = 1.0E6 * OUT_TOTL(1: NFRQ, 1: NLOC)

!
!      Case for output == 22 is handeled separately ...
       IF (OUTPUT == 12) THEN
           ALLOCATE (OUT_SCAT(NFRQ, NLOC), OUT_PERC(NFRQ, NLOC))
           OUT_SCAT(1: NFRQ, 1: NLOC) =  BFD_SCAT(1: NFRQ, 1: NLOC, 1, KC)
           DO JS = 1, NLOC

               IF (CONVERT) OUT_SCAT(1: NFRQ, JS) = OUT_SCAT(1: NFRQ, JS) / (FREQ(1: NFRQ) * I2PI)

                OUT_SCAT(1: NFRQ, JS) = OUT_SCAT(1: NFRQ, JS) / CURNT(1: NFRQ)
                DO JF = 1, NFRQ
                   RTMP = REAL(OUT_SCAT(JF, JS))
                   QTMP = AIMAG(OUT_SCAT(JF, JS))
                   RTMP = RTMP / DXPRM(KC, 2)
                   QTMP = QTMP / DXPRM(KC, 2)

                   OUT_SCAT(JF, JS) = CMPLX(RTMP, QTMP)

                END DO
           END DO
           CALL FEM_PERC(NFRQ, NLOC, OUT_SCAT, OUT_TOTL / 1.0E6, OUT_PERC)
           OUT_SCAT(1: NFRQ, 1: NLOC) = 1.0E6 * OUT_SCAT(1: NFRQ, 1: NLOC)
       END IF

       DO JS = 1, NLOC

           SELECT CASE (OUTPUT)
           CASE (10, 11)

               WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 10 * JG), 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_TOTL(1: NFRQ, JS))

           CASE (12)
               WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 10 * JG), 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO")  REAL(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_SCAT(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO")  REAL(OUT_SCAT(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_PERC(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_PERC(1: NFRQ, JS))

           CASE (20, 21)

               WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 10 * JG), "_TF", 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_TOTL(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_TOTL(1: NFRQ, JS))

           END SELECT

       END DO

       DEALLOCATE (OUT_TOTL, OUT_HOLD)
       IF (OUTPUT == 12) DEALLOCATE (OUT_SCAT, OUT_PERC)

     END DO

!
!    Special case of output == 21 (blocked mode, all data).  We need this because of the requirement to group
!    all data of a certain type together.  Without the special case, we get the different types printed at the
!    same station and this makes the file quite difficult to process
     IF (OUTPUT == 22) THEN
       DO JD = 1, MAX_TYP
         WRITE (NA, 1001)
         DO JC = 1, NCMPG(1)
           WRITE (NA, 1001)
           IF (KT > 1) THEN
             KC = 1
             JC1 = 7
           ELSE
             JC1 = PRTCMP(JC, 1)
             KC = JC1
             IF (KC > 3) KC = KC - 3
           END IF

!
!          Fill output arrays & calculate percentage-target effect ...
           ALLOCATE (OUT_TOTL(NFRQ, NLOC), OUT_HOLD(NFRQ, NLOC))
           ALLOCATE (OUT_SCAT(NFRQ, NLOC), OUT_PERC(NFRQ, NLOC))

           OUT_TOTL(1: NFRQ, 1: NLOC) =  BFD(1: NFRQ, 1: NLOC, 1, KC)
           OUT_SCAT(1: NFRQ, 1: NLOC) =  BFD_SCAT(1: NFRQ, 1: NLOC, 1, KC)

           DO JS = 1, NLOC

               IF (CONVERT) OUT_TOTL(1: NFRQ, JS) = OUT_TOTL(1: NFRQ, JS) / (FREQ(1: NFRQ) * I2PI)
               IF (CONVERT) OUT_SCAT(1: NFRQ, JS) = OUT_SCAT(1: NFRQ, JS) / (FREQ(1: NFRQ) * I2PI)

               OUT_TOTL(1: NFRQ, JS) = OUT_TOTL(1: NFRQ, JS) / CURNT(1: NFRQ)
               OUT_SCAT(1: NFRQ, JS) = OUT_SCAT(1: NFRQ, JS) / CURNT(1: NFRQ)
               DO JF = 1, NFRQ
!
!                  first total field ...
                 RTMP = REAL(OUT_TOTL(JF, JS))
                 QTMP = AIMAG(OUT_TOTL(JF, JS))
                 RTMP = RTMP / DXPRM(KC, 2)
                 QTMP = QTMP / DXPRM(KC, 2)

                 OUT_TOTL(JF, JS) = CMPLX(RTMP, QTMP)

!
!                  ... then scattered ...
                 RTMP = REAL(OUT_SCAT(JF, JS))
                 QTMP = AIMAG(OUT_SCAT(JF, JS))
                 RTMP = RTMP / DXPRM(KC, 2)
                 QTMP = QTMP / DXPRM(KC, 2)

                 OUT_SCAT(JF, JS) = CMPLX(RTMP, QTMP)
                END DO
           END DO
           CALL FEM_PERC(NFRQ, NLOC, OUT_SCAT, OUT_TOTL, OUT_PERC)

           OUT_TOTL(1: NFRQ, 1: NLOC) = 1.0E6 * OUT_TOTL(1: NFRQ, 1: NLOC)
           OUT_SCAT(1: NFRQ, 1: NLOC) = 1.0E6 * OUT_SCAT(1: NFRQ, 1: NLOC)

           IF (JD == 1) OUT_HOLD = OUT_TOTL
           IF (JD == 2) OUT_HOLD = OUT_SCAT
           IF (JD == 3) OUT_HOLD = OUT_PERC

           DO JS = 1, NLOC
               WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 10 * JG), OUT_DTYPE(JD), 1, 1, JS, &
                                                   SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(1), NFRQ

               WRITE (NA, 1015, ADVANCE = "NO") AIMAG(OUT_HOLD(1: NFRQ, JS))
               WRITE (NA, 1015, ADVANCE = "YES") REAL(OUT_HOLD(1: NFRQ, JS))
           END DO

           DEALLOCATE (OUT_TOTL, OUT_HOLD)
           DEALLOCATE (OUT_SCAT, OUT_PERC)

         END DO

       END DO

     END IF

     DEALLOCATE (RXPLT, SLENG)

   END SELECT

   CLOSE (NA)

!  Formats ...
1000 FORMAT (a)
1001 FORMAT ("/")
1002 FORMAT ("AMX_VERSION=", i2.2, ".", i2.2, 2x, "PROGRAM_NAME:", a)
1003 FORMAT ("/", /, "/FILE_TYPE=", i2.2, /, "/FIELDS_FORMAT=", i2.2, /, "/")
1004 FORMAT ("/", /, "/SURVEY_TYPE=", a, /, "/SOURCE_TYPE=", a, /, "/")
1005 FORMAT ("/TX_TOTAL=", i3.3)
1006 FORMAT ("/TX", i3.3, "_COORDS(N,E,Z,M,Dip,Az)=", 6(f13.2, :, ", ", 2x))
1008 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_TYPE=", a)
1009 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_UNITS=", 3(a, :, ","))
1011 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_RXN", i3.3, "_PARAMS(N,E,Z,M,Dip,Az)=", 6(f13.2, :, ", "))
1012 FORMAT (a, 2x, 512(f13.2, :, ", "))
1014 FORMAT (2x, i6, 3(2x, i4), 5(2x, f13.2), 2x, a2, 2x, a3, 2x, i4)
1015 FORMAT (512(:, 2x, e15.6))
1018 FORMAT (2x, i6, a3, 3(2x, i4), 5(2x, f13.2), 2x, a2, 2x, a3, 2x, i4)
1020 FORMAT ("/NORMALISATION=", a)
1021 FORMAT ("/PRIMARY_FIELD_AXIAL(pT)=", en13.4, /, &
             "/PRIMARY_FIELD_SLOPE(pT)=", en13.4, /, &
             "/PRIMARY_FIELD_HORIZONTAL(pT)=", en13.4, /, &
             "/PRIMARY_FIELD_TOTAL(pT)=", en13.4)
1022 FORMAT ("/Normalising ", a, " component by ", a, " primary field")

  END SUBROUTINE WRITE_FAMX_PPM
!--------------

 SUBROUTINE FEM_PERC(NFRQ, NSTNS, NUM, DEN, PRC)
!-----------------------------------------------

!  Sub. designed to compute 100. * (num / den)

!  Calls:      none
!  Called by:  wrt_famx

!  Notes.
!  1.  for denominator values less than 1e-20, prc is set to 0.
!  2.  note use of array masks

!  Input
!      nfrq    first array dimension
!      nstns   second array dimension
!      num     numerator   (typically scattered field in caller)
!      den     denominator (typically total field in caller)

!  Output
!      prc     100. * num / den  |den| >= tol
!              0                 |den| <  tol

   IMPLICIT NONE

   INTEGER, INTENT (IN) :: NFRQ, NSTNS

   COMPLEX, INTENT (IN) ::  NUM(NFRQ, NSTNS)
   COMPLEX, INTENT (IN) ::  DEN(NFRQ, NSTNS)
   COMPLEX, INTENT (OUT) :: PRC(NFRQ, NSTNS)

   REAL, PARAMETER :: TOL = 1.E-20
   REAL :: OUT_ZERO(NFRQ, NSTNS)
   REAL :: OUT_REAL(NFRQ, NSTNS)
   REAL :: OUT_IMAG(NFRQ, NSTNS)

   OUT_ZERO = TOL

   WHERE (ABS(DEN) <= OUT_ZERO)
     OUT_REAL = 0.
     OUT_IMAG = 0.
   ELSEWHERE
     OUT_REAL =  REAL(NUM(1: NFRQ, 1: NSTNS)) /  REAL(DEN(1: NFRQ, 1: NSTNS))
     OUT_IMAG = AIMAG(NUM(1: NFRQ, 1: NSTNS)) / AIMAG(DEN(1: NFRQ, 1: NSTNS))
   END WHERE

   PRC = 100. * CMPLX(OUT_REAL, OUT_IMAG)

   RETURN

 END SUBROUTINE FEM_PERC
!--------------

 SUBROUTINE WFAMX_HEADER(NA, OUTPUT, NOUT)
!-----------------------------------------------

!  Sub. writes AMX file column headers for FEM files

!   Calls:      none
!   Called by:  wrt_famx

!  Input
!    na       output unit
!    output   10 => total only (flat)
!             11 => total + scattered + % (flat)
!             20 => total only (blocked)
!             21 => total + scattered + % (blocked)
!    nout     # of data to write

!  Output
!       in file connected to unit na
!
!  Notes
!  1.   general nature of subroutine means that nout may be either nfrq or nstat
!       depending upon the setting of prfl.
!  2.   Data type indicators are appended (or not) depending upon detting of output
!       10, 11 => Append _TF, _TF, _SF, _PT
!       20, 21 => Do not append anything (blocked mode)

   IMPLICIT NONE

   INTEGER, INTENT (IN) :: NA, OUTPUT, NOUT
   INTEGER :: JO

   WRITE (NA, 1000, ADVANCE = "NO")
   WRITE (NA, 1002, ADVANCE = "NO")
   WRITE (NA, 1003, ADVANCE = "NO")
   WRITE (NA, 1005, ADVANCE = "NO") "NFrq"

   SELECT CASE (OUTPUT)
   CASE (10, 11)

       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "QFrq", JO, "_TF"
       END DO
       DO JO = 1, NOUT - 1
           WRITE (NA, 1004, ADVANCE = "NO")  "IFrq", JO, "_TF"
       END DO
       WRITE (NA, 1004, ADVANCE = "YES")   "IFrq", NOUT, "_TF"

   CASE (12)

       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "QFrq", JO, "_TF"
       END DO
       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "IFrq", JO, "_TF"
       END DO
       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "QFrq", JO, "_SF"
       END DO
       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "IFrq", JO, "_SF"
       END DO
       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "QFrq", JO, "_PT"
       END DO
       DO JO = 1, NOUT - 1
           WRITE (NA, 1004, ADVANCE = "NO")  "IFrq", JO, "_PT"
       END DO
       WRITE (NA, 1004, ADVANCE = "YES")   "IFrq", NOUT, "_PT"

   CASE (20, 21)

       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "QFrq", JO, "  "
       END DO
       DO JO = 1, NOUT - 1
           WRITE (NA, 1004, ADVANCE = "NO")  "IFrq", JO, "  "
       END DO
       WRITE (NA, 1004, ADVANCE = "YES")   "IFrq", NOUT, "   "

   CASE (22)

       DO JO = 1, NOUT
           WRITE (NA, 1004, ADVANCE = "NO")  "QFrq", JO, "  "
       END DO
       DO JO = 1, NOUT - 1
           WRITE (NA, 1004, ADVANCE = "NO")  "IFrq", JO, "  "
       END DO
       WRITE (NA, 1004, ADVANCE = "YES")   "IFrq", NOUT, "   "

   END SELECT

   RETURN

1000 FORMAT ("Line", 2x, "TxGrp", 2x, "RxGrp", 2x, "Fid", 2x)
1002 FORMAT ("Dist", 2x, "Stn", 2x, "North", 2x, "East", 2x, "RxElev", 2x)
1003 FORMAT ("CMP", 2x, "RxType", 2x)
1004 FORMAT (2x, a, i3.3, a)
1005 FORMAT (a5, 2x)

 END SUBROUTINE WFAMX_HEADER
!--------------

 SUBROUTINE WRITE_TAMX(TITLE, &
               STEP, OUTPUT, SOURCE_TYPE, SURVEY_TYPE, &
               NCHNL, TMS, &
               NTXE, MXVRTX, N_VRTX, SXE, SXN, SXZ, SXDIP, SXAZ, SXMNT, &
               NRGTX, NRXG, RGTXID, NCMPG, PRTCMP, &
               LRX, MRX, NRX, MQVR, RX_TYPE, UNITS, &
               RXED, RXND, RXZD, RXDIP, RXAZ, RXMNT, CLCD, &
               BTD, BTD_SCAT)
!----------------------------------------------------------------------------------

!  Calls       wtamx_header
!              set_output_scaling
!              wamx_pos
!              wamx_cldist
!              tem_perc
!  Called by:  main

   IMPLICIT NONE

   INTEGER, PARAMETER :: AMX_MAJOR = 2
   INTEGER, PARAMETER :: AMX_MINOR = 0
   INTEGER, PARAMETER :: NA = 30
   INTEGER, PARAMETER :: MAX_TYP = 3
   INTEGER, PARAMETER :: MAX_RCT = 3
   INTEGER, PARAMETER :: MAX_CMP = 3
   INTEGER, PARAMETER :: MAX_SRC = 4
   INTEGER, PARAMETER :: LBASE = 10000
   INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 80)

   INTEGER, INTENT (IN) :: STEP, OUTPUT
   INTEGER, INTENT (IN) :: SOURCE_TYPE, SURVEY_TYPE
   INTEGER, INTENT (IN) :: NCHNL
   INTEGER, INTENT (IN) :: NTXE, MXVRTX
   INTEGER, INTENT (IN) :: N_VRTX(NTXE)
   INTEGER, INTENT (IN) :: NRXG, LRX, MRX, MQVR
   INTEGER, INTENT (IN) :: NRGTX(NTXE)
   INTEGER, INTENT (IN) :: NRX(NRXG), UNITS(NRXG), RX_TYPE(NRXG), NCMPG(NRXG)
   INTEGER, INTENT (IN) :: PRTCMP(10, NRXG)
   INTEGER, INTENT (IN) :: RGTXID(NRXG, NTXE)

   INTEGER :: JD, JG, JS, JV, JX, JR, JC, JC1
   INTEGER :: KA, KZ, KT, KG, KC, KV
   INTEGER :: N_CORNR, NLOC, STNS, N_PRFL

   REAL, PARAMETER :: RAD2DEG = (180. / 3.14159265)

   REAL (KIND = DP), INTENT (IN) :: RXED(MRX, NRXG, MQVR), RXND(MRX, NRXG, MQVR), RXZD(MRX, NRXG, MQVR), CLCD(MAX_CMP, NTXE)

   REAL (KIND = DP), ALLOCATABLE :: RXPLT(:, :)
   REAL (KIND = DP), ALLOCATABLE :: SLENG(:)

   REAL, INTENT (IN) :: TMS(NCHNL)
   REAL, INTENT (IN) :: SXE(MXVRTX, NTXE), SXN(MXVRTX, NTXE), SXZ(MXVRTX, NTXE)
   REAL, INTENT (IN) :: RXDIP(MRX, NRXG), RXAZ(MRX, NRXG), RXMNT(MRX, NRXG)
   REAL, INTENT (IN) :: SXDIP(NTXE), SXAZ(NTXE), SXMNT(NTXE)
   REAL, INTENT (IN) :: BTD(NCHNL, LRX, NTXE, MAX_CMP)
   REAL, INTENT (IN) :: BTD_SCAT(NCHNL, LRX, NTXE, MAX_CMP)

   REAL, ALLOCATABLE :: OUT_SCAT(:, :), OUT_HOLD(:, :)
   REAL, ALLOCATABLE :: OUT_TOTL(:, :), OUT_PERC(:, :)

   REAL :: OUT_SCALE(MRX, NRXG)

   CHARACTER (LEN = 05), PARAMETER :: PROG_NAME = "Marco"
   CHARACTER (LEN = 09), PARAMETER :: FILE_NAME = "Marco.amx"

   CHARACTER (LEN = 120), INTENT (IN) :: TITLE

   CHARACTER (LEN = 03) :: OUT_DTYPE(MAX_TYP)
   CHARACTER (LEN = 03) :: OUT_RXTYP2(MAX_RCT)
   CHARACTER (LEN = 03) :: OUT_COMP(10)
   CHARACTER (LEN = 04) :: OUT_UNITS(NRXG)
   CHARACTER (LEN = 15) :: OUT_RXTYP1(MAX_RCT)
   CHARACTER (LEN = 15) :: OUT_SURVEY(MAX_SRC)
   CHARACTER (LEN = 16) :: OUT_SOURCE(MAX_SRC + 1)

   DATA OUT_RXTYP2 / "MDP", "FLP", "EDP"/
   DATA OUT_SOURCE / "General_Loop    ", &
                   "Grounded_Wire   ", &
                   "Magnetic_Dipole ", &
                   "Magnetotellurics", &
                   "Coincident-loop "/
   DATA OUT_SURVEY / "Separate_Tx_Rx ", &
                   "Slingram       ", &
                   "Central_loop   ", &
                   "Coincident_loop" /
   DATA OUT_RXTYP1 / "Magnetic_dipole", &
                   "Finite_loop    ", &
                   "Electric_dipole"/
   DATA OUT_COMP   / " N", " E", " Z", &
                     "HR", "SL", "AX", &
                     "ED", "LP", " Z", " Z"/
   DATA OUT_DTYPE  /"_TF", "_SF", "_PT"/

!
!  End of declarations; code begins ...

!
!  Enfore profile output mode ...
   N_PRFL = 1

!
!  Open file & write std. header ...
   OPEN (UNIT = NA, FILE = FILE_NAME, STATUS = "REPLACE")

   WRITE (NA, 1000) TRIM(TITLE)
   WRITE (NA, 1002) AMX_MAJOR, AMX_MINOR, PROG_NAME
   CALL WTAMX_HEADER(NA, OUTPUT, NCHNL)

!
!  Determine output scaling factors & units...
   CALL SET_OUTPUT_SCALING (NRXG, MRX, SURVEY_TYPE, RX_TYPE, RXMNT, STEP, UNITS, OUT_SCALE, OUT_UNITS)

!
!  Write header blocks ...
   WRITE (NA, 1003) N_PRFL, OUTPUT
   WRITE (NA, 1004) OUT_SURVEY(SURVEY_TYPE), OUT_SOURCE(SOURCE_TYPE)

   SELECT CASE (SURVEY_TYPE)
   CASE (1)
     NLOC = MRX
     WRITE (NA, 1005) NTXE
     DO JS = 1, NTXE
       WRITE (NA, 1001)
       IF (SOURCE_TYPE == 3) WRITE (NA, 1006) JS, SXE(1, JS), SXN(1, JS), SXZ(1, JS), &
                                                  SXMNT(JS), RAD2DEG * SXDIP(JS), RAD2DEG * SXAZ(JS)
       IF (SOURCE_TYPE /= 3) WRITE (NA, 1007) JS, N_VRTX(JS), (SXE(JV, JS), SXN(JV, JS), SXZ(JV, JS), JV = 1, N_VRTX(JS))

!
!      Now Rx groups for current transmitter ...
       DO JG = 1, NRGTX(JS)
         WRITE (NA, 1001)
         KG = RGTXID(JG, JS)
         KT = RX_TYPE(KG)
         JX = NRX(KG)

         IF (KT == 1) N_CORNR = 1        ! dipole ...
         IF (KT == 2) N_CORNR = 4        ! loop ...
         IF (KT == 3) N_CORNR = 2        ! bipole ...

         ALLOCATE (RXPLT(3, NRX(KG)))
         ALLOCATE (SLENG(NRX(KG)))
         CALL WAMX_POS(0, MRX, NRXG, MQVR, JX, KG, N_CORNR, RXED, RXND, RXZD, RXPLT, SLENG, STNS)

         WRITE (NA, 1008) JS, JG, OUT_RXTYP1(KT)
         IF ((OUTPUT == 10) .OR. (OUTPUT == 20)) WRITE (NA, 1009) JS, JG, TRIM(OUT_UNITS(JG))
         IF ((OUTPUT == 11) .OR. (OUTPUT == 21)) WRITE (NA, 1009) JS, JG, TRIM(OUT_UNITS(JG)), &
                                                                          TRIM(OUT_UNITS(JG)), "%"
         WRITE (NA, 1010) JS, JG, JX

!
!        Receiver parameters for current group ...
         WRITE (NA, 1001)
         IF (KT == 1) THEN
           DO JR = 1, JX
             WRITE (NA, 1011) JS, JG, JR, RXED(JR, KG, 1), RXND(JR, KG, 1), RXZD(JR, KG, 1), &
                           RXMNT(JR, KG), RXDIP(JR, KG), RXAZ(JR, KG)
           END DO
         ELSE
           DO JR = 1, JX
             WRITE (NA, 1016) JS, JG, JR, N_CORNR, &
                           (RXED(JR, KG, KV), RXND(JR, KG, KV), RXZD(JR, KG, KV), KV = 1, N_CORNR)
           END DO
         END IF
         DEALLOCATE (RXPLT, SLENG)

       END DO
     END DO

!
!    Usually, we'd branch for Profile / temporal mode, but for multiple receivers per transmitters, there is
!    little point.  Instead, write times no matter the mode.
     WRITE (NA, 1001)
     WRITE (NA, 1012) "/TIMES(ms)=", TMS(1: NCHNL)

!
!    We are now(!) in a position to write data ...
     DO JS = 1, NTXE
       KA = 1
       DO JG = 1, NRGTX(JS)

         KG = RGTXID(JG, JS)
         KT = RX_TYPE(KG)
         JX = NRX(KG)
         KZ = (KA + JX) - 1

         IF (KT == 1) N_CORNR = 1        ! dipole ...
         IF (KT == 2) N_CORNR = 4        ! loop ...
         IF (KT == 3) N_CORNR = 2        ! bipole ...

!
!        Set up plotting points ...
         ALLOCATE (RXPLT(3, NRX(KG)))
         ALLOCATE (SLENG(NRX(KG)))
         CALL WAMX_POS(0, MRX, NRXG, MQVR, JX, KG, N_CORNR, RXED, RXND, RXZD, RXPLT, SLENG, STNS)

!
!        Loop over components ...
         DO JC = 1, NCMPG(JG)
           WRITE (NA, 1001)

!
!          Determine the component to write ...
           SELECT CASE (KT)
           CASE (1)                    ! dipole
               JC1 = PRTCMP(JC, KG)
               KC  = JC1
               IF (KC > 3) KC = KC - 3
           CASE (2)                    ! loop
               KC  = 1
               JC1 = 8
           CASE (3)                    ! bipole
               KC  = 1
               JC1 = 7
           END SELECT

!
!          Fill output arrays & calculate percentage-target effect ...
           ALLOCATE (OUT_TOTL(NCHNL, JX + 1), OUT_HOLD(NCHNL, JX + 1))
           ALLOCATE (OUT_SCAT(NCHNL, JX + 1), OUT_PERC(NCHNL, JX + 1))

           OUT_TOTL(1: NCHNL, 1: JX) = BTD(1: NCHNL, KA: KZ, JS, KC)
           OUT_SCAT(1: NCHNL, 1: JX) = BTD_SCAT(1: NCHNL, KA: KZ, JS, KC)

           DO JR = 1, JX
             OUT_TOTL(1: NCHNL, JR) = OUT_TOTL(1: NCHNL, JR) * SXMNT(JS) * OUT_SCALE(JR, KG)
             OUT_SCAT(1: NCHNL, JR) = OUT_SCAT(1: NCHNL, JR) * SXMNT(JS) * OUT_SCALE(JR, KG)
           END DO
           CALL TEM_PERC(NCHNL, JX, OUT_SCAT, OUT_TOTL, OUT_PERC)

!
!          Write data ...
           DO JR = 1, JX

               SELECT CASE (OUTPUT)
               CASE (10, 11)

                   WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), JS, JG, JR, &
                                                   SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(KT), NCHNL

                   WRITE (NA, 1015, ADVANCE = "YES") OUT_TOTL(1: NCHNL, JR)

               CASE (12)

                   WRITE (NA, 1014, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), JS, JG, JR, &
                                                   SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(KT), NCHNL

                   WRITE (NA, 1015, ADVANCE = "NO")  OUT_TOTL(1: NCHNL, JR)
                   WRITE (NA, 1015, ADVANCE = "NO")  OUT_SCAT(1: NCHNL, JR)
                   WRITE (NA, 1015, ADVANCE = "YES") OUT_PERC(1: NCHNL, JR)

               CASE (20, 21)

                   WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), "_TF", &
                                                   JS, JG, JR, &
                                                   SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(KT), NCHNL

                   WRITE (NA, 1015, ADVANCE = "YES") OUT_TOTL(1: NCHNL, JR)

               END SELECT

           END DO

           DEALLOCATE (OUT_TOTL, OUT_HOLD)
           DEALLOCATE (OUT_SCAT, OUT_PERC)

         END DO

!
!        Special case of output == 21 (blocked mode, all data).  We need this because of the requirement to group
!        all data of a certain type together.  Without the special case, we get the different types printed at the
!        same station and this makes the file quite difficult to process
         IF (OUTPUT == 22) THEN
           DO JD = 1, MAX_TYP
             WRITE (NA, 1001)
             DO JC = 1, NCMPG(JG)
               WRITE (NA, 1001)
!
!              Determine the component to write ...
               SELECT CASE (KT)
               CASE (1)                    ! dipole
                   JC1 = PRTCMP(JC, KG)
                   KC  = JC1
                   IF (KC > 3) KC = KC - 3
               CASE (2)                    ! loop
                   KC  = 1
                   JC1 = 8
               CASE (3)                    ! bipole
                   KC  = 1
                   JC1 = 7
               END SELECT

!
!              Fill output arrays & calculate percentage-target effect ...
               ALLOCATE (OUT_TOTL(NCHNL, JX), OUT_HOLD(NCHNL, JX))
               ALLOCATE (OUT_SCAT(NCHNL, JX), OUT_PERC(NCHNL, JX))

               OUT_TOTL(1: NCHNL, 1: JX) = SXMNT(JS) * BTD(1: NCHNL, KA: KZ, JS, KC)
               OUT_SCAT(1: NCHNL, 1: JX) = SXMNT(JS) * BTD_SCAT(1: NCHNL, KA: KZ, JS, KC)

               DO JR = 1, NLOC
                 OUT_TOTL(1: NCHNL, JR) = OUT_TOTL(1: NCHNL, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
                 OUT_SCAT(1: NCHNL, JR) = OUT_SCAT(1: NCHNL, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
               END DO
               CALL TEM_PERC(NCHNL, NLOC, OUT_SCAT, OUT_TOTL, OUT_PERC)

               IF (JD == 1) OUT_HOLD = OUT_TOTL
               IF (JD == 2) OUT_HOLD = OUT_SCAT
               IF (JD == 3) OUT_HOLD = OUT_PERC

               DO JR = 1, JX
                   WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 1000 * JS + 10 * JG), OUT_DTYPE(JD), &
                                                   JS, JG, JR, &
                                                   SLENG(JR), RXPLT(STNS, JR), RXPLT(1, JR), RXPLT(2, JR), RXPLT(3, JR), &
                                                   OUT_COMP(JC1), OUT_RXTYP2(KT), NCHNL

                   WRITE (NA, 1015, ADVANCE = "YES")  OUT_HOLD(1: NCHNL, JR)
               END DO

               DEALLOCATE (OUT_TOTL, OUT_HOLD)
               DEALLOCATE (OUT_SCAT, OUT_PERC)

             END DO
           END DO
         END IF

         DEALLOCATE (RXPLT, SLENG)
         KA = KZ + 1

       END DO
     END DO


   CASE DEFAULT
     NLOC = NTXE
     JG = 1; KT = 1

!
!    Write transmitter parameters ....
     WRITE (NA, 1005) NLOC
     WRITE (NA, 1001)
     SELECT CASE (SOURCE_TYPE)
     CASE (3)
       DO JS = 1, NTXE
         WRITE (NA, 1006) JS, SXE(1, JS), SXN(1, JS), SXZ(1, JS), SXMNT(JS), RAD2DEG * SXDIP(JS), RAD2DEG * SXAZ(JS)
       END DO
     CASE DEFAULT
       DO JS = 1, NTXE
         WRITE (NA, 1007) JS, N_VRTX(JS), (SXE(JV, JS), SXN(JV, JS), SXZ(JV, JS), JV = 1, N_VRTX(JS))
       END DO
     END SELECT

!
!    Write receiver parameters ...
     WRITE (NA, 1001)
     IF (SURVEY_TYPE /= 4) WRITE (NA, 1008)  1, JG, OUT_RXTYP1(KT)
     IF (SURVEY_TYPE == 4) WRITE (NA, 1008)  1, JG, OUT_SURVEY(4)
     IF ((OUTPUT == 12) .OR. (OUTPUT == 22)) THEN
       WRITE (NA, 1009) 1, JG, TRIM(OUT_UNITS(JG)), TRIM(OUT_UNITS(JG)), "%"
     ELSE
       WRITE (NA, 1009) 1, JG, TRIM(OUT_UNITS(JG))
     END IF
     WRITE (NA, 1010)                        1, JG, NLOC

!
!    Write receiver parameters in header section ...
     ALLOCATE (RXPLT(3, NLOC))
     ALLOCATE (SLENG(NLOC))
     DO JR = 1, NLOC
       SELECT CASE (SURVEY_TYPE)
       CASE (4)

         WRITE (NA, 1020) 1, JG, JR, &
                         CLCD(1, JR), CLCD(2, JR), CLCD(3, JR)
                         RXPLT(1: 3, JR) = CLCD(1: 3, JR)

       CASE DEFAULT        ! 2 OR 3

         WRITE (NA, 1011) 1, JG, JR, &
                         RXED(1, JR, 1), RXND(1, JR, 1), RXZD(1, JR, 1), &
                         RXMNT(JR, 1), RXDIP(JR, 1), RXAZ(JR, 1)

       END SELECT
     END DO

!
!    Determine Rx plotting points ...
     IF (SURVEY_TYPE /= 4) CALL WAMX_POS(1, MRX, NRXG, MQVR, NLOC, JG, N_CORNR, RXED, RXND, RXZD, RXPLT, SLENG, STNS)
     IF (SURVEY_TYPE == 4) CALL WAMX_CLDIST(NLOC, RXPLT, SLENG, STNS)

     WRITE (NA, 1001)
     WRITE (NA, 1012) "/TIMES(ms)=", TMS(1: NCHNL)

!
!    Completed writing header section; start on data ...
     DO JC = 1, NCMPG(1)
       WRITE (NA, 1001)
       IF ((RX_TYPE(1) > 1) .OR. (SURVEY_TYPE == 4)) THEN
         KC = 1
         JC1 = 7
       ELSE
         JC1 = PRTCMP(JC, 1)
         KC = JC1
         IF (KC > 3) KC = KC - 3
       END IF

!
!      Fill output arrays & calculate percentage-target effect ...
       ALLOCATE (OUT_TOTL(NCHNL, NLOC), OUT_HOLD(NCHNL, NLOC))
       ALLOCATE (OUT_SCAT(NCHNL, NLOC), OUT_PERC(NCHNL, NLOC))

       OUT_TOTL(1: NCHNL, 1: NLOC) =  BTD(1: NCHNL, 1: NLOC, 1, KC)
       OUT_SCAT(1: NCHNL, 1: NLOC) =  BTD_SCAT(1: NCHNL, 1: NLOC, 1, KC)

       DO JR = 1, NLOC
         OUT_TOTL(1: NCHNL, JR) = OUT_TOTL(1: NCHNL, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
         OUT_SCAT(1: NCHNL, JR) = OUT_SCAT(1: NCHNL, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
       END DO

       CALL TEM_PERC(NCHNL, NLOC, OUT_SCAT, OUT_TOTL, OUT_PERC)

       DO JS = 1, NLOC

           SELECT CASE (OUTPUT)
           CASE (10, 11)

               WRITE (NA, 1014, ADVANCE = "NO") LBASE, 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NCHNL

               WRITE (NA, 1015, ADVANCE = "YES") OUT_TOTL(1: NCHNL, JS)

           CASE (12)

               WRITE (NA, 1014, ADVANCE = "NO") LBASE, 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NCHNL

               WRITE (NA, 1015, ADVANCE = "NO")  OUT_TOTL(1: NCHNL, JS)
               WRITE (NA, 1015, ADVANCE = "NO")  OUT_SCAT(1: NCHNL, JS)
               WRITE (NA, 1015, ADVANCE = "YES") OUT_PERC(1: NCHNL, JS)

           CASE (20, 21)

               WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 10 * JG), "_TF", 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NCHNL

               WRITE (NA, 1015, ADVANCE = "YES") OUT_TOTL(1: NCHNL, JS)

           END SELECT

       END DO

       DEALLOCATE (OUT_TOTL, OUT_SCAT)
       DEALLOCATE (OUT_PERC, OUT_HOLD)

     END DO

!
!    Special case of output == 21 (blocked mode, all data).  We need this because of the requirement to group
!    all data of a certain type together.  Without the special case, we get the different types printed at the
!    same station and this makes the file quite difficult to process
     IF (OUTPUT == 22) THEN
       DO JD = 1, MAX_TYP
         WRITE (NA, 1001)
         DO JC = 1, NCMPG(1)
           WRITE (NA, 1001)
           IF ((RX_TYPE(1) > 1) .OR. (SURVEY_TYPE == 4)) THEN
             KC = 1
             JC1 = 7
           ELSE
             JC1 = PRTCMP(JC, 1)
             KC = JC1
             IF (KC > 3) KC = KC - 3
           END IF

!
!          Fill output arrays & calculate percentage-target effect ...
           ALLOCATE (OUT_TOTL(NCHNL, NLOC), OUT_HOLD(NCHNL, NLOC))
           ALLOCATE (OUT_SCAT(NCHNL, NLOC), OUT_PERC(NCHNL, NLOC))

           OUT_TOTL(1: NCHNL, 1: NLOC) =  BTD(1: NCHNL, 1: NLOC, 1, KC)
           OUT_SCAT(1: NCHNL, 1: NLOC) =  BTD_SCAT(1: NCHNL, 1: NLOC, 1, KC)

           DO JR = 1, NLOC
             OUT_TOTL(1: NCHNL, JR) = OUT_TOTL(1: NCHNL, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
             OUT_SCAT(1: NCHNL, JR) = OUT_SCAT(1: NCHNL, JR) * SXMNT(1) * OUT_SCALE(JR, 1)
           END DO

           CALL TEM_PERC(NCHNL, NLOC, OUT_SCAT, OUT_TOTL, OUT_PERC)

           IF (JD == 1) OUT_HOLD = OUT_TOTL
           IF (JD == 2) OUT_HOLD = OUT_SCAT
           IF (JD == 3) OUT_HOLD = OUT_PERC

           DO JS = 1, NLOC
               WRITE (NA, 1018, ADVANCE = "NO") (LBASE + 10 * JG), OUT_DTYPE(JD), 1, 1, JS, &
                                               SLENG(JS), RXPLT(STNS, JS), RXPLT(1, JS), RXPLT(2, JS), RXPLT(3, JS), &
                                               OUT_COMP(JC1), OUT_RXTYP2(1), NCHNL

               WRITE (NA, 1015, ADVANCE = "YES") OUT_HOLD(1: NCHNL, JS)

           END DO

           DEALLOCATE (OUT_TOTL, OUT_HOLD)
           DEALLOCATE (OUT_SCAT, OUT_PERC)

         END DO

       END DO
     END IF

     DEALLOCATE (RXPLT, SLENG)

   END SELECT

   CLOSE (NA)

1000 FORMAT (a)
1001 FORMAT ("/")
1002 FORMAT ("AMX_VERSION=", i2.2, ".", i2.2, 2x, "PROGRAM_NAME:", a)
1003 FORMAT ("/", /, "/FILE_TYPE=", i2.2, /, "/FIELDS_FORMAT=", i2.2, /, "/")
1004 FORMAT ("/", /, "/SURVEY_TYPE=", a, /, "/SOURCE_TYPE=", a, /, "/")
1005 FORMAT ("/TX_TOTAL=", i3.3)
1006 FORMAT ("/TX", i3.3, "_COORDS(N,E,Z,M,Dip,Az)=", 6(f13.2, :, ", ", 2x))
1007 FORMAT ("/TX", i3.3, "_COORDS(NVRTxN,E,Z)=", i2.2, ", ", 256(f13.2, ", ", f13.2, ", ", f13.2, :, ", "))
1008 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_TYPE=", a)
1009 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_UNITS=", 3(a, :, ","))
1010 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_NUMBER=", i3.3)
1011 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_RXN", i3.3, "_PARAMS(N,E,Z,M,Dip,Az)=", 6(f13.2, :, ", "))
1012 FORMAT (a, 2x, 512(f13.2, :, ", "))
1014 FORMAT (2x, i6, 3(2x, i4), 5(2x, f13.2), 2x, a2, 2x, a3, 2x, i4)
1015 FORMAT (512(:, 2x, e15.6))
1016 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_RXN", i3.3, "_PARAMS(nv,Nv,Ev,Zv)=", &
             i2.2, ", ", 4(f13.2, ", ", f13.2, ", ", f13.2, :, ", "))
1018 FORMAT (2x, i6, a3, 2x, 3(2x, i4), 5(2x, f13.2), 2x, a2, 2x, a3, 2x, i4)
1020 FORMAT ("/TX", i3.3, "_RXGroup", i3.3, "_RXN", i3.3, "_PARAMS(N,E,Z)=", 3(f13.2, :, ", "))

 END SUBROUTINE WRITE_TAMX
!--------------

 SUBROUTINE TEM_PERC(NCHNL, NSTNS, NUM, DEN, PRC)
!-----------------------------------------------

!  Sub. designed to compute 100. * (num / den)

!  Calls:      none
!  Called by:  wrt_tamx

!  Notes.
!  1.  for denominator values less than 1e-20, prc is set to 0.
!  2.  note use of array masks

!  Input
!      nchnl   first array dimension
!      nstns   second array dimension
!      num     numerator   (typically scattered field in caller)
!      den     denominator (typically total field in caller)

!  Output
!      prc     100. * num / den  |den| >= tol
!              0                 |den| <  tol

   IMPLICIT NONE

   INTEGER, INTENT (IN) :: NCHNL, NSTNS

   REAL, INTENT (IN) ::  NUM(NCHNL, NSTNS)
   REAL, INTENT (IN) ::  DEN(NCHNL, NSTNS)
   REAL, INTENT (OUT) :: PRC(NCHNL, NSTNS)

   REAL, PARAMETER :: TOL = 1.E-20
   REAL :: OUT_ZERO(1: NCHNL, 1: NSTNS)
   REAL :: OUT_TOTL(1: NCHNL, 1: NSTNS)

   OUT_ZERO = TOL

   WHERE (ABS(DEN) <= OUT_ZERO)
     OUT_TOTL = 0.
   ELSEWHERE
     OUT_TOTL =  NUM(1: NCHNL, 1: NSTNS) /  DEN(1: NCHNL, 1: NSTNS)
   END WHERE

   PRC = 100. * OUT_TOTL

   RETURN

 END SUBROUTINE TEM_PERC
!--------------

 SUBROUTINE WAMX_CLDIST(NLOC, RXPLT, SLENG, STNS)
!------------------------------------------------

!  Sub. designed to calculate dominate distance for CL surveys ...

!  Calls:      none
!  Called by:  wrt_tamx

!  Input
!      nloc    # survey locations
!      rxplt   survey coordinates

!  Output
!      stns    dimension of most rapidly varying index in rxplt

!  InOut
!      sleng   distance along survey

   IMPLICIT NONE

   INTEGER, PARAMETER :: MAX_COMP = 3
   INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 80)

   INTEGER, INTENT (IN) :: NLOC
   INTEGER, INTENT (OUT) :: STNS
   INTEGER :: JR

   REAL (KIND = DP), INTENT (IN) :: RXPLT(MAX_COMP, NLOC)
   REAL (KIND = DP)              :: DIST(MAX_COMP)

   REAL (KIND = DP), INTENT (INOUT) :: SLENG(NLOC)
   REAL (KIND = DP) :: DS


   DIST = MAXVAL(TRANSPOSE(RXPLT), DIM = 1) - MINVAL( TRANSPOSE(RXPLT), DIM = 1)
   IF ((DIST(1) > DIST(2)) .AND. (DIST(1) > DIST(3))) THEN
     STNS = 1                                                    ! northings
   ELSE IF ((DIST(3) > DIST(1)) .AND. (DIST(3) > DIST(2))) THEN
     STNS = 3                                                    ! vertical
   ELSE
     STNS = 2                                                    ! easting by default
   END IF

!
!  Calculate distance along traverse
   SLENG = 0.
   DO JR = 2, NLOC
     DS = (RXPLT(1, JR) - RXPLT(1, JR - 1))**2 + &
          (RXPLT(2, JR) - RXPLT(2, JR - 1))**2 + &
          (RXPLT(3, JR) - RXPLT(3, JR - 1))**2
     SLENG(JR) = SQRT(DS) + SLENG(JR - 1)
   END DO

   RETURN

 END SUBROUTINE WAMX_CLDIST

!--------------

 SUBROUTINE WAMX_POS(MODE, MRX, NRXG, MQVR, JX, JG, N_CORNR, RXED, RXND, RXZD, RXPLT, SLENG, STNS)
!-------------------------------------------------------------------------------------------------

!  Sub. designed to encapsulate details of calculating plotting position for general loops & di(bi)poles

!  Called by: WRT_FAMX, WRT_TAMX
!  Calls    : None

!  Input
!      mode                0 => general loops; 1 => in loop
!      mrx                 max. # rx
!      nrxg                # rx groups
!      mqvr                max. # verticies
!      jx                  # rx in current group
!      jg                  # of current group
!      n_cormr             # corners
!      rxed, rxnd, rxzd    East, North & vertical rx coordinates

!  Output
!      stns    index to use as stns

!  InOut
!      rxplt(In)   allocated array (initialised in THIS routine)
!          (out)   simplified coords for plotting
!      sleng(In)   initialised
!          (out)   length along survey (esp. for DDH work)

   IMPLICIT NONE

   INTEGER, PARAMETER :: MAX_COMP = 3
   INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 80)

   INTEGER, INTENT (IN)  :: MODE
   INTEGER, INTENT (IN)  :: MRX, NRXG, MQVR
   INTEGER, INTENT (IN)  :: JG, JX, N_CORNR
   INTEGER, INTENT (OUT) :: STNS

   INTEGER :: JR

   REAL (KIND = DP), INTENT (IN)    :: RXED(MRX, NRXG, MQVR)
   REAL (KIND = DP), INTENT (IN)    :: RXND(MRX, NRXG, MQVR)
   REAL (KIND = DP), INTENT (IN)    :: RXZD(MRX, NRXG, MQVR)

   REAL (KIND = DP), INTENT (INOUT) :: RXPLT(MAX_COMP, JX)
   REAL (KIND = DP), INTENT (INOUT) :: SLENG(JX)

   REAL (KIND = DP) :: DIST(MAX_COMP)
   REAL (KIND = DP) :: DS

   RXPLT = 0.

   SELECT CASE (MODE)
   CASE (0)
     DO JR = 1, JX
       RXPLT(1, JR) = SUM(RXND(JR, JG, 1: N_CORNR)) / REAL(N_CORNR, DP)
       RXPLT(2, JR) = SUM(RXED(JR, JG, 1: N_CORNR)) / REAL(N_CORNR, DP)
       RXPLT(3, JR) = SUM(RXZD(JR, JG, 1: N_CORNR)) / REAL(N_CORNR, DP)
     END DO
   CASE (1)
     DO JR = 1, JX
       RXPLT(1, JR) = RXND(1, JR, 1)
       RXPLT(2, JR) = RXED(1, JR, 1)
       RXPLT(3, JR) = RXZD(1, JR, 1)
     END DO
   END SELECT

!
!  Select index to plot as station ...
   DIST = MAXVAL (TRANSPOSE (RXPLT), DIM = 1) - MINVAL (TRANSPOSE (RXPLT), DIM = 1)
   IF ((DIST(1) > DIST(2)) .AND. (DIST(1) > DIST(3))) THEN
     STNS = 1                                                       ! northings
   ELSE IF ((DIST(3) > DIST(1)) .AND. (DIST(3) > DIST(2))) THEN
     STNS = 3                                                       ! vertical
   ELSE
     STNS = 2                                                       ! easting by default
   END IF

!
!  Calculate distance along traverse
   SLENG = 0.
   DO JR = 2, JX
     DS = (RXPLT(1, JR) - RXPLT(1, JR - 1))**2 + &
          (RXPLT(2, JR) - RXPLT(2, JR - 1))**2 + &
          (RXPLT(3, JR) - RXPLT(3, JR - 1))**2
     SLENG(JR) = SQRT(DS) + SLENG(JR - 1)
   END DO

   RETURN

 END SUBROUTINE WAMX_POS
!--------------

 SUBROUTINE WTAMX_HEADER(NA, OUTPUT, NOUT)
!--------------------------------------------

!  Sub. writes AMX file column headers for TEM files

!   Calls:      none
!   Called by:  wrt_famx

!  Input
!    na       output unit
!    output   10 => total only (flat)
!             11 => total + scattered + % (flat)
!             20 => total only (blocked)
!             21 => total + scattered + % (blocked)
!    nout     # of data to write

!  Output
!       in file connected to unit na
!
!  Notes
!  1.   general nature of subroutine means that nout may be either nfrq or nstat
!       depending upon the setting of prfl.
!  2.   Data type indicators are appended (or not) depending upon detting of output
!       10, 11 => Append _TF, _TF, _SF, _PT
!       20, 21 => Do not append anything (blocked mode)

   IMPLICIT NONE

   INTEGER, INTENT (IN) :: NA, OUTPUT, NOUT
   INTEGER :: JO

   WRITE (NA, 1000, ADVANCE = "NO")
   WRITE (NA, 1002, ADVANCE = "NO")
   WRITE (NA, 1003, ADVANCE = "NO")
   WRITE (NA, 1005, ADVANCE = "NO") "NChnl"

   SELECT CASE (OUTPUT)
   CASE (10, 11)

     DO JO = 1, NOUT - 1
       WRITE (NA, 1004, ADVANCE = "NO")  "Chn", JO, "_TF"
     END DO
     WRITE (NA, 1004, ADVANCE = "YES")   "Chn", NOUT, "_TF"

   CASE (12)

     DO JO = 1, NOUT
       WRITE (NA, 1004, ADVANCE = "NO")  "Chn", JO, "_TF"
     END DO
     DO JO = 1, NOUT
       WRITE (NA, 1004, ADVANCE = "NO")  "Chn", JO, "_SF"
     END DO
     DO JO = 1, NOUT - 1
       WRITE (NA, 1004, ADVANCE = "NO")  "Chn", JO, "_PT"
     END DO
     WRITE (NA, 1004, ADVANCE = "YES")   "Chn", NOUT, "_PT"

   CASE (20, 21)

     DO JO = 1, NOUT - 1
       WRITE (NA, 1004, ADVANCE = "NO")  "Chn", JO, "   "
     END DO
     WRITE (NA, 1004, ADVANCE = "YES")   "Chn", NOUT, "   "

   CASE (22)

     DO JO = 1, NOUT - 1
       WRITE (NA, 1004, ADVANCE = "NO")  "Chn", JO, "   "
     END DO
     WRITE (NA, 1004, ADVANCE = "YES")   "Chn", NOUT, "   "

   END SELECT

   RETURN

1000 FORMAT ("Line", 2x, "TxGrp", 2x, "RxGrp", 2x, "Fid", 2x)
1002 FORMAT ("Dist", 2x, "Stn", 2x, "North", 2x, "East", 2x, "RxElev", 2x)
1003 FORMAT ("CMP", 2x, "RxType", 2x)
1004 FORMAT (2x, a, i3.3, a)
1005 FORMAT (a5, 2x)

 END SUBROUTINE WTAMX_HEADER
!--------------

 SUBROUTINE SET_OUTPUT_SCALING (NRXG, MRX, SURVEY_TYPE, RX_TYPE, RXMNT, STEP, UNITS, OUT_SCALE, OUT_UNITS)
!---------------------------------------------------------------------------------------------------------

!  Sub. is a neatened version of set_output_factors.

!  Calls:       none
!  Called by:   wrt_famx
!              wrt_tamx

!  Input
!      nrxg         # receiver groups
!      mrx              max # receivers
!      survey_type      cf. entry notes
!      rx_type      cf. entry notes
!      rxmnt        receiver moments
!      step         step / otherwise
!      units        cf. entry notes

!  Output
!      out_scale   total scalling to be applied to output data
!      out_units   textual SI units for outut

!  Notes
!  1.  sub written to minimise changes in existing code; since AMIRA format is no longer
!      used, the orginial set_output_factors could easily be replaced with this version

   IMPLICIT NONE

   INTEGER, INTENT (IN) :: NRXG, MRX, SURVEY_TYPE, STEP
   INTEGER, INTENT (IN) :: RX_TYPE(NRXG), UNITS(NRXG)
   INTEGER :: JG

   REAL, INTENT (IN)  :: RXMNT(MRX, NRXG)
   REAL, INTENT (OUT) :: OUT_SCALE(MRX, NRXG)

   CHARACTER (LEN = 04), INTENT (OUT) :: OUT_UNITS(NRXG)

   DO JG = 1, NRXG

     IF ((SURVEY_TYPE == 4) .OR. (RX_TYPE(JG) > 1)) THEN

       SELECT CASE (UNITS(JG))
       CASE (1)
         OUT_SCALE(1: MRX, JG) = 1.
         OUT_UNITS(JG) = "V   "
       CASE (2)
         OUT_SCALE(1: MRX, JG) = 1.E3
         OUT_UNITS(JG) = "mV  "
       CASE (3)
         OUT_SCALE(1: MRX, JG) = 1.E6
         OUT_UNITS(JG) = "uV  "
       CASE (4)
         OUT_SCALE(1: MRX, JG) = 1.E9
         OUT_UNITS(JG) = "nV  "
       END SELECT

     ELSE IF ((STEP == 0) .AND. (RX_TYPE(JG) == 1)) THEN

       SELECT CASE (UNITS(JG))
       CASE (1)
         OUT_SCALE(1: MRX, JG) = 1.E9
         OUT_UNITS(JG) = "nT/s"
       CASE (2)
         OUT_SCALE(1: MRX, JG) = 1.E12
         OUT_UNITS(JG) = "pT/s"
       CASE (3)
         OUT_SCALE(1: MRX, JG) = 1.E6 * RXMNT(1: MRX, JG)
         OUT_UNITS(JG) = "uV  "
       CASE (4)
         OUT_SCALE(1: MRX, JG) = 1.E9 * RXMNT(1: MRX, JG)
         OUT_UNITS(JG) = "nV  "

       END SELECT
     ELSE IF ((STEP == 1) .AND. (RX_TYPE(JG) == 1)) THEN

       SELECT CASE (UNITS(JG))
       CASE (1)
         OUT_SCALE(1: MRX, JG) = 1.E9
         OUT_UNITS(JG) = "nT  "
       CASE (2)
         OUT_SCALE(1: MRX, JG) = 1.E12
         OUT_UNITS(JG) = "pT  "
       CASE (3)
         OUT_SCALE(1: MRX, JG) = 1.E15
         OUT_UNITS(JG) = "fT  "
       END SELECT

     END IF

   END DO

   RETURN

 END SUBROUTINE SET_OUTPUT_SCALING

!=================================================
!  End of extended AMIRA format routines: Marco
!=================================================


 SUBROUTINE MARCO_3D (NW,DO3D,NFRQ,FREQ,SURVEY_TYPE,SOURCE_TYPE,NTXE,MXVRTX,N_VRTX, &
                      SXE,SXN,SXZ,SXDIP,SXAZ,NRXG,NRGTX,RX_TYPE,RGTXID,NRXTX,NRX,   &
                      MRX,LRX,MQVR,RXE,RXN,RXZ,NLYR,THK,RES,RMU,REPS,CHRG,CTAU,     &
                      CFREQ,KSYMM,NPRISM,PRISM_ZMID,PRISM_EAST,PRISM_NORTH,         &
                      PRSM_SIZE_EW,PRSM_SIZE_NS,PRSM_SIZE_Z,NCELL_EW,NCELL_NS,      &
                      NCELL_Z,PRSM_RES,RMUP,REPSP,PRSM_CHRG,PRSM_TAU,PRSM_CFR,      &
                      KACC,SOLVER,BFD,BFD_SCAT)
!------------------------------------------------------------------------------------

!  The computation assumes unit transmitter and receiver dipoles and MKS units
!  Conversion to user specified units and inclusion of transmitter and receiver
!  dipole moments happens in the output routines.

!                     INPUT
!                     -----
!            FREQ - array of NFRQ frequencies
!     SURVEY_TYPE - indicates loop (1), grounded wire (2), magnetic dipole(3) or
!                   plane wave sources (4)
!     SOURCE_TYPE - indicates loop (1), grounded wire (2), magnetic dipole(3) or
!                   plane wave sources (4)
!            NTXE - number of transmitter positions
!       N_VRTX(J) - number of vertices for tansmitter J
!          MXVRTX - maximum number of vertices for any tansmitter
!        SXE(I,J) = local east coordinate of vertex I for loop position J
!        SXN(I,J) = local coordinate of vertex I for loop position J
!        SXZ(I,J) = local (z positive down) depth of vertex I for loop position J
!        SXDIP(J) = dip (in radians) of dipole J (eg; vertical = 0, horizontal = 90)
!         SXAZ(J) = azimuth (in radians) of dipole J (north = 0, east = 90)
!            NRXG - number of receiver groups
!                 = 1 if SURVEY_TYPE > 1
!        NRGTX(J) - number of receiver groups for transmitter J
!                 = 1 if SURVEY_TYPE > 1
!      RX_TYPE(I) - for Rx group I: dipole (1), loop (2), grounded electrode (3)
!     RGTXID(I,J) - receiver group index for Ith group for transmitter J
!        NRXTX(J) -
!          NRX(J) - the number of receivers in receiver group J.  MRX = MAXVAL (NRX)
!                 = 1 if SURVEY_TYPE > 1
!             MRX - maximum number of receivers in any receiver group
!             LRX - maximum number of receivers assigned to any transmitter position
!                 = 1 if SURVEY_TYPE > 1
!            MQVR - maximum number of vertices for all receivers
!                 = 1 if all sources are magnetic dipoles)
!      RXE(J,I,K) = local east coordinate of the Kth vertex of the
!                   Jth receiver of receiver group I
!      RXE(J,I,K) = local north coordinate of vertex K of Rx J of Group I
!      RXZ(J,I,K) - depth (z is positive down) of vertex K of Rx J of Group I
!                 - K = 1 only for mag dipole Rx; 1 to 2 for electric dipole Rx; 1 to 4 for loop Rx
!
!            NLYR -
!             THK -
!             RES -
!             RMU -
!            REPS -
!            CHRG -
!            CTAU -
!           CFREQ -
!
!           KSYMM -
!          NPRISM -
!      PRISM_ZMID -
!      PRISM_EAST -
!     PRISM_NORTH -
!    PRSM_SIZE_EW -
!    PRSM_SIZE_NS -
!     PRSM_SIZE_Z -
!        NCELL_EW -
!        NCELL_NS -
!         NCELL_Z -
!        PRSM_RES -
!            RMUP -
!           REPSP -
!       PRSM_CHRG -
!        PRSM_TAU -
!        PRSM_CFR -
!
!                     OUTPUT
!                     ------
!    BFD_SCAT(JF,JR,JS,JC) - scattered frequency-domain component JC at receiver JR
!                            corresponding to source position JS, frequency JF.
!
!       If SURVEY_TYPE = 1,
!         For magnetic dipole receivers, BFD will be the frequency-domain magnetic field.
!           BFD_SCAT(*,*,*,1:3) contain the NORTH (1),  EAST (2), & VERTICAL(3)
!                       components respectively.
!
!         For loop of electric dipole receivers, BFD_SCAT(*,*,*,1) will be the frequency-
!                      domain voltage and BFD_SCAT(*,*,*,2:3) = (0,.0.)
!
!
!       If SURVEY_TYPE = 2 or 3 or 4, results are stored in BFD_SCAT(1, 1, 1:NTX, 1:3)

!       If SURVEY_TYPE = 4, results are stored in BFD_SCAT(1, 1, 1:NTX, 1)
!          As above, unless the receiver type is a magnetic dipole and CMP = 0,
!          all results will be stored in BFD_SCAT(1, 1, 1:NTX, 1)
!
 IMPLICIT NONE
!
!------ Input parameters from main program ---------------------
!
! -- System parameters
!
 LOGICAL, PARAMETER :: PRT_REF=.FALSE.
 INTEGER :: NW
 INTEGER NFRQ,SOURCE_TYPE,SURVEY_TYPE,NTXE,NRXG,MXVRTX,MQVR,MRX,LRX, &
         RGTXID(NRXG,NTXE)
 INTEGER, DIMENSION (NTXE) :: N_VRTX,NRGTX,NRXTX
 INTEGER, DIMENSION (NRXG) :: NRX,RX_TYPE
 REAL FREQ(NFRQ),SXDIP(NTXE),SXAZ(NTXE)
 REAL, DIMENSION (MXVRTX,NTXE) :: SXE, SXN, SXZ
 REAL, DIMENSION (MRX,NRXG,MQVR) :: RXE, RXN, RXZ
!
! -- Layered earth parameters
 INTEGER :: NLYR
 REAL :: THK(NLYR),RES(NLYR),CHRG(NLYR),CTAU(NLYR),                     &
         CFREQ(NLYR),RMU(NLYR),REPS(NLYR)
! -- 3D parameters
 INTEGER :: KACC,SOLVER,DO3D,KSYMM,                                     &
            NPRISM,NCELL_EW(NPRISM),NCELL_NS(NPRISM),NCELL_Z(NPRISM)
 REAL :: PRISM_EAST(NPRISM),PRISM_NORTH(NPRISM),PRISM_ZMID(NPRISM),     &
         PRSM_SIZE_EW(NPRISM),PRSM_SIZE_NS(NPRISM),PRSM_SIZE_Z(NPRISM), &
         PRSM_RES(NPRISM),RMUP(NPRISM),REPSP(NPRISM),PRSM_CHRG(NPRISM), &
         PRSM_TAU(NPRISM),PRSM_CFR(NPRISM)
!
!-------  Output parameter  --------------------------
!
 COMPLEX :: BFD_SCAT(NFRQ,LRX,NTXE,3),BFD(NFRQ,LRX,NTXE,3)
!
!------ Internal parameters for 3D (and 1D) computations ----------------
!
!-- Transmitter-receiver parameters for the internal computation of this program
!
 INTEGER :: SUB_RX_MAX,SUB_BIPOLE
 INTEGER, ALLOCATABLE, DIMENSION(:) :: N_RX
 REAL, ALLOCATABLE, DIMENSION(:,:)  :: MD_ANGLE
 REAL, ALLOCATABLE, DIMENSION(:,:)  :: TX_CRDX,TX_CRDY,TX_CRDZ
 REAL, ALLOCATABLE, DIMENSION(:,:,:) :: RX_X,RX_Y,RX_Z
 REAL, ALLOCATABLE, DIMENSION(:,:,:,:) :: RX_WEIGHT
 INTEGER, ALLOCATABLE :: RX_TYPE_INDEX(:,:),N_SUB_RX(:,:)

!
!
!-- Parameters for the 3D target
!
!-- Electric and magnetic components. P for 1D primasy field; S for 3D secondary fields
!
 COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: EPX,EPY,EPZ,HPX,HPY,HPZ,VOLTP,   &
                                           ESX,ESY,ESZ,HSX,HSY,HSZ,VOLTS
!
! -- Parameter E_ONLY is designed mostly for a 1D module for routine. Check
!    documentation in routine COMPUTE_3D for detailed descriptions.
!
 INTEGER, PARAMETER :: E_ONLY=0
!
! -- Parameter LOOP_INTEG_ACCURACY controls the accuracy of integrations of loop
!    receivers.  A n-sided polygonal receiver loop is divided into n triangles
!    for numerical integrations.
!
!    LOOP_INTEG_ACCURACY = 1: sampling at triangle centres is used to approximate
!                             the integration over the triangles.
!                          2: 4-point rules are used to approximate the integrations.
!
!    It is recommended to use the value of 2 for LOOP_INTEG_ACCURACY for better accuracy
!
!
 INTEGER, PARAMETER :: LOOP_INTEG_ACCURACY=2
!
 INTEGER :: JR,JF,JS,I,J
 REAL :: BIPOLE_LEN

!-- Convert input data to Marco working parameters
!
! --- Allocate working arrays for transmitters and receivers
!
 ALLOCATE(TX_CRDX(MXVRTX,NTXE),TX_CRDY(MXVRTX,NTXE),   &
          TX_CRDZ(MXVRTX,NTXE))
 ALLOCATE(MD_ANGLE(2,NTXE))

!
!    Initialise allocated arrays
!
 TX_CRDX=0.; TX_CRDY=0.; TX_CRDZ=0.; MD_ANGLE=0.
!
! -- Determine maximal number of sub-receivers.  Those are magnetic dipole
!    receivers for loops and sub-bipole sections for bipole receivers.
!
!
 IF (MQVR>=4.OR.SURVEY_TYPE==4) THEN
!  --    Use magentic dipole receivers for loops.
    IF (SURVEY_TYPE==4) MQVR=MXVRTX    !  Coincident loop use transmitters as receivers
    IF (LOOP_INTEG_ACCURACY==1) SUB_RX_MAX=MQVR
    IF (LOOP_INTEG_ACCURACY==2) SUB_RX_MAX=MQVR*2+1
 ELSE
    SUB_RX_MAX=MQVR
 END IF
!
! Divide bipole receivers into SUB_BIPOLE sub-receivers
!
! -- The following choice of sub-bipole length is best if all bipole receivers
!    have the same length.   Different values for SUB_BIPOLE may be needed for
!    bipole receivers with various lengths.  However, that would require an one-
!    dimensional array for SUB_BIPOLE.
!
!   Minimum of 5 sections or 10 m based length of largest dipole.
!
!   Find the maximal bipole separation
!
 BIPOLE_LEN = 0.
 IF (MAXVAL (RX_TYPE) > 2) THEN     !^^^^^^^^^^^^^^^^
   DO JS=1,NTXE                     !  Transmitter in use (from selected events)
      DO J=1,NRGTX(JS)              !  Receiver groups for transmitter JTX
         JR=RGTXID(J,JS)            !  Actual receiver group ID from input list
         IF (RX_TYPE(JR)==3) THEN   !   -- Electric bipole receivers only
            DO I=1,NRX(JR)          !  Actual receivers from input list
               BIPOLE_LEN = MAX(BIPOLE_LEN,                          &
                                SQRT((RXE(I,JR,1)-RXE(I,JR,2))**2 +  &
                                     (RXN(I,JR,1)-RXN(I,JR,2))**2 +  &
                                     (RXZ(I,JR,1)-RXZ(I,JR,2))**2))
            END DO
         END IF
      END DO
   END DO
 END IF  !^^^^^^^^^^^^^^^^

 SUB_BIPOLE=5+1                                          ! 5 sub-bipoles
 IF (BIPOLE_LEN/5.>10.) SUB_BIPOLE=NINT(BIPOLE_LEN/10.)  ! 10 m sub-bipoles
!
!  Use the maximal of SUB_RX_MAX and SUB_BIPOLE if there are mixed receivers
!
 SUB_RX_MAX=MAX(SUB_RX_MAX,SUB_BIPOLE)
!
!    Note that  RX_X etc are defined differently from old versions as electric
!    receivers now have two end points or many vertices (loop)
!
 ALLOCATE(RX_X(SUB_RX_MAX,LRX,NTXE),RX_Y(SUB_RX_MAX,LRX,NTXE),   &
          RX_Z(SUB_RX_MAX,LRX,NTXE),RX_WEIGHT(3,SUB_RX_MAX,LRX,NTXE))
 RX_X=0.; RX_Y=0.; RX_Z=0.; RX_WEIGHT=0.
!
 ALLOCATE(N_RX(NTXE),N_SUB_RX(LRX,NTXE),RX_TYPE_INDEX(LRX,NTXE))
 N_RX(NTXE)=0; RX_TYPE_INDEX=0; N_SUB_RX=0
!
! -- Convert input data
!
!    This includes converting the input coordinate system to the internal
!    computational coordinate system.
!
!    Note that the signs of vertical coordinates of transmitters and receivers remain
!    unchanged in routine TX_RX_CONVERTER.  They need be reversed according to conventions
!    for the input coordinate system should they be defined postive up.
!

 CALL TX_RX_CONVERTER (SURVEY_TYPE,SOURCE_TYPE,NTXE,MXVRTX,                &
                       N_VRTX,SXE,SXN,SXZ,SXDIP,SXAZ,NRXG,NRGTX,RX_TYPE,   &
                       RGTXID,NRXTX,NRX,MRX,LRX,MQVR,RXE,RXN,RXZ,          &
                       SUB_RX_MAX,SUB_BIPOLE,TX_CRDX,TX_CRDY,TX_CRDZ,      &
                       MD_ANGLE,N_RX,RX_X,RX_Y,RX_Z,RX_TYPE_INDEX,         &
                       N_SUB_RX,RX_WEIGHT,LOOP_INTEG_ACCURACY)
!
! -- Allocate arrays for field components
!
 ALLOCATE(EPX(LRX,NTXE,NFRQ),EPY(LRX,NTXE,NFRQ),EPZ(LRX,NTXE,NFRQ),   &
          HPX(LRX,NTXE,NFRQ),HPY(LRX,NTXE,NFRQ),HPZ(LRX,NTXE,NFRQ),   &
          ESX(LRX,NTXE,NFRQ),ESY(LRX,NTXE,NFRQ),ESZ(LRX,NTXE,NFRQ),   &
          HSX(LRX,NTXE,NFRQ),HSY(LRX,NTXE,NFRQ),HSZ(LRX,NTXE,NFRQ),   &
          VOLTP(LRX,NTXE,NFRQ),VOLTS(LRX,NTXE,NFRQ))
 EPX=(0.,0.); EPY=(0.,0.); EPZ=(0.,0.); HPX=(0.,0.); HPY=(0.,0.); HPZ=(0.,0.)
 ESX=(0.,0.); ESY=(0.,0.); ESZ=(0.,0.); HSX=(0.,0.); HSY=(0.,0.); HSZ=(0.,0.)
!
!  -- Equivalence of input parameter to those of Marco_3D
!
!   TRGT_BLCK = NPRISM
!   BLCK_NY = NCELL_EW    BLCK_LY = PRSM_SIZE_EW    BLCK_CX = PRISM_NORTH
!   BLCK_NX = NCELL_NS    BLCK_LX = PRSM_SIZE_NS    BLCK_CY = PRISM_EAST
!   BLCK_NZ = NCELL_Z     BLCK_LZ = PRSM_SIZE_Z     BLCK_CZ = PRISM_ZMID
!
!   M_RX = LRX
!
 CALL COMPUTE_3D(NFRQ,FREQ,SOURCE_TYPE,NW,                           & ! frequency info
                 NTXE,MXVRTX,N_VRTX,TX_CRDX,TX_CRDY,TX_CRDZ,         & ! transmitter info
                 MD_ANGLE,RX_TYPE_INDEX,N_SUB_RX,RX_WEIGHT,          & ! transmitter info
                 LRX,N_RX,RX_X,RX_Y,RX_Z,SUB_RX_MAX,                 & ! receiver info
                 NLYR,THK,RES,RMU,REPS,CHRG,CTAU,CFREQ,              & ! layered earth info
                 DO3D,SOLVER,KACC,KSYMM,NPRISM,NCELL_NS,             & !
                 NCELL_EW,NCELL_Z,PRSM_SIZE_NS,                      & !
                 PRSM_SIZE_EW,PRSM_SIZE_Z,                           & !  3D parameters
                 PRISM_NORTH,PRISM_EAST,PRISM_ZMID,                  & !
                 PRSM_RES,PRSM_CHRG,PRSM_TAU,PRSM_CFR,RMUP,REPSP,    & !
                 E_ONLY,EPX,EPY,EPZ,HPX,HPY,HPZ,VOLTP,               & !  1D output
                 ESX,ESY,ESZ,HSX,HSY,HSZ,VOLTS)                        !  3D output


!**** Internal test printing out results similar to those in version Marco_3p

 IF (PRT_REF) THEN

    OPEN (UNIT=5,FILE='MARCO.REF')
    CALL PRINT_FD(5,2,LRX,NFRQ,NTXE,N_RX,SOURCE_TYPE,SURVEY_TYPE,FREQ,   &
                  SUB_RX_MAX,SUB_BIPOLE,RX_X,RX_Y,RX_Z,N_vrtx,mxvrtx,             &
                  0.,0.,0.,                                               &
                  RX_TYPE_INDEX,TX_CRDX,TX_CRDY,TX_CRDZ,MD_ANGLE,DO3D,          &
                  HPX,HPY,HPZ,VOLTP,                                &
                  HSX,HSY,HSZ,VOLTS)
!**** End internal test
 END IF

!
 BFD_SCAT = (0.,0.)
 BFD      = (0.,0.)
!
! -- Assign output to arrays BFD and BFD_SCAT
!
!    Arrays BFD and BFD_SCAT are defined similar to HPX, HSX, VOLTP, VOLTS
!    etc.
!
!  *** Note that output HPX etc for magnetic dipoles are in fact components of B.
!
 DO JF = 1,NFRQ
    DO JS = 1,NTXE
       DO JR =1, LRX    ! May use array NRGTX to assign computed receivers only
          IF (RX_TYPE_INDEX(JR,JS) > 1) THEN
             BFD(JF,JR,JS,1) = VOLTP(JR,JS,JF)
          ELSE
!            Coincident loop may have only one valid component
             BFD(JF,JR,JS,1) = HPX(JR,JS,JF)
             BFD(JF,JR,JS,2) = HPY(JR,JS,JF)
             BFD(JF,JR,JS,3) = HPZ(JR,JS,JF)
          END IF
       END DO
    END DO
 END DO

 IF (DO3D==1) THEN
    DO JF = 1,NFRQ
       DO JS = 1,NTXE
          DO JR =1, LRX    ! May use array NRGTX to assign computed receivers only
             IF (RX_TYPE_INDEX(JR,JS) > 1) THEN
                BFD_SCAT(JF,JR,JS,1) = VOLTS(JR,JS,JF)
             ELSE
!            Coincident loop may have only one valid component
                BFD_SCAT(JF,JR,JS,1) = HSX(JR,JS,JF)
                BFD_SCAT(JF,JR,JS,2) = HSY(JR,JS,JF)
                BFD_SCAT(JF,JR,JS,3) = HSZ(JR,JS,JF)
             END IF
          END DO
       END DO
    END DO
 END IF
!
! - BFD is total reponse
!
!^^ already done in the main program
!
! BFD=BFD+BFD_SCAT
!
 END SUBROUTINE MARCO_3D

!
 SUBROUTINE TX_RX_CONVERTER (SURVEY_TYPE,SOURCE_TYPE,NTXE,MXVRTX,                &
                             N_VRTX,SXE,SXN,SXZ,SXDIP,SXAZ,NRXG,NRGTX,RX_TYPE,   &
                             RGTXID,NRXTX,NRX,MRX,LRX,MQVR,RXE,RXN,RXZ,          &
                             SUB_RX_MAX,SUB_BIPOLE,TX_CRDX,TX_CRDY,TX_CRDZ,      &
                             MD_ANGLE,N_RX,RX_X,RX_Y,RX_Z,RX_TYPE_INDEX,         &
                             N_SUB_RX,RX_WEIGHT,LOOP_INTEG_ACCURACY)

!  LRX = M_RX
!  NRXTX = N_RX
!  N_VRTX = old N_SIDE
!  MQVR /= /= !!! SUB_RX_MAX
!  NCRD = MXVRTX


!**** Convert input transmitter and receiver data to internal parameters of Marco_1D
!
!     The input coordinate system is different from the interanl coordinate system
!     for computation.  Conversions are done here to transmitters and receivers
!
!     The input data coordinate syste:   X -- East
!                                        Y -- North
!                                        Z -- Down
!     The computation coordinate syste:  X -- North
!                                        Y -- East
!                                        Z -- Down
!
!    Note that the signs of vertical coordinates of transmitters and receivers remain
!    unchanged in routine TX_RX_CONVERTER.  They need be reversed according to conventions
!    for the input coordinate system should they be defined postive up.
!
!
! Input parameters:
!
!  SUB_RX_MAX = maximum number of magnetic dipole points for loops
!              or points along electric bipole.
!  SUB_BIPOLE = number of bipole integration points.
!
!  LOOP_INTEG_ACCURACY:  Integer, accuracy level for loop-receivers.  See routine
!                        RX_LOOP_INTEG for more details.
!
!  Other parameters such as SURVEY_TYPE etc are same as documented control file Tx
!  and Rx parameters
!
!
! Output parameters:
!
!  TX_CRDX, TX_CRDY, TX_CRDZ: Real TX_CRDX(MXVRTX,NTXE), TX_CRDY(MXVRTX,NTXE),
!           and  Real TX_CRDZ(MXVRTX,NTXE):
!           coordinates of electrodes (the end points of current bipoles
!           or loop corners) or the center coordinates of a current loop
!           or a magnetic dipole for all the excitations.
!           Note that the x and y-coordinates are in double precision to accomodate
!           real world coordinates.    For various
!           values of SOURCE_TYPE,  the four elements for the first index of
!           TX_CRDX, TX_CRDY,  and TX_CRDZ contain the following information:
!           SOURCE_TYPE =1:  the arrays TX_CRDX etc. contains the coordinates
!                            of the vertices of the polygonal loop.
!                       =2:  elements of TX_CRDX etc. are coordinates for the
!                            electrodes of the bipoles;
!                       =3:  the first elements of TX_CRDX etc.
!                            contain the coordinates of the centre of the
!                            magnetic dipole.
!  MD_ANGLE:  Real MD_ANGLE(2,NTXE),  orientations of arbitrary magnetic
!             dipoles (SOURCE_TYPE=3) for each excitation.  For each excitation
!             the two elements of MD_ANGLE(1:2,J) contain the dip angle
!             MD_ANGLE(1,J) and the azimuthal angle MD_ANGLE(2,J) of the Jth
!             magnetic dipole.  The dip angle is the angle from the axis down
!             to the earth (note that this is the internal positive z-axis
!             which differs from the input-output z-axis that points upwards).
!             The azimuthal angle is the angle from the north,  the y-axis.
!             Thus for a vertical magnetic dipole MD_ANGLE(1,J)=180 for
!             pointing up air and MD_ANGLE(1,J) =0 for pointing down.  A
!             horizontal magnetic dipole pointing north will have MD_ANGLE(1,J)
!             =90 and MD_ANGLE(2,J)=0,  and a horizontal magnetic dipole
!             pointing east will have MD_ANGLE(1,J)=90 and MD_ANGLE(2,J)=90.
!  N_RX:      N_RX is used by lower level subroutines.
!             N_RX = NRXTX for SURVEY_TYPE=1 and
!             N_RX = NRX   for SURVEY_TYPE=2
!  N_SUB_RX:   Integer, number of sub receivers per receiver per transmitter
!  RX_X,RX_Y,RX_Z:  Real RX_X(SUB_RX_MAX,LRX,NTXE),
!                        RX_Y(SUB_RX_MAX,LRX,NTXE),
!                   Real RX_Z(SUB_RX_MAX,LRX,NTXE),
!                    receiver sites coordinates in the x, y, and z-directions for
!                    receiver sites,  respectively.
!                    Note RX_X etc are designed differently from older versions which
!                    have no sub index for each receiver site.
!  RX_WEIGHT:    Real RX_WEIGHT(3,SUB_RX_MAX,LRX,NTXE), integration weights for
!                sub-receivers (magnetic dipoles) for loop receivers.  Those weights
!                are the products of integration weight, area, and direction cosines
!                for the sub-receivers.  See routine RX_LOOP_INTEG for
!                more details.
!  RX_TYPE_INDEX:  RX_TYPE index for each receiver.
!                  = 1: magnetic dipole receivers;
!                  = 2: loop receivers; and
!                  = 3: electric bipole receivers
!                  Note that loop receivers are converted to magnetic dipole receivers
!                  with RX_TYPE_INDEX=2.
!
!**** Called by:  main
!**** Calls:      none
!
!
      IMPLICIT NONE
!
! -- Input parameters
!
 INTEGER SOURCE_TYPE,SURVEY_TYPE,NTXE,NRXG,MXVRTX,MQVR,MRX,LRX, &
         RGTXID(NRXG,NTXE)
 INTEGER, DIMENSION (NTXE) :: N_VRTX,NRGTX,NRXTX
 INTEGER, DIMENSION (NRXG) :: NRX,RX_TYPE
 REAL :: SXDIP(NTXE),SXAZ(NTXE)
 REAL, DIMENSION (MXVRTX,NTXE) :: SXE, SXN, SXZ
 REAL, DIMENSION (MRX,NRXG,MQVR) :: RXE, RXN, RXZ
 INTEGER :: SUB_RX_MAX,SUB_BIPOLE,LOOP_INTEG_ACCURACY
!
! -- Output parameters
!
 INTEGER :: N_RX(NTXE),N_SUB_RX(LRX,NTXE),RX_TYPE_INDEX(LRX,NTXE)
 REAL :: TX_CRDX(MXVRTX,NTXE),TX_CRDY(MXVRTX,NTXE),TX_CRDZ(MXVRTX,NTXE),  &
         RX_X(SUB_RX_MAX,LRX,NTXE),RX_Y(SUB_RX_MAX,LRX,NTXE),             &
         RX_Z(SUB_RX_MAX,LRX,NTXE),RX_WEIGHT(3,SUB_RX_MAX,LRX,NTXE)
 REAL :: MD_ANGLE(2,NTXE)
!
 INTEGER :: NINTEG,NINTEG_MAX
 REAL, ALLOCATABLE :: VERTEX(:,:),INTEG_POINTS(:,:),INTEG_WEIGHTS(:,:)
!
 INTEGER :: I,II,J,JJ,K,JS,JR
 REAL :: DX,DY,DZ
!
! Loop receivers are design for 4-sided loops only.  May need further test
! if there are polygonal loop receivers.
 NINTEG_MAX=MQVR*2+1
 ALLOCATE (VERTEX(3,MQVR),INTEG_POINTS(3,NINTEG_MAX),INTEG_WEIGHTS(3,NINTEG_MAX))
!
! --- Transmitters
!
      DO J=1,NTXE
!
         IF (SOURCE_TYPE==1.OR.SOURCE_TYPE==2) THEN
!  --    Grounded electric wires or electric loops
            DO I=1,N_VRTX(J)
               TX_CRDX(I,J)=SXN(I,J)    ! x-axis is north
               TX_CRDY(I,J)=SXE(I,J)
               TX_CRDZ(I,J)=SXZ(I,J)
            END DO
         ELSE IF (SOURCE_TYPE==3) THEN
!  --    Magentic dipoles
            TX_CRDX(1,J)=SXN(1,J)
            TX_CRDY(1,J)=SXE(1,J)
            TX_CRDZ(1,J)=SXZ(1,J)
            MD_ANGLE(1,J)=SXDIP(J)  ! double check if angles are defined same
            MD_ANGLE(2,J)=SXAZ(J)
         END IF
!
      END DO
!
! --- Receivers
!
!     For Survey_type=1 RX_X etc must contain receiver coordinates for all
!     the events that share the same transmitter in order to minimise run
!     time.  Information for those receivers are passed on by arrays,
!     NRGTX, NRXTX, and RGTXID
!
      IF (SURVEY_TYPE==1) THEN
         N_RX = NRXTX
         DO JS=1,NTXE            !  Transmitter in use (from selected events)
            II=0
            DO J=1,NRGTX(JS)     !  Receiver groups for transmitter JS
               JR=RGTXID(J,JS)   !  Actual receiver group ID from input list
               DO I=1,NRX(JR)    !  Actual receivers from input list
                  II=II+1        !  II can also be determined by using array NRXTX
                  DO JJ =1,MQVR
                     RX_X(JJ,II,JS) = RXN(I,JR,JJ)
                     RX_Y(JJ,II,JS) = RXE(I,JR,JJ)
                     RX_Z(JJ,II,JS) = RXZ(I,JR,JJ)
                     RX_TYPE_INDEX(II,JS) = RX_TYPE(JR)
                  END DO
               END DO
            END DO
         END DO
      ELSE IF (SURVEY_TYPE==4) THEN
!  -- Coincident loops
         N_RX = 1
         DO JS=1,NTXE
            DO JJ =1,MQVR      !   MQVR is assigned in MARCO_3D for SURVEY_TYPE=4
               RX_X(JJ,1,JS) = TX_CRDX(JJ,JS)
               RX_Y(JJ,1,JS) = TX_CRDY(JJ,JS)
               RX_Z(JJ,1,JS) = TX_CRDZ(JJ,JS)
               RX_TYPE_INDEX(1,JS) = 2
            END DO
         END DO
      ELSE
         N_RX = NRX       !  NRX = 1.  N_RX is used by lower level subroutines
         DO JS=1,NTXE
            DO II=1,NRX(JS)
               DO JJ =1,MQVR                      !** MQVR work for all survey type???
                  RX_X(JJ,II,JS) = RXN(II,JS,JJ)
                  RX_Y(JJ,II,JS) = RXE(II,JS,JJ)
                  RX_Z(JJ,II,JS) = RXZ(II,JS,JJ)
                  RX_TYPE_INDEX(II,JS) = RX_TYPE(JS)
               END DO
            END DO
         END DO
      END IF
!
!  -- Set number of sub receivers to be 1 for magnetic dipole receivers.
!     Other receiver types are considered below.
!
      N_SUB_RX=1
!
!  -- Convert bipole and loop receives into sub-receivers
!
!     The following two DO blocks can be combined into one,  but using separate blocks
!     for bipoles and loops is clearer.
!
!   - Electric bipole receivers.
!     Bipole receivers are divided into SUB_BIPOLE-1 sections
!
      DO JS=1,NTXE
         DO II=1,N_RX(JS)
            IF (RX_TYPE_INDEX(II,JS)==3) THEN

  !*** May need to redefine sub_bipole for each receiver!!

               DX=(RX_X(2,II,JS)-RX_X(1,II,JS))/REAL(SUB_BIPOLE-1)
               DY=(RX_Y(2,II,JS)-RX_Y(1,II,JS))/REAL(SUB_BIPOLE-1)
               DZ=(RX_Z(2,II,JS)-RX_Z(1,II,JS))/REAL(SUB_BIPOLE-1)
               N_SUB_RX(II,JS)=SUB_BIPOLE
               DO K=1,SUB_BIPOLE
                  RX_X(K,II,JS)=RX_X(1,II,JS)+DX*(K-1)
                  RX_Y(K,II,JS)=RX_Y(1,II,JS)+DY*(K-1)
                  RX_Z(K,II,JS)=RX_Z(1,II,JS)+DZ*(K-1)
               END DO
            END IF
         END DO
      END DO
!
!   - Electric loop receivers are converted magnetic dipole receivers placed
!     on vertices and centres of sub-triangles.  Note that integration weights
!     associated with those dipole positions are also returned and they must
!     be passed on further to routines that actually compute responses at
!     those receiver sites
!
      DO JS=1,NTXE
         DO II=1,N_RX(JS)
            IF (RX_TYPE_INDEX(II,JS)==2) THEN
!
               DO I=1,MQVR                   ! This works for MQVR=4.  May need further test
                  VERTEX(1,I)=RX_X(I,II,JS)  ! if there are polygonal loop receivers.
                  VERTEX(2,I)=RX_Y(I,II,JS)
                  VERTEX(3,I)=RX_Z(I,II,JS)
               END DO                        !\/ MQVR for all loops !!
               CALL RX_LOOP_INTEG (MQVR,VERTEX,LOOP_INTEG_ACCURACY,  &
                                             NINTEG_MAX,NINTEG,INTEG_POINTS,INTEG_WEIGHTS)
               N_SUB_RX(II,JS)=NINTEG
               DO K=1,NINTEG
                  RX_X(K,II,JS)=INTEG_POINTS(1,K)
                  RX_Y(K,II,JS)=INTEG_POINTS(2,K)
                  RX_Z(K,II,JS)=INTEG_POINTS(3,K)
                  RX_WEIGHT(1:3,K,II,JS)=INTEG_WEIGHTS(1:3,K)
               END DO
            END IF
         END DO
      END DO
!
 DEALLOCATE (VERTEX,INTEG_POINTS,INTEG_WEIGHTS)
!
 END SUBROUTINE TX_RX_CONVERTER
!
!
 SUBROUTINE RX_LOOP_INTEG (NVRTX,VERTEX,ACCURACY,NINTEG_MAX,NINTEG,INTEG_POINTS,INTEG_WEIGHTS)
!---------------------------------------------------------------------------------------------
!
!  The voltage induced in a polygonal loop receiver is computed by integrating
!  the component of the magnetic field normal to the loop plane over the area
!  of the loop.  In order to approximate dipping, non-planar loops, the loop
!  is divided into NVRTX, pie-slice triangles, each defined by two adjacent
!  loop vertices and the loop centre point.  If the loop vertices are not
!  coplanar, then neither will the triangles be coplanar.
!
!  The magnetic field will be integrated over the loop using a 2*NVRTX + 1
!  rule (4 points per triangle) or an NVRTX rule (1 point per triangle)
!
!
! Input parameters:
!
!            NVRTX : integer, number of vertices of the receiver loop
!                  = 4 except for coincident loop case
!
!  VERTEX(J,NVRTX) : J = 1,2,3 are the north, east and depth coordinates of the vertices
!
!    ACCURACY: This routine supports two accuracy levels.                                       Example when NVRTX = 4
!
!         ACCURACY = 1: NVRTX integration points represented by  one magnetic dipole              _________________
!                       in the centre of the triangles is used for approximations.                #\             /#
!                                                                                                 |  \         /  |
!                  = 2: (2 * NVRTX + 1) integration points represented by one magentic            |    \  *  /    |
!                       dipole in each triangle centre plus one at each loop vertex plus          |      \ /      |
!                       one at the loop centre                                                    |  *   /C\  *   |
!                                                                                                 |    /     \    |
!                 * indicates integration points for ACCURACY = 1  (when NVRTX = 4)               |  /    *    \  |
!                 # indicates additional integration points for ACCURACY = 2  (when NVRTX = 4)    | /            \|
!                                                                                                 #---------------#
!       NINTEG_MAX :  Maximal number of integration points used for array definitions.
!                     NINTEG_MAX = 2 * MXVRTX + 1 where MXVRTX is defined as the
!                     maximum number of vertices of any receiver loop in the survey,
!
!
!  Output parameters:
!
!         NINTEG = NVRTX for ACCURACY = 1 or 2* NVRTX + 1 for ACCURACY = 2
!
!   INTEG_POINTS: real INTEG_POINTS(3,NINTEG), coordinates of the NINTEG points.
!                 For ACCURACY = 1, only first NVRTX elements are computed.
!
!  INTEG_WEIGHTS(3,NINTEG) : integration weights associated with each point for each
!                            of the three north, east and z-components
!                            (J = 1,2,3 respectively)
!
!                 They are the product of integration weights with the appropriate
!                 direction cosines.
!                 For ACCURACY = 1, only first 3 by NVRTX elements are computed.
!
!
!   To use this routine, compute three components of the the magnetic field at each
!   integration point.  Suppose that H(I,J) was the Ith component of the magnetic field
!   at point J.  I = 1,2,3 reprsents the north, east and z coordinates
!
!   H_TOTAL = SUM {I = 1,3} [SUM {j = 1,NINTEG} H(I,J) * INTEG_WEIGHTS(I,J)


 IMPLICIT NONE

 INTEGER, INTENT(IN) :: NVRTX,ACCURACY,NINTEG_MAX
 REAL, INTENT(IN) :: VERTEX(3,NVRTX)

 INTEGER, INTENT(OUT) :: NINTEG
 REAL, INTENT(OUT) :: INTEG_POINTS(3,NINTEG_MAX),INTEG_WEIGHTS(3,NINTEG_MAX)

! Working parameters for triangle vertices, side lengths, area, and angles

 REAL :: LOOP_CENTRE(3)
 REAL, ALLOCATABLE :: TRIANGLE_CENTRE(:,:),DIRECTION_COS(:,:),AREA(:)
 REAL :: X21,X31,Y21,Y31,Z21,Z31,L1,L2,L3,SP,A,B,C,NORM,D
 INTEGER :: I,J,J1

! Allocate working arrays

 ALLOCATE (TRIANGLE_CENTRE(3,NVRTX),DIRECTION_COS(3,NVRTX),AREA(NVRTX))

! Compute loop centre coordinates

 DO I = 1,3
   LOOP_CENTRE(I) = SUM (VERTEX(I,1:NVRTX)) / REAL (NVRTX)
 END DO

! Compute the centre for each triangle.

 TRIANGLE_CENTRE = 0.
 DO J= 1, NVRTX
   J1 = J + 1
   IF (J == NVRTX) J1 = 1   !  back to the first vertex for last triangle
   DO I = 1,3
     TRIANGLE_CENTRE(I,J) = (VERTEX(I,J) + VERTEX(I,J1) + LOOP_CENTRE(I)) /3.
   END DO
 END DO

! Compute triangle areas and direction cosines

 DO J = 1, NVRTX   !  Sum over triangles
   J1 = J + 1
   IF (J == NVRTX) J1 = 1

   X21 = VERTEX(1,J1) - VERTEX(1,J)
   Y21 = VERTEX(2,J1) - VERTEX(2,J)
   Z21 = VERTEX(3,J1) - VERTEX(3,J)
   X31 = LOOP_CENTRE(1) - VERTEX(1,J)
   Y31 = LOOP_CENTRE(2) - VERTEX(2,J)
   Z31 = LOOP_CENTRE(3) - VERTEX(3,J)

!  Side lengths
   L1 = SQRT (X21**2 + Y21**2 + Z21**2)
   L2 = SQRT ((LOOP_CENTRE(1) - VERTEX(1,J1))**2 +  &
              (LOOP_CENTRE(2) - VERTEX(2,J1))**2 +  &
              (LOOP_CENTRE(3) - VERTEX(3,J1))**2)
   L3 = SQRT(X31**2 + Y31**2 + Z31**2)

   SP = .5* (L1+L2+L3)     ! Semi perimeter

   AREA(J) = SQRT (SP * (SP-L1) * (SP-L2) * (SP-L3)) !  Heron's formula

!  Direction cosines: The equation of the plane containing triangle J is AX + BY + CZ = D

   A = Y21*Z31 - Y31*Z21
   B = Z21*X31 - Z31*X21
   C = X21*Y31 - X31*Y21
   NORM = SQRT (A**2 + B**2 + C**2)

   DIRECTION_COS(1,J) = A / NORM
   DIRECTION_COS(2,J) = B / NORM
   DIRECTION_COS(3,J) = C / NORM

   D = A* VERTEX(1,J) + B* VERTEX(2,J) + C* VERTEX(3,J)  ! Compute the correct sign
   IF (D < -1.E-6 * NORM) DIRECTION_COS(1:3, J) = -DIRECTION_COS(1:3, J)

 END DO

!  Output integration points and weights

 IF (ACCURACY==1) THEN  ! Triangle centres only

   NINTEG = NVRTX
   DO J = 1,NVRTX
     INTEG_POINTS(1:3,J)  = TRIANGLE_CENTRE(1:3,J)
     INTEG_WEIGHTS(1:3,J) = AREA(J) * DIRECTION_COS(1:3,J)
   END DO
 ELSE

!                    C                           C
!                  /   \                       /   \
!                 /     \                     /     \
!                /       \       ----->      /       \
!               /    $    \                 /    $    \
!              /           \               #           #
!             /             \             /             \
!            #_______________#           /_______________\
!
!
!   ACCURACY = 1:  C & # weights = 0      $ weight = 1
!   ACCURACY = 2:  C & # weights = 1/12   $ weight = 3/4
!
!   These weights get multiplied by each triangle area.
!   Each $ is used by one triangle; Each # is used by two triangles;
!   C is used by NVRTX triangles

   NINTEG = 2* NVRTX + 1

   DO J = 1, NVRTX   ! Triangle centres  Integration points 1:NVRTX
     INTEG_POINTS(1:3,J)  = TRIANGLE_CENTRE(1:3,J)
     INTEG_WEIGHTS(1:3,J) = .75 * AREA(J) * DIRECTION_COS(1:3,J)
   END DO

! Triangle vertices: Integration points NVRTX + 1 : 2 * NVRTX (WEIGHT = 1/12.)
! Receivers at the vertices cause singularity problems for coincident loop.
! Therefore, those position are moved 25% toward loop centre.

   DO J = 1,NVRTX
     J1 = J + 1                !  adjacent triangle
     IF (J == NVRTX) J1 = 1    !
     INTEG_POINTS(1:3, J+NVRTX)  = .75* VERTEX(1:3, J) + .25* LOOP_CENTRE(1:3)
     INTEG_WEIGHTS(1:3, J+NVRTX) = (AREA(J) * DIRECTION_COS(1:3, J)             &
                                 + AREA(J1) * DIRECTION_COS(1:3, J1)) /12.
   END DO

!  Vertex at loop centre is shared by all the triangles (WEIGHT = 1/12.)
   DO I=1,3
     INTEG_POINTS(I,2*NVRTX+1)  = LOOP_CENTRE(I)
     INTEG_WEIGHTS(I,2*NVRTX+1) = SUM (AREA(1:NVRTX) * DIRECTION_COS(I, 1:NVRTX)) / 12.
   END DO
 END IF

 DEALLOCATE (TRIANGLE_CENTRE,DIRECTION_COS,AREA)  ! De-allocate working arrays

 END SUBROUTINE RX_LOOP_INTEG


   SUBROUTINE COMPUTE_3D (NFRQ,FREQ,SOURCE_TYPE,NW,                         &  ! frequency info & others
                          NTXE,NCRD,N_VRTX,TX_CRDX,TX_CRDY,TX_CRDZ,         &  ! transmitter info
                          MD_ANGLE,RX_TYPE_INDEX,N_SUB_RX,RX_WEIGHT,        &  ! transmitter info
                          M_RX,N_RX,RX_X,RX_Y,RX_Z,SUB_RX_MAX,              &  ! receiver info
                          MLAYER,LRYTH,RES_LYR,RMU_LYR,RESP_LYR,CHRG_LYR,   &  ! layered earth info
                          TAU_LYR,FRQC_LYR,                                 &
                          DO3D,SOLVER,KACC,KSYMM,TRGT_BLCK,BLCK_NX,         &
                          BLCK_NY,BLCK_NZ,BLCK_LX,BLCK_LY,BLCK_LZ,BLCK_CX,  &
                          BLCK_CY,BLCK_CZ,RSB,CHRSB,TAUSB,CFRSB,RMUP,REPSP, &
                          E_ONLY,EPX,EPY,EPZ,HPX,HPY,HPZ,VOLTP,             &  !  1D output
                          E3X,E3Y,E3Z,H3X,H3Y,H3Z,VOLT3)                       !  3D output   3 for 3D
!
!**** 3D engine module for frequency domain modeling of multiple prisms in layered earths
!
!
!  Input parameters
!
!     NFRQ:    Integer,  number of frequencies.
!     FREQ:    Real FREQ(NFRQ), array for the frequencies.
!     SOURCE_TYPE: Integer, transmitter type.
!                  = 1 => general loop
!                  = 2 => grounded wire
!                  = 3 => magnetic dipole
!                  = 4 => magnetotellurics (to be added)
!     NW:       Integer, output unit for Marco.out
!     NTXE:     Integer,  number of excitations.  Note that NTXE is the
!               number of transmitters that are actually used in the computation.
!               It may be different from NTX in the input file.
!     NCRD:     Integer, number of electrodes/vertices. NRCD=1 for magnetic dipoles.
!     N_VRTX:   Integer N_VRTX(NTXE) number of vertices.  Note N_VRTX in this routine
!               are the vertices for true events. It is N_VTRX_EVENT in the main program.
!     TX_CRDX, TX_CRDY, TX_CRDZ: Real TX_CRDX(NCRD,NTXE), TX_CRDY(NCRD,NTXE),
!                                     TX_CRDZ(NCRD,NTXE):
!               coordinates of electrodes (the end points of current bipoles
!               or loop corners) or the center coordinates of a current loop
!               or a magnetic dipole for all the excitations.  Note that the
!               x and y-coordinates are in double precision to accomodate
!               real world coordinates.    For various
!               values of SOURCE_TYPE,  the four elements for the first index of
!               TX_CRDX, TX_CRDY,  and TX_CRDZ contain the following information:
!               SOURCE_TYPE =1:  the arrays TX_CRDX etc. contains the coordinates
!                                of the vertices of the polygonal loop.
!                           =2:  elements of TX_CRDX etc. are coordinates for the
!                                electrodes of the bipoles;
!                           =3:  the first elements of TX_CRDX etc.
!                                contain the coordinates of the centre of the
!                                magnetic dipole.
!     MD_ANGLE:  Real MD_ANGLE(2,NTXE),  orientations of arbitrary magnetic
!                dipoles (SOURCE_TYPE=3) for each excitation.  For each excitation
!                the two elements of MD_ANGLE(1:2,J) contain the dip angle
!                MD_ANGLE(1,J) and the azimuthal angle MD_ANGLE(2,J) of the Jth
!                magnetic dipole.  The dip angle is the angle from the axis down
!                to the earth (note that this is the internal positive z-axis
!                which differs from the input-output z-axis that points upwards).
!                The azimuthal angle is the angle from the north,  the y-axis.
!                Thus for a vertical magnetic dipole MD_ANGLE(1,J)=180 for
!                pointing up air and MD_ANGLE(1,J) =0 for pointing down.  A
!                horizontal magnetic dipole pointing north will have MD_ANGLE(1,J)
!                =90 and MD_ANGLE(2,J)=0,  and a horizontal magnetic dipole
!                pointing east will have MD_ANGLE(1,J)=90 and MD_ANGLE(2,J)=90.
!     RX_TYPE_INDEX: Integer RX_TYPE_INDEX(M_RX,NTXE) index for each receiver
!                    per transmitter.
!                     = 1: magnetic dipole receivers;
!                     = 2: loop receivers; and
!                     = 3: electric bipole receivers
!                    Note that loop receivers are converted to 3x3 magnetic dipole
!                    receivers with RX_TYPE_INDEX=2.
!     M_RX:    Integer,  maximal number of receivers for all the transmitter.
!     N_RX:    Integer N_RX(NTXE),  number of receivers for each excitation.
!     N_SUB_RX:    Integer N_SUB_RX(M_RX,NTXE), number of sub-receivers.
!     RX_X,RX_Y,RX_Z:  Real RX_X(SUB_RX_MAX,M_RX,NTXE), RX_Y(SUB_RX_MAX,M_RX,NTXE),
!                           RX_Z(SUB_RX_MAX,M_RX,NTXE)
!                      receiver sites coordinates in the x, y, and z-directions
!                      for receiver sites,  respectively.
!     RX_WEGHT:    Real RX_WEIGHT(SUB_RX_MAX,M_RX,NTXE), integration weights for
!                  sub-receivers (magnetic dipoles receivers) of loop receivers.
!     SUB_RX_MAX:  Integer, number of receiver sub-receivers for each receiver.
!                  Electric bipole receives are divided into SUB_RX_MAX-1 sections
!                  (with SUB_RX_MAX sub-electrode positions).  Loop receivers are
!                  replace by SUB_RX_MAX magnetic dipole (normally 3x3).
!                  SUB_RX_MAX = 1 for magnetic dipole receivers.
!     MLAYER: Integer,  number of layers of the earth.
!     LRYTH:   Real LRYTH(MLAYER), thickness of the layers.
!     RES_LYR:  Real RES_LYR(MLAYER),  resistivities of each layer of the earths.
!     RMU_LYR:  Real RMU_LYR(MLAYER),  permeabilities of each layer of the earths.
!     RESP_LYR:   Real RESP_LYR(MLAYER),  dielectric permittivities of the earths.
!     CHRG_LYR: Real CHRG_LYR(MLAYER),  chargeabilities of the earths.
!     TAU_LYR: Real TAU_LYR(MLAYER),  time constants of the earths.
!     FRQC_LYR: Real FRQC_LYR(MLAYER), frequency constants of the earths.
!     DO3D:  Integer.  DO3D = 1 Compute new 3D model; and
!                           = 0 or 2, Compute the response of a layered halfspace with no 3D target.
!     SOLVER:  Integer. Switch for direct or iterative solvers
!              = 1:  direct solver (best choice if model isn't too big)
!              = 2:  block iterative solver
!     KACC:    Integer,  accuracy level for the computation of the scattered
!              fields.  1<=KACC<=5. KACC=2 or 3 is recommeded.
!     KSYMM:   Integer,  controlling parameter for the two-plane symmetry for the 3D
!              model.  KSYMM=1:  symmetric model;  =0:  non-symmetric model.
!              Althoug KSYMM is determined automatically in the main programm this
!              3D engine required only the quadrant model for symmetric targets.
!     TRGT_BLCK: Integer,  number of input blocks.
!     BLCK_NX,BLCK_NY,BLCK_NZ: Integer BLCK_NX(TRGT_BLCK), BLCK_NY(TRGT_BLCK), BLCK_NZ(TRGT_BLCK).
!                              Number of cells in the x, y, and z-directions.
!     BLCK_LX,BLCK_LY,BLCK_LZ: Real BLCK_LX(TRGT_BLCK), BLCK_LY(TRGT_BLCK), BLCK_LZ(TRGT_BLCK).
!                              Dimensions of the blocks in the x, y, and z-direction.
!     BLCK_CX,BLCK_CY,BLCK_CZ: Real BLCK_CX(TRGT_BLCK), BLCK_CY(TRGT_BLCK), BLCK_CZ(TRGT_BLCK).
!                              Centre coordinates of the blocks in the x, y, and z-direction.
!     RSB:     Real RSB(TRGT_BLCK),  resistivities of the blocks.
!     CHRSB:   Real CHRSB(TRGT_BLCK),  chargeability of the blocks.  Cole-Cole models are
!              used to describe polarisable models.
!     TAUSB:   Real TAUSB(TRGT_BLCK),  time constants of the blocks.
!     CFRSB:   Real CFRSB(TRGT_BLCK),  frequency constants of the blocks.
!     RMUP:    Real RMUP(TRGT_BLCK). Relative permeabilities of the blocks.
!     REPSP:   Real REPSP(TRGT_BLCK). Relative dielectric constants of the blocks.
!     E_ONLY:  Integer.  E_ONLY controls if components of electric fields are to be
!              computed.  This is mostly designed for a 1D module based on this
!              routine.  It is useful for electric components at receiver locations
!              for many other purposes.  E_ONLY will affect the output parameters.
!              =1: compute E component only;
!              =0: compute either H components (E components are also computed together with H)
!                  or voltage between electrodes.
!              E_ONLY is used in routine MAIN_PRM_AT_RCV.
!
!  Output parameters
!
!     EPX,EPY,EPZ:  Complex EPX(M_RX,NTXE,NFRQ), EPY(M_RX,NTXE,NFRQ),
!                           EPZ(M_RX,NTXE,NFRQ).
!                   Electric field components due to layered earths at each receiver
!                   site per transmitter per frequency.
!                   EPX, EPY, and EPZ are output if E_ONLY=1.
!     HPX,HPY,HPZ:  Complex HPX(M_RX,NTXE,NFRQ), HPY(M_RX,NTXE,NFRQ),
!                           HPZ(M_RX,NTXE,NFRQ).
!                   Magnetic field components due to layered earths at each receiver
!                   site per transmitter per frequency.
!                   HPX, HPY, and HPZ are output if E_ONLY=0.
!     E3X,E3Y,E3Z:  Complex E3X(M_RX,NTXE,NFRQ), E3Y(M_RX,NTXE,NFRQ),
!                           E3Z(M_RX,NTXE,NFRQ).
!                   Scattered electric field components due to 3D targets at each
!                   receiver site per transmitter per frequency.
!     H3X,H3Y,H3Z:  Complex H3X(M_RX,NTXE,NFRQ), H3Y(M_RX,NTXE,NFRQ),
!                           H3Z(M_RX,NTXE,NFRQ).
!                   Scattered magnetic field components due to 3D targets at each
!                   receiver site per transmitter per frequency.
!     VOLTP:  Complex VOLTP(M_RX,NTXE,NFRQ). Potential due to layered earths
!             at each receiver site per transmitter per frequency.
!             VOLTP is output for bipole receivers if E_ONLY=0.
!     VOLT3:  Complex VOLT3(M_RX,NTXE,NFRQ).  Scattered potential due to
!             3D targets at each receiver site per transmitter per frequency.
!
!
!
!
!   ** New parameters compared to older versions:
!
!      SOURCE_TYPE and extend/replace functions of CS_TYPE
!
!      Arrays N_RX,RX_X,RX_Y,RX_Z have now one more dimension for vertices/bipole-ends
!      as determined by NRX_VRTX.
!
!      Circular loops and horizontal moving loops are obsolete.  Thus RAD and RAD2
!      are removed from the input list
!
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)  :: NFRQ,MLAYER,NW,SOURCE_TYPE,NTXE,NCRD,               &
                           N_RX(NTXE),M_RX,N_VRTX(NTXE),SUB_RX_MAX,            &
                           RX_TYPE_INDEX(M_RX,NTXE),N_SUB_RX(M_RX,NTXE),E_ONLY
!
! -- Note that x and y-coordinates of transmitters and receivers are in double
!    precision to accommodate real world coordinates
   REAL, INTENT(IN) :: TX_CRDX(NCRD,NTXE),TX_CRDY(NCRD,NTXE),            &
                       TX_CRDZ(NCRD,NTXE),RX_X(SUB_RX_MAX,M_RX,NTXE),    &
                       RX_Y(SUB_RX_MAX,M_RX,NTXE),RX_Z(SUB_RX_MAX,M_RX,NTXE),   &
                       RX_WEIGHT(3,SUB_RX_MAX,M_RX,NTXE)
   REAL, INTENT(IN)     :: FREQ(NFRQ),MD_ANGLE(2,NTXE),                             &
                           RES_LYR(MLAYER),CHRG_LYR(MLAYER),TAU_LYR(MLAYER),            &
                           FRQC_LYR(MLAYER),RESP_LYR(MLAYER),LRYTH(MLAYER),             &
                           RMU_LYR(MLAYER)
   COMPLEX, INTENT(OUT) :: EPX(M_RX,NTXE,NFRQ),EPY(M_RX,NTXE,NFRQ),EPZ(M_RX,NTXE,NFRQ), &
                           HPX(M_RX,NTXE,NFRQ),HPY(M_RX,NTXE,NFRQ),HPZ(M_RX,NTXE,NFRQ), &
                           VOLTP(M_RX,NTXE,NFRQ)
!                          ESX etc are used internally. Use E3X, E3Y,... for output
   COMPLEX, INTENT(OUT) :: E3X(M_RX,NTXE,NFRQ),E3Y(M_RX,NTXE,NFRQ),E3Z(M_RX,NTXE,NFRQ), &
                           H3X(M_RX,NTXE,NFRQ),H3Y(M_RX,NTXE,NFRQ),H3Z(M_RX,NTXE,NFRQ), &
                           VOLT3(M_RX,NTXE,NFRQ)
!
! -- Cole-Cole parameters for the permittivities are not used (not passed into this
!    routine).  They are assigned default values of non-dispersive models.
   REAL, ALLOCATABLE, DIMENSION (:) :: DCHRG_LYR,DTAU_LYR,DFRQC_LYR
!
   REAL,    ALLOCATABLE, DIMENSION(:) :: ZBND,HVK
   COMPLEX, ALLOCATABLE, DIMENSION(:) :: CDH,CDV,KKH
   COMPLEX, ALLOCATABLE, DIMENSION(:,:) :: ENX,ENY,ENZ,HNX,HNY,HNZ,VLT1D,  &
                                           ESX,ESY,ESZ,HSX,HSY,HSZ,VLT3D
!
!-- Arrays storing the tabulated Hankel integrals.  RRG contains the lateral
!   grid abscissas
!
   REAL, ALLOCATABLE :: RRG(:)
   COMPLEX, ALLOCATABLE :: GRHF(:,:,:,:),GRHO0(:,:,:)
!  ---   For 3D applications only :
   REAL, ALLOCATABLE :: RRG3(:)
   COMPLEX, ALLOCATABLE :: GRHF3(:,:,:),GRHO03(:,:)
!
!  -- For 3D wire paths simply define NZSRMAX z'-levels between the maximumand minimun
!     Not that these z'-levels greatly increase memory requirements!
!
   INTEGER, PARAMETER :: NZSRMAX=100
!
!  --- MZGRID is the maximal number of the vertical z-levels of the sources
!   and receivers.   300 should be quite big since it corresponds to an
!   array size of over 600 M-bytes for the array GRHF.  MZGRID is assigned a
!   larger value than NZSRMAX because MZGRID is also used as a working
!   parameter that simply adds up all receiver (and sub-receiver) levels
!   before identical ones are eliminated.
!
!   The arrays ZOBG etc. may also be made allocatable so that the parameter
!   MZGRID is eliminated.  However,  unless the routine INIT_ZLVLS is made an
!   internal routine of the main program this may affect the beauty of the
!   code since determining the z-levels is quite lengthy.
!
   INTEGER, PARAMETER :: MZGRID=500  !  use 500 because sub-receivers are now needed to
                                     !  compute potentials between electrodes.
!
   REAL :: ZOBG(MZGRID),ZSRG(2,MZGRID),ZOBCS(MZGRID),ZSRCS(2,MZGRID)
   REAL, ALLOCATABLE :: ZBG(:,:)
!
   INTEGER, PARAMETER :: KANIS=0  ! no anisotropy
!
!**** Parameters for the 3D body  *******************
!
   INTEGER, PARAMETER :: KAUTO=1   !  Always use automatic substructuring
   INTEGER, INTENT(IN) :: KSYMM,TRGT_BLCK,KACC,SOLVER,BLCK_NX(TRGT_BLCK), &
                          BLCK_NY(TRGT_BLCK),BLCK_NZ(TRGT_BLCK),DO3D

   REAL, INTENT(IN)    :: BLCK_LX(TRGT_BLCK),BLCK_LY(TRGT_BLCK),          &
                          BLCK_LZ(TRGT_BLCK),BLCK_CX(TRGT_BLCK),          &
                          BLCK_CY(TRGT_BLCK),BLCK_CZ(TRGT_BLCK),          &
                          RSB(TRGT_BLCK),CHRSB(TRGT_BLCK),                &
                          TAUSB(TRGT_BLCK),CFRSB(TRGT_BLCK),              &
                          REPSP(TRGT_BLCK),RMUP(TRGT_BLCK)
!
! -- Dispersive dielectric permeability parameters as Cole-Cole models.
!    They are not used in this version but they are kept here and assigned to
!    default values to minimise changes (in some routines such as STRUCTURING).
!
!          DESB is identical to REPSP and must be assigned so.
!
  ! REAL :: DESB(NSBM),DCHRSB(NSBM),DTAUSB(NSBM),DCFRSB(NSBM)
!
! -- The following 2 dimensional arrays are for the resistivities etc for
!    each sub-blocks of the sub-structures   **
   REAL, ALLOCATABLE :: DCHRBC(:,:),DTAUBC(:,:),DCFRBC(:,:)
!
! --  Arrays for conductivity properties etc for each sub-blocks of the sub-structures
!     that are assigned in routine STRUCTURING
!     DEBC is renamed to REPSB in MarcoAir
   REAL, DIMENSION (:,:), ALLOCATABLE :: RBC,CHRBC,TAUBC,CFRBC,DEBC,RMUB
!
   INTEGER, ALLOCATABLE :: NX(:,:),NY(:,:),NZ(:,:),NCELL(:,:),            &
                           NXI(:),NYI(:),NZI(:),NXJ(:),NYJ(:),            &
                           NZJ(:),NCELLI(:),NCELLJ(:),NCT(:),NET(:),      &
                           KCELL(:),SUB_BLOCK(:),KEYSF(:,:)
   COMPLEX, ALLOCATABLE :: CDB(:,:)
!
   REAL, DIMENSION (:), ALLOCATABLE :: CLMN,BLXI,BLYI,BLZI,X1,Y1,Z1
   REAL, DIMENSION (:,:), ALLOCATABLE :: BLX,BLY,BLZ,XBL,YBL,ZBL,XCELLI,YCELLI,     &
                                         ZCELLI,XCELLJ,YCELLJ,ZCELLJ
   REAL, DIMENSION (:,:,:), ALLOCATABLE :: XCELL,YCELL,ZCELL
!
   INTEGER NMAX,NBMAX,NBODY
!
   INTEGER, ALLOCATABLE :: IND(:)
   REAL, DIMENSION (:), ALLOCATABLE :: VV,GAI
   COMPLEX, ALLOCATABLE :: GA(:,:),EN(:),EMT(:),ENT(:,:),JST(:,:),     &
                           EJGS(:),EJGS2(:)
!
!   The array TCDB is used to compute electric fields at
!   receivers located on or within a cell.
!
      COMPLEX, ALLOCATABLE :: TCDB(:,:,:)
!
! ---- Parameter NSMR controls the size of the array containing
!   all the non-identical matrix elements for spatial symmetry
!   reductions.  Note that NSRM is defined differently from the
!   old version SYSEM since the first subscript of GRHF is changed.
!
!   In case NZTMAX has to be enlarged to allow either more cells
!   in the vertical direction or to allow more downhole receivers,
!   but the array GSB1 and GSB2 is big enough for the problem,
!   the definition of NSMR may changed in order to minimise the
!   memory requirement.  The memory requirement will otherwise
!   increases with NZTMAX quadratically.
!
   INTEGER NSMR
!
   COMPLEX, ALLOCATABLE :: GSB1(:,:),GSB2(:,:)
!
   COMPLEX, ALLOCATABLE :: EAX(:),EAY(:),EAZ(:),HAX(:),HAY(:),HAZ(:)
!
   INTEGER, PARAMETER :: KCOND=0, KCLMN=0
!
   REAL :: ALMAX,DMIN,CLMN2,RHOMAX,RHOMIN,BLMIN,RMAX1,RMIN1,RMAX2,RMIN2,FRQ
   INTEGER :: NHFILM,NZOB,NZSR,NZBG,NOBCS,NSRCS,              &
              IFRQ,I,J,WIRE_PATH,CS_TYPE,COLE_COLE,HIGH_FRQ
   INTEGER :: MBODY,NSUBCM,NXMAX,NYMAX,NZMAX,NCTT,NEQ,KBOUND,KSFT,KGHP,   &
              KUTCRP
!
! ---- Parameter SUB_CELL_MAX is the maximal number of cells to be allowed
!      in a substructure.  The parameter defines the maximal size of the
!      scattering matrix.  Note that the total number of cells to be modeled
!      is independent of SUB_CELL_MAX.  In fact,  there is no limit on the
!      total number of cells this program can handle as long as there is
!      enough disk space.
!
!   INTEGER, PARAMETER :: SUB_CELL_MAX=500
!
! ***  Parameter SUB_CELL_MAX is now disabled in favour of SOLVER.  It is
!      now determined by SOLVER and the total number of cells of the model
!
!      For large models the code will however overide the choice of SOVLER
!      by the user so that it won't crush because of lack of memory.
!      This limit is currently set to about 1200 cells which correspond to
!      104 MB for the scattering matrix.  Check the internal routine STRUCTURING
!      for details.
!
   INTEGER :: SUB_CELL_MAX
!
!  super block parameters for spatial symmetry reductions
   INTEGER :: NXS,NYS,NZS,KSMR
   REAL :: SBX,SBY,SBZ,SCX,SCY,SCZ,XSB,YSB,ZSB
!
!**** Parameters for MT receivers *******************
!*                                                  *
!
!   The MT option is retained in this version since this does not take
!   much extra spaces.  On the other hand,  the plane wave excitations
!   may somethmes be useful.
!
  !    REAL :: ZMT                                         ! Those parameters are kept temporarily
  !    INTEGER :: N_PROFL,LP1,LP2,MT_PROFL,NPOL,MT_STATN   ! before they are changed to new Rx
  !    REAL, ALLOCATABLE :: XRMT(:),YRMT(:)                ! conventions
      REAL, parameter :: ZMT=0.
      INTEGER :: LP1,LP2
      INTEGER, parameter :: NPOL=1,MT_PROFL=1,MT_STATN=1  !,N_PROFL=1 temporary fix
      REAL, parameter :: XRMT(1)=0.,YRMT(1)=0.
!
      COMPLEX :: E0X,E0Y
!
!  -- Arrays for scattered fields of MT stations
!
      COMPLEX, ALLOCATABLE :: EXMT(:,:,:),EYMT(:,:,:),             &
                              HXMT(:,:,:),HYMT(:,:,:),HZMT(:,:,:)    ! to be changed to ESX etc
!*                                                  *
!****************************************************
!
!     Rad is the radius of circular loops that were used in earlier versions.
!
   REAL, ALLOCATABLE :: RAD (:)
   
!
!	store time fields ...
	   Integer :: tvalue(8)
!
! -- Allocate internal working array RAD.  To be removed.
!
   ALLOCATE (RAD(NTXE))
   RAD=0.  ! initailisation to avoid compiler error
!
! --- Open files RESST and CONDT for storing the resistivity and the
!    complex conductivity of the cells.  These two units must be
!    opened for computation since cell conductivities are needed.

   OPEN (61,FILE='RESST',FORM='UNFORMATTED',STATUS='UNKNOWN')
   OPEN (62,FILE='CONDT',FORM='UNFORMATTED',STATUS='UNKNOWN')
!
! ----  The parameter HIGH_FRQ controls whether the high frequency
!       module will be invoked.  This normally controls the filters
!       for the Hankel integrals.  HIGH_FRQ is the same parameter as
!       "HIGH_FRQ" in older versions that computer dielectric
!       permittivity models at high frequencies.  With the introduction
!       of lithologies the input of permittivities is determined by
!       parameter LITHL_SPEC.  Here HIGH_FRQ affects the computations
!       of the Hankel integrals only.   The program considers
!       the frequency to be high if it is above 1 MHz (up to about 200 MHz).
!       At high frequencies displacement currents are important and
!       100-per-decade filters are chosen to evaluate the Hankel
!       transforms.  At low frequencies all permittivities are assumed
!       to be 1 although displacement currents are still included in
!       the computations.  At low frequencies (usually below 1 MHz,
!       but definitely below 10 MHz) 15-per-decade filters are used
!       to compute the Hankel transofrms.  It is possible to further
!       introduce another intermediate frequency range to improve
!       efficiency.  Thus,  the parameter HIGH_FRQ can be considered
!       as a frequency range option.
!
!       HIGH_FRQ = 0, low frequency computations;  and
!                = 1, high frequency version computations.
!
!       If HIGH_FRQ=1, dielectric parameters need to be input
!
!       Unlike in older versions with the parameter HIGH_FRQ where
!       HIGH_FRQ=1 would requre the input of permittivity data,
!       HIGH_FRQ is now determined automatically by the maximal frequency.
!
      IF (MAXVAL(FREQ)>1.E6) THEN
         HIGH_FRQ=1
      ELSE
         HIGH_FRQ=0
      END IF
!
! --- COLE_COLE controls if the layer and model conductivities are
!     described by Cole Cole models
!
      IF (DO3D==1) THEN
         IF (MAXVAL(CHRG_LYR)>0..OR.MAXVAL(CHRSB)>0.) THEN
            COLE_COLE=1                 ! IP models
         ELSE
            COLE_COLE=0                 ! Non-IP models
         END IF
      ELSE
         IF (MAXVAL(CHRG_LYR)>0.) THEN
            COLE_COLE=1                 ! IP models
         ELSE
            COLE_COLE=0                 ! Non-IP models
         END IF
      END IF
!
! ---- Set parameters for the high or low frequency version (i.e.,
!      whether displacement currents should be included)
!
!      ALMAX for the truncation of the kernels functions is determined
!      by the switch HIGH_FRQ.  ALMAX is to be passed into routine
!      ONE_D_0_2_INFTY.
!
!      DMIN is the geometric resolution limit.
!
!      RHOMIN and RHOMAX determine the minimal and maximal dimensions the
!      code can handle,  which is determined by the filters and required
!      size of the array GRHF.  They must agree with the design of
!      routine HFIL (the array dimensions in that routine).
!
!      NHFILM is the total number of grid for the spatial Hankel transforms
!      designed in routine HFIL which uses 15-per-decade filters in the low
!      frequency version and 50-per-decade filters in the high frequency
!      version.
!
!      The value of ALMAX depends on the highest frequency
!
      IF (HIGH_FRQ==1) THEN
         IF (MAXVAL(FREQ)>5.E+07) THEN
            ALMAX=300.
         ELSE
            ALMAX=100.
         END IF
         DMIN=0.001; RHOMIN=0.01
      ELSE
         ALMAX=20.; DMIN=.1;  RHOMIN=0.1
      END IF
!
!  --- Allocate layer parameters
!
      ALLOCATE (CDH(0:MLAYER),CDV(0:MLAYER),KKH(0:MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER))
      ALLOCATE (DCHRG_LYR(MLAYER),DTAU_LYR(MLAYER),DFRQC_LYR(MLAYER))
!
      HVK=1.            ! No anisotropy
      DCHRG_LYR=0.      ! Non-dispersive layers
      DTAU_LYR=0.
      DFRQC_LYR=0.
!
! --- Contruct layer boundaries coordinates from layer thickness
!
      ZBND(0)=0.
      DO I=1,MLAYER-1
         ZBND(I)=ZBND(I-1)+LRYTH(I)
      END DO
!
!  --- Divide the block(s) into substructures if necessary
!
!      Parameter NBMAX for the maximal number of block in each substructure
!      is necessary to control the number of blocks in a substructure.
!
      IF (DO3D==1) THEN !**** because of array allocation problem, it is
                         !     better to use nprism=0 (TRGT_BLCK here) for DO3D/=1
    !     IF (DO3D/=1) TRGT_BLCK=0
!
         NBMAX=3
!
         CALL STRUCTURING
!
!  --    Allocate 3D parametric arrays
!
         NXMAX=MAXVAL(NX)
         NYMAX=MAXVAL(NY)
         NZMAX=MAXVAL(NZ)
!  --    Reset NBMAX
         NBMAX=MAXVAL(SUB_BLOCK)
         NSUBCM=MAXVAL(NCT)
         MBODY=NBODY         ! MBODY normally have identical functions as NBODY but
                             ! some routines use both
!
         ALLOCATE(XCELL(NXMAX,NBMAX,NBODY),YCELL(NYMAX,NBMAX,NBODY),          &
                  ZCELL(NZMAX,NBMAX,NBODY),BLXI(NBMAX),BLYI(NBMAX),           &
                  BLZI(NBMAX),XCELLI(NXMAX,NBMAX),YCELLI(NYMAX,NBMAX),        &
                  ZCELLI(NZMAX,NBMAX),XCELLJ(NXMAX,NBMAX),                    &
                  YCELLJ(NYMAX,NBMAX),ZCELLJ(NZMAX,NBMAX),X1(NXMAX),          &
                  Y1(NYMAX),Z1(NZMAX),NXI(NBMAX),NYI(NBMAX),NZI(NBMAX),       &
                  NXJ(NBMAX),NYJ(NBMAX),NZJ(NBMAX),NCELLI(NBMAX),             &
                  NCELLJ(NBMAX),NET(NBODY),KCELL(NBODY),CLMN(NBODY),          &
                  KEYSF(NBMAX,NBODY))
!
      END IF
!
!  -- Test if the wire path is three-dimensional
!
!     Routine TEST_WIRE_PATH also returns the value for CS_TYPE for internal
!     computations (vs SOURCE_TYPE).  MT has yet to be considered
!
      IF (SOURCE_TYPE==1.or.SOURCE_TYPE==2) THEN
         CALL TEST_WIRE_PATH (SOURCE_TYPE,DMIN,NCRD,NTXE,TX_CRDX,TX_CRDY,   &
                              TX_CRDZ,WIRE_PATH,CS_TYPE)
      ELSE IF (SOURCE_TYPE==3) THEN
         CS_TYPE=9
         WIRE_PATH=0
      END IF
!
! ---- Note that after the routine INIT_COMPUTATION is executed,
!    arrays BLX,  BLY,  and BLZ contains the dimensions
!    of the cells instead of the blocks.
!


!!*** New parameter:  N_SUB_RX, RX_WEIGHT for loop and other integrations!!


      IF (DO3D==1)     &
      CALL INIT_COMPUTATION(DMIN,MBODY,NBMAX,NXMAX,NYMAX,NZMAX,              &
                            CS_TYPE,KSYMM,NTXE,SUB_RX_MAX,M_RX,              &
                            N_RX,N_SUB_RX,RX_X,RX_Y,RX_Z,                    &
                            ZMT,MT_PROFL,MT_STATN,XRMT,YRMT,                 &  ! MT parameters to be changed
                            NBODY,SUB_BLOCK,NX,NY,NZ,                        &
                            BLX,BLY,BLZ,XBL,YBL,ZBL,X1,Y1,Z1,                &
                            NCT,NET,NCELL,NCTT,NEQ,XCELL,YCELL,ZCELL,KCELL,  &
                            KBOUND,MLAYER,ZBND,                              &
                            KSFT,KEYSF,KGHP,BLMIN)


!
! ---- Determine the reference length for numerical integration
!    of the Green's functions as required by the accuracy levels
!    determined by the parameter KACC.

      IF (DO3D==1)     &
      CALL INIT_REF_CELL_DIM(NW,MBODY,NBMAX,NBODY,SUB_BLOCK,   &
                             BLX,BLY,BLZ,DMIN,KCLMN,CLMN)
!
! ---- Determine if the spatial symmetry reduction can be used
!
      IF (DO3D==1)     &
      CALL INIT_SUPER_BLOCK (NW,MBODY,NBMAX,NSMR,KSYMM,DMIN,NXMAX,    &
                             NYMAX,NZMAX,NBODY,SUB_BLOCK,BLX,BLY,BLZ,   &
                             NX,NY,NZ,XBL,YBL,ZBL,XCELL,YCELL,ZCELL,    &
                             SBX,SBY,SBZ,XSB,YSB,ZSB,SCX,SCY,SCZ,NXS,   &
                             NYS,NZS,KSMR)
!
    CALL INIT_RHOMAX(DO3D,MBODY,NBMAX,NXMAX,NYMAX,KSYMM,                   &
                     NBODY,SUB_BLOCK,NX,NY,XCELL,YCELL,BLX,BLY,NTXE,  &
                     NCRD,TX_CRDX,TX_CRDY,N_RX,RX_X,RX_Y,SUB_RX_MAX,       &
                     N_SUB_RX,M_RX,RHOMIN,RMAX1,RMIN1,RMAX2,RMIN2)
!
!  -- Use the largest possible value for RMAX1, the largest distance between transmitters
!     and receivers.  Note that this parameter affects memory requirements, particularly
!     for high frequency applications.
!
      IF (HIGH_FRQ==1) THEN
         RHOMIN=.01
      ELSE
         RHOMIN=.1
      END IF
!
      RHOMAX=MAX(RMAX1,RMAX2)
!
! --- Determine the number grid nodes in the rho-direction for the Hankel tables.
!     Note those values must strictly be determined by the sampling density
!     values of the filters used in routines HFILL and HFILH.
!
!     Default may use NHFILM=301;RHOMIN=0.1; RHOMAX=100000.; NHFILM=91
!
      IF (HIGH_FRQ==1) THEN
         NHFILM=INT(ALOG(RHOMAX)/(ALOG(10.)/50.))+100+5
      ELSE
         NHFILM=INT(ALOG(RHOMAX)/(ALOG(10.)/15.))+15+5
      END IF
!
      IF (DO3D==1) THEN
!
! ---- Open files to store the scattering matrices
!
!--- Files Green0 through 8 store the scattering matrices.
!
!    For MT problems, GREEN1 and GREEN3 stores the diagonal
!    submatrices for the two polarizations, while GREEN2 and
!    GREEN4 store the interaction submatrices for the two
!    polarization.  Green5 and GREEN6 are used as a working
!    file.
!
!    For CSAMT problems unit 31 through 38 store the block
!    matrices  computed by group theoretical diagonalization.
!    The original scattering matrix is block diagonalized into
!    four block matrices piece by piece.   Those four block
!    matrices are then further partitioned into submatrices
!    for the use of system iteration.   Units 32 through 35
!    store the diagonal submatrices of the four block matrices
!    obtained by group reduction. Units 31 through 34 store
!    the factored results.  Unit 35 through 38 store the
!    interaction submatrices, or the off-diagonal submatrices.
!    Note that unit 35 first store the diagonal submatrices
!    temporarily.  After factorization it's contents are move
!    to unit 34, and contents in units 34, 33,  and 32 are
!    move to units 33, 32, and 31.
!
!    Units 41 through 44 stores the four sets of transformed
!    incident fields used by the group reduction.  They
!    correspond to the incident fields for the four block
!    matrices
!    Units 45 through 48 stores the four sets of transformed
!    scattering currents
!
         IF (KSYMM==1.OR.NBODY>1) THEN
            OPEN (31,FILE='GREEN1',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (32,FILE='GREEN2',FORM='UNFORMATTED',STATUS='UNKNOWN')
         END IF
         IF (KSYMM==1) THEN
            OPEN (33,FILE='GREEN3',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (34,FILE='GREEN4',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (35,FILE='GREEN5',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (36,FILE='GREEN6',FORM='UNFORMATTED',STATUS='UNKNOWN')
         END IF
         IF (KSYMM==1.AND.CS_TYPE/=1) THEN
            OPEN (37,FILE='GREEN7',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (38,FILE='GREEN8',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (41,FILE='UEI1',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (42,FILE='UEI2',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (43,FILE='UEI3',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (44,FILE='UEI4',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (45,FILE='UJS1',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (46,FILE='UJS2',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (47,FILE='UJS3',FORM='UNFORMATTED',STATUS='UNKNOWN')
            OPEN (48,FILE='UJS4',FORM='UNFORMATTED',STATUS='UNKNOWN')
         END IF
!
! ---- File INDEX1 through INDEX4 in units 63 through 66 store the
!    array IND used in solution of the matrix equations
!
         OPEN (63,FILE='INDEX1',FORM='UNFORMATTED',STATUS='UNKNOWN')
         OPEN (64,FILE='INDEX2',FORM='UNFORMATTED',STATUS='UNKNOWN')
         OPEN (65,FILE='INDEX3',FORM='UNFORMATTED',STATUS='UNKNOWN')
         OPEN (66,FILE='INDEX4',FORM='UNFORMATTED',STATUS='UNKNOWN')
!
! ---- Eics and Jscs store the electric fields and scattering
!    current in the structure due to different excitation sites.
!    Note that for symmetric structures 41 through 44 instead of
!    10 will be used
!
         IF (KSYMM==0.OR.NPOL==2) OPEN (10,FILE='EICS',FORM='UNFORMATTED',    &
             STATUS='UNKNOWN')
         IF (CS_TYPE/=1.OR.NPOL==2) OPEN (20,FILE='JSCS',FORM='UNFORMATTED',  &
             STATUS='UNKNOWN')
!
!-- Units 11 and 12 store the values of the normal and scattered
!   electric and magnetic fields at each frequency used both in
!   the Fourier transforms for time domain solutions and in printing
!   the frequency domain results for plotting purpose.
!
!   Unit 13 (tmp13) stores the apparent resistivities of CSAMT computation
!
   !         OPEN (11,FILE='tmp11',FORM='UNFORMATTED',STATUS='UNKNOWN')
   !         OPEN (12,FILE='tmp12',FORM='UNFORMATTED',STATUS='UNKNOWN')
   !         IF (CS_TYPE==3)   &
   !         OPEN (13,FILE='tmp13',FORM='UNFORMATTED',STATUS='UNKNOWN')
!
      END IF
!
! --- For approximate solutions it is suggested to use spatial
!   symmetry reduction.  Issue warnings if not so.
!
!  -- Determine z'- and z-levels for the vertical coordinates of the transmitters and
!     receivers.  This is very efficient for magnetic dipoles,  for electrodes on a
!     flat horizontal plane and for strictly vertical electric bipoles.
!
!
!     Note that CS_TYPE = 2 is a very special case. It is used only if
!     all the transmitter bipoles are strictly vertical.  This does not
!     include vertical bipoles that are mixed among other arbitrarily
!     oriented 3D current bipoles, as in the case of WIRE_PATH=1 (non-
!     flat-earth).  This special function of CS_TYPE=2 can also be used
!     to test the accuracy of the numerical integrations in computing the
!     transmitter bipoles,  by comparing the results for a vertical
!     bipole (CS_TYPE=2) and the results for a vertical bipole that is
!     computed together with a group of other inclined 3D current bipoles.
!     Those tests can be used to determine the value of parameter NZSRMAX.
!
      CALL Z_ZP_LVLS(NW,MZGRID,CS_TYPE,NTXE,N_SUB_RX,                      &
                     M_RX,SUB_RX_MAX,N_RX,NCRD,TX_CRDZ,RX_Z,               &
                     WIRE_PATH,DMIN,NZSRMAX,NSRCS,ZSRCS,NOBCS,ZOBCS)
!
      IF (DO3D==1)                                                       &
         CALL INIT_ZLVLS(NW,MBODY,NBMAX,NZMAX,KSMR,NBODY,SUB_BLOCK,          &
                         NZS,NZ,SBZ,SCZ,ZSB,ZCELL,BLZ,                       &
                         MZGRID,DMIN,NZSR,ZSRG,NZOB,ZOBG)
!
!  -- ZBG is a working array that breaks the downhole current bipoles
!     into sections if the two electrodes straddle layers.  This is
!     necessary for the analytic integration of the Hankel kernels in
!     the vertical direction.
!
      NZBG=NSRCS+MLAYER
      ALLOCATE(ZBG(2,NZBG))
      ALLOCATE(RRG(NHFILM))
!
! ** May de- and re- allocate separately for 1D and 3D computations for better memory management
!
      ALLOCATE(GRHF(11,NHFILM,MAX(NZSR,NSRCS),MAX(NZOB,NOBCS)),        &
               GRHO0(4,       MAX(NZSR,NSRCS),MAX(NZOB,NOBCS)))
!
      IF (DO3D==1) THEN
!
         ALLOCATE(RRG3(NHFILM))
         ALLOCATE(GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR))
!
         NMAX=3*NSUBCM
         ALLOCATE(GA(NMAX,NMAX),EN(NMAX),EMT(NMAX),ENT(NMAX,NBODY),          &
                  JST(NMAX,NBODY),EJGS(4*NMAX*NBODY),EJGS2(4*NMAX*NBODY),    &
                  VV(NMAX),GAI(NMAX),IND(NMAX))
!  --- Take the maximal value of nsmr (=9*NXS*NYS*NZS*(NZS+1)/2) and
!      the size of the array for the Hankel tables
!         NSMR=MAX(11*NHFILM*NZSR*NZOB,NSMR)
! *** NSMR does not have to be linked to the array GRHF
      IF (KSMR==1) THEN
         ALLOCATE(GSB1(NSMR/3,3),GSB2(NSMR/3,3))
      ELSE
         NSMR=0
         ALLOCATE(GSB1(0,3),GSB2(0,3))  ! just to avoid error for some compilers!
      END IF
!
      END IF
!
!  -- Test 3D data
!
      IF (DO3D==1)     &
      CALL INIT_3D_INPUT_TEST(NW,KAUTO,KSYMM,DMIN,NSUBCM,MBODY,        &
                              NBMAX,NXMAX,NYMAX,NZMAX,NBODY,TRGT_BLCK, &
                              BLCK_LX,BLCK_LY,BLCK_LZ,BLCK_CX,BLCK_CY, &
                              BLCK_CZ,NCT,SUB_BLOCK,NX,NY,NZ,BLX,BLY,  &
                              BLZ,XBL,YBL,ZBL,MLAYER,ZBND,ZCELL)
!
      ALLOCATE(ENX(M_RX,NTXE),ENY(M_RX,NTXE),ENZ(M_RX,NTXE),      &
               HNX(M_RX,NTXE),HNY(M_RX,NTXE),HNZ(M_RX,NTXE),      &
               VLT1D(M_RX,NTXE))
      ALLOCATE(ESX(M_RX,NTXE),ESY(M_RX,NTXE),ESZ(M_RX,NTXE),      &
               HSX(M_RX,NTXE),HSY(M_RX,NTXE),HSZ(M_RX,NTXE),      &
               VLT3D(M_RX,NTXE))
      ALLOCATE(EAX(M_RX),EAY(M_RX),EAZ(M_RX),HAX(M_RX),HAY(M_RX),HAZ(M_RX))
      ALLOCATE(TCDB(NSUBCM,NBMAX,MBODY),CDB(NSUBCM,NBMAX))
!
! ------ Begin the frequency loop -------------------------------------
!
      Frequency_loop: DO IFRQ=1,NFRQ
!
         FRQ=FREQ(IFRQ)
!
         IF (NFRQ>1.AND.IFRQ==1) WRITE (*,*) ' '
!         IF (NFRQ>1) WRITE (*,1050) FRQ,100.*(IFRQ-1.)/NFRQ
         Call Date_and_Time(Values = tvalue)
         If (NFRQ > 1) Write (*, 1050) tvalue(1:3), tvalue(5:7), frq, 100.*(IFRQ-1.)/NFRQ
1050 Format (2x, i4, 2('/', i2.2), 2x, i2.2, 2(':', i2.2), 2x, en13.4, ' Hz => ', f5.1, ' % complete')         
! 1050 FORMAT (T3,'Frequency:',G12.4,1X,F5.1,' percent done')
!
!---- Compute the complex conductivities of the earths and the cells.
!
         CALL INIT_CMPLX_CD_1D(NW,FRQ,COLE_COLE,MLAYER,KANIS,HVK,            &
                               RES_LYR,CHRG_LYR,TAU_LYR,FRQC_LYR,RMU_LYR,    &
                               RESP_LYR,DCHRG_LYR,DTAU_LYR,DFRQC_LYR,        &
                               CDH,CDV,KKH)
         IF (DO3D==1)     &
         CALL INIT_CMPLX_CD_3D(FRQ,COLE_COLE,NBMAX,NBODY,SUB_BLOCK,NCELL,    &
                               BLZ,ZBND,MLAYER,RMU_LYR,NSUBCM,CDB,RBC,CHRBC,    &
                               TAUBC,CFRBC,DEBC,RMUB)
!
!-- No outcrops in forming the scattering matrix
!
         KUTCRP=0
!
! ----  NPOL controls the polarizations of the incident waves
!     for MT problems
!
!     For controlled sources, npol must be 0
!
   !      IF (CS_TYPE/=1) NPOL=0
!
         IF (NPOL==0.OR.NPOL==1) THEN
            LP1=1+NPOL
            LP2=1+NPOL
         ELSEIF (NPOL==2) THEN
            LP1=1
            LP2=2
         ELSE
            WRITE (NW,*) ' NPOL can only be 0, 1 or 2.  Please check'  &
                         ,' the input.  Program aborted.'
            WRITE (*,*) ' NPOL can only be 0, 1 or 2.  Please check',  &
                        ' the input.  Program aborted.'
            STOP
         END IF
!
! ---- calculate the incident fields at cell centres
!
         IF (DO3D==1)                                                     &
         CALL MAIN_PRM_AT_CELL(NW,FRQ,MLAYER,ZBND,LRYTH,HVK,KKH,CDH,      &
                               KANIS,HIGH_FRQ,CS_TYPE,KSYMM,MBODY,        &
                               NBMAX,NSUBCM,NMAX,NXMAX,NYMAX,NZMAX,       &
                               NTXE,MD_ANGLE,NCRD,N_VRTX,TX_CRDX,    &
                               TX_CRDY,TX_CRDZ,RAD,                       &
                               NPOL,LP1,LP2,NBODY,SUB_BLOCK,              &
                               NET,NEQ,NX,NY,NZ,NCELL,XCELL,YCELL,        &
                               ZCELL,NXI,NYI,NZI,NCELLI,XCELLI,YCELLI,    &
                               ZCELLI,CDB,EN,EMT,ENT,EJGS,EJGS2,RHOMIN,   &
                               RHOMAX,NZOB,ZOBG,NSRCS,ZSRCS,NZBG,ZBG,     &
                               KACC,1.,DMIN,NHFILM,ALMAX,BLMIN,           &  ! aj=1
                               GRHF,RRG,GRHO0)
!
         IF (KSMR==1) THEN
!
! ---- Compute the non-indentical elements of the scattering matrix
!    for use by spatial symmetry reductions.
!
!    Only the value of the clmn of one substructure is valid.
!
            CLMN2=CLMN(1)
!
            IF (DO3D==1)     &
            CALL MAIN_SUPER_GRID(GSB1,HIGH_FRQ,CLMN2,KANIS,SBX,SBY,SBZ,      &
                                 NXS,NYS,NZS,XSB,YSB,ZSB,NSMR,FRQ,MLAYER,    &
                                 ZBND,LRYTH,KKH,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG, &
                                 DMIN,NHFILM,RHOMIN,RHOMAX,RRG,RRG3,GRHF,    &
                                 GRHF3,GRHO0,GRHO03,ALMAX,KSFT,KCLMN,BLMIN,  &
                                 KACC,KUTCRP)
!
! -- Move the results from the array gsb1 to the array gsb2
!    since the array ga will be used later
!
            DO J=1,3
               DO I=1,3*NXS*NYS*NZS*(NZS+1)/2
                  GSB2(I,J)=GSB1(I,J)
               END DO
            END DO
!
         END IF
!
! --- Form the scattering matrices
!
         IF (DO3D==1)                                                    &
         CALL MAIN_MATRICES(NW,HIGH_FRQ,NPOL,KSMR,CLMN,KANIS,            &
                            KBOUND,KSYMM,CS_TYPE,KCOND,GA,GSB2,IND,      &
                            VV,GAI,EN,EMT,CDB,MBODY,NBMAX,NXMAX,NYMAX,   &
                            NZMAX,NSUBCM,NBODY,SUB_BLOCK,NET,NX,NY,NZ,   &
                            NCELL,BLX,BLY,BLZ,XCELL,YCELL,ZCELL,KCELL,   &
                            NEQ,NMAX,NXI,NYI,NZI,NCELLI,BLXI,BLYI,       &
                            BLZI,XCELLI,YCELLI,ZCELLI,NXJ,NYJ,NZJ,       &
                            NCELLJ,XCELLJ,YCELLJ,ZCELLJ,SBX,SBY,SBZ,     &
                            NXS,NYS,NZS,ZSB,NSMR,FRQ,MLAYER,ZBND,        &
                            LRYTH,KKH,CDH,CDV,HVK,NZOB,ZOBG,NZSR,ZSRG,   &
                            DMIN,NHFILM,RHOMIN,RHOMAX,RRG,RRG3,GRHF,     &
                            GRHF3,GRHO0,GRHO03,ALMAX,KSFT,KCLMN,BLMIN,   &
                            KACC,KUTCRP)
!
! --- Solving the matrix equations for the scattering currents
!   in the 3D structure using the system iteration method
!
         IF (DO3D==1)                                                    &
         CALL MAIN_SOLVER(NW,GA,IND,EMT,EN,ENT,NET,JST,EJGS,EJGS2,       &
                          KACC,KSMR,KSYMM,CS_TYPE,KANIS,KBOUND,NTXE,   &
                          LP1,LP2,NPOL,MBODY,NBMAX,NXMAX,NYMAX,          &
                          NZMAX,NMAX,NBODY,SUB_BLOCK,NX,NY,NZ,NCELL,     &
                          NCT,KCELL,XCELL,YCELL,ZCELL,BLX,BLY,BLZ,       &
                          NXI,NYI,NZI,NCELLI,XCELLI,YCELLI,ZCELLI,       &
                          BLXI,BLYI,BLZI,NXJ,NYJ,NZJ,NCELLJ,XCELLJ,      &
                          YCELLJ,ZCELLJ,SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,     &
                          NSMR,GSB2,NEQ)
!
! --- Calculate EM fields at receiver sites
!
!**** MT not considered yet!!!!

         CALL MAIN_PRM_AT_RCV(HIGH_FRQ,CS_TYPE,KACC,MLAYER,ZBND,RMU_LYR,  &
                              CDH,FRQ,NTXE,MD_ANGLE,NCRD,M_RX,N_SUB_RX,   &
                              RX_TYPE_INDEX,SUB_RX_MAX,                   &
                              SOURCE_TYPE,N_RX,RX_X,RX_Y,RX_Z,            &
                              RX_WEIGHT,N_VRTX,                           &
                              TX_CRDX,TX_CRDY,TX_CRDZ,E_ONLY,ENX,ENY,ENZ, &
                              HNX,HNY,HNZ,VLT1D,NHFILM,LRYTH,HVK,KKH,     &
                              KANIS,BLMIN,DMIN,RHOMIN,RHOMAX,NOBCS,ZOBCS, &
                              NSRCS,ZSRCS,NZBG,ZBG,ALMAX,GRHF,RRG,GRHO0)
!
! -- Compute scattered E and H fields at receiver sites.  Note
!    that MAIN_PRM_AT_RCV must be called before EHSRCV because of the
!    handling of receivers on or in the 3D target.
!
! -- Note that the two subroutines MAIN_SCAT_EH_MT and MAIN_SCAT_EH_CS may be
!    combined into one,  but they are separated because of the
!    different definitions of the arrays ESX etc. verse EXMT
!    etc.
!
         IF (DO3D==1) THEN
            IF (CS_TYPE==1)                                                  &
!  ** MT computations need yet to be updated.
               CALL MAIN_SCAT_EH_MT(HIGH_FRQ,KACC,KSYMM,MBODY,NBMAX,         &
                                    NSUBCM,NBODY,SUB_BLOCK,NCELL,TCDB,       &
                                    JST,NMAX,NHFILM,FRQ,MLAYER,ZBND,         &
                                    LRYTH,HVK,KKH,KANIS,BLMIN,DMIN,          &
                                    RHOMIN,RHOMAX,NOBCS,ZOBCS,NZSR,ZSRG,     &
                                    ALMAX,RRG,RRG3,GRHF,GRHF3,GRHO0,         &
                                    GRHO03,MT_PROFL,MT_STATN,XRMT,YRMT,      &
                                    NXMAX,NYMAX,NZMAX,NX,NY,NZ,XCELL,        &
                                    YCELL,ZCELL,BLX,BLY,BLZ,CDH,NPOL,E0X,    &
                                    E0Y,ZMT,KSFT,CLMN,EXMT,EYMT,HXMT,        &
                                    HYMT,HZMT)
            IF (CS_TYPE/=1)                                                  &
               CALL MAIN_SCAT_EH_CS(SUB_RX_MAX,                              &
                                    RX_TYPE_INDEX,HIGH_FRQ,KACC,KSYMM,MBODY, &
                                    NBMAX,NSUBCM,NBODY,SUB_BLOCK,NCELL,      &
                                    NET,TCDB,EMT,JST,EJGS,NMAX,NTXE,N_RX,    &
                                    N_SUB_RX,RX_WEIGHT,                      &
                                    NHFILM,FRQ,MLAYER,ZBND,LRYTH,HVK,KKH,    &
                                    RMU_LYR,                                 &
                                    KANIS,BLMIN,DMIN,RHOMIN,RHOMAX,NOBCS,    &
                                    ZOBCS,NZSR,ZSRG,ALMAX,RRG,RRG3,GRHF,     &
                                    GRHF3,GRHO0,GRHO03,RX_X,RX_Y,RX_Z,       &
                                    NXMAX,NYMAX,NZMAX,NEQ,NX,NY,NZ,XCELL,    &
                                    YCELL,ZCELL,BLX,BLY,BLZ,CDH,CDV,KSFT,    &
                                    CLMN,M_RX,ENX,ENY,ENZ,EAX,EAY,EAZ,       &
                                    HAX,HAY,HAZ,VLT3D,ESX,ESY,ESZ,HSX,HSY,HSZ)
!
!--- Set scattered fields to be zero for 1D computation only
!
         ELSE
            VLT3D=(0.,.0)
            ESX=(0.,.0)
            ESY=(0.,.0)
            ESZ=(0.,.0)
            HSX=(0.,.0)
            HSY=(0.,.0)
            HSZ=(0.,.0)
         END IF
!
! --- Store the E and H components in the output arrays Ex etc
!
!  *** Note that output HPX etc for magnetic dipoles are in fact components of B.
!
         DO J=1,NTXE
            DO I=1,M_RX
               IF (RX_TYPE_INDEX(I,J)>1) THEN
                  VOLTP(I,J,IFRQ)=VLT1D(I,J)
                  VOLT3(I,J,IFRQ)=VLT3D(I,J)
                  EPX(I,J,IFRQ)=(0.,0.)
                  EPY(I,J,IFRQ)=(0.,0.)
                  EPZ(I,J,IFRQ)=(0.,0.)
                  HPX(I,J,IFRQ)=(0.,0.)
                  HPY(I,J,IFRQ)=(0.,0.)
                  HPZ(I,J,IFRQ)=(0.,0.)
                  E3X(I,J,IFRQ)=(0.,0.)
                  E3Y(I,J,IFRQ)=(0.,0.)
                  E3Z(I,J,IFRQ)=(0.,0.)
                  H3X(I,J,IFRQ)=(0.,0.)
                  H3Y(I,J,IFRQ)=(0.,0.)
                  H3Z(I,J,IFRQ)=(0.,0.)
               ELSE
                  VOLTP(I,J,IFRQ)=(0.,0.)
                  VOLT3(I,J,IFRQ)=(0.,0.)
                  EPX(I,J,IFRQ)=ENX(I,J)
                  EPY(I,J,IFRQ)=ENY(I,J)
                  EPZ(I,J,IFRQ)=ENZ(I,J)
                  HPX(I,J,IFRQ)=HNX(I,J)
                  HPY(I,J,IFRQ)=HNY(I,J)
                  HPZ(I,J,IFRQ)=HNZ(I,J)
                  E3X(I,J,IFRQ)=ESX(I,J)
                  E3Y(I,J,IFRQ)=ESY(I,J)
                  E3Z(I,J,IFRQ)=ESZ(I,J)
                  H3X(I,J,IFRQ)=HSX(I,J)
                  H3Y(I,J,IFRQ)=HSY(I,J)
                  H3Z(I,J,IFRQ)=HSZ(I,J)
               END IF
            END DO
         END DO
!
!********** Start a new frequency loop ***********
!
         IF (NFRQ/=1) THEN
!
            IF (KSYMM==1.OR.NBODY>1) THEN
               REWIND (31)
               REWIND (32)
            END IF
            IF (KSYMM==1) THEN
               REWIND (33)
               REWIND (34)
               REWIND (35)
               REWIND (36)
            END IF
            IF (KSYMM==1.AND.CS_TYPE/=1) THEN
               REWIND (37)
               REWIND (38)
               REWIND (41)
               REWIND (42)
               REWIND (43)
               REWIND (44)
               REWIND (45)
               REWIND (46)
               REWIND (47)
               REWIND (48)
            END IF
            IF (KSYMM==0.OR.NPOL==2) REWIND (10)
            IF (CS_TYPE/=1.OR.NPOL==2) REWIND (20)
            DO I=1,6
               REWIND (60+I)
            END DO
         END IF
!
      END DO Frequency_loop
!
! --- Close units 10, 20,  41 through 48 and units 61 through 66
!   in order to reduce the total number of files being opened.
!   The units 31 through 38 storing the scattering matrix may
!   be too large to be closed during the excutation and thus
!   will not be closed during the executaion.
!
!  !! Unit 31 through 38 must be closed since the total number
!     of files is too large for some computers like Silicon
!     Graphics workstations
!
      IF (KSYMM==0.OR.NPOL==2) CLOSE (10,STATUS='DELETE')
      IF (CS_TYPE/=1.OR.NPOL==2) CLOSE (20,STATUS='DELETE')
      DO I=1,6
         CLOSE (UNIT=60+I,STATUS='DELETE')
      END DO
      IF (KSYMM==1.AND.CS_TYPE/=1) THEN
         DO I=1,8
            CLOSE (UNIT=40+I,STATUS='DELETE')
         END DO
      END IF
      DO I=1,8
         CLOSE (UNIT=30+I,STATUS='DELETE')
      END DO
!
!  --- Deallocate all the arrays before leaving this routine to avoid problems
!      with some compilers
!
      DEALLOCATE (CDH,CDV,KKH,ZBND,HVK,RRG,GRHF,GRHO0,ZBG,                  &
                  ESX,ESY,ESZ,HSX,HSY,HSZ,CDB,EAX,EAY,                      &
                  EAZ,HAX,HAY,HAZ)
!  -- Some of the arrays have been deallocated
      IF (DO3D==1) DEALLOCATE(EN,EMT,VV,GAI,IND)
 !     IF (DO3D==1) DEALLOCATE(RRG3,GRHF3,GRHO03,GA,EN,EMT,ENT,JST,      &
 !                             EJGS,EJGS2,VV,GAI,IND,GSB1,GSB2)
!  -- The following arrays for 3D part have always been allocated in the current version
      IF (DO3D==1) &
      DEALLOCATE(XCELL,YCELL,ZCELL,BLXI,BLYI,BLZI,XCELLI,YCELLI,        &
                 ZCELLI,XCELLJ,YCELLJ,ZCELLJ,X1,Y1,Z1,NXI,NYI,NZI,      &
                 NXJ,NYJ,NZJ,NCELLI,NCELLJ,NET,KCELL,CLMN)
!   -- These are allocated in routine STRUCTURING
      IF (DO3D==1) &
      DEALLOCATE(NX,NY,NZ,NCT,NCELL,BLX,BLY,BLZ,XBL,YBL,ZBL,RBC,        &
                 CHRBC,TAUBC,CFRBC,RMUB,SUB_BLOCK)
!
!  END SUBROUTINE MARCO_3D and begin internal routines
!
   CONTAINS
!
      SUBROUTINE STRUCTURING
!
!**** Divide block(s) into substructures
!
!   Input blocks are divided into substructures for the use of the
!   system iteration.  Blcoks are halved in the direction of maximal
!   cell numbers untill the total number of cells within each
!   substructure is reduced to a quarter of NSUBCM.
!
!Input parameters:
!
!  NSUBCM:  Integer(*4),  maximal nuber of cells in a substructure.
!  MBODY:   Integer,  maximal number of substructures allowed in the
!           program.
!  NBMAX:   Integer,  maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  TRGT_BLCK: Integer,  number of input blocks to be divided into
!           substructures.
!  BLCK_NX:    Integer BLCK_NX(TRGT_BLCK),  number of cells in the x-direction
!           of blocks.
!  BLCK_NY:    Integer BLCK_NY(TRGT_BLCK),  number of cells in the y-direction
!           of blocks.
!  BLCK_NZ:    Integer BLCK_NZ(TRGT_BLCK),  number of cells in the z-direction
!           of blocks.
!  BLCK_LX:    Real BLCK_LX(TRGT_BLCK),  dimensions of the blocks in the
!           x-direction.
!  BLCK_LY:    Real BLCK_LY(TRGT_BLCK),  dimensions of the blocks in the
!           y-direction.
!  BLCK_LZ:    Real BLCK_LZ(TRGT_BLCK),  dimensions of the blocks in the
!           z-direction.
!  BLCK_CX:    Real BLCK_CX(TRGT_BLCK),  x-coordinates of the block centres.
!  BLCK_CY:    Real BLCK_CY(TRGT_BLCK),  y-coordinates of the block centres.
!  BLCK_CZ:    Real BLCK_CZ(TRGT_BLCK),  z-coordinates of the block centres.
!  RSB:     Real RSB(TRGT_BLCK),  resistivities of the blocks.
!  CHRSB:   Real CHRSB(TRGT_BLCK),  chargeability of the blocks (if it
!           is polarisable).  Cole-Cole models are used to presents
!           polarisable models.
!  TAUSB:   Real TAUSB(TRGT_BLCK),  time constants of the blocks.
!  CFRSB:   Real CFRSB(TRGT_BLCK),  frequency constants of the blocks.
!  KACC:    Integer,  accuracy level for the computation of the scattered
!           fields.  See documentation file "Marco.DOC" for detail.
!  COLE_COLE:     Integer,  parameter controlling whether the model is polarisable.
!           COLE_COLE = 0:  non-polarisable;  and
!               = 1:  polarisable.
!
!
!Output parameters:
!
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:  Integer SUB_BLOCK(MBODY),  number of blocks in each substructure.
!  NCT:     Integer NCT(MBODY),  number of cells in each substructure.
!  NCELL:   Integer NCELL(NBMAX,MBODY),  number of cells in each block
!           of the substructures.
!  NX:      Integer NX(NBMAX,MBODY),  numbers of cells in the x-direction
!           in each block of the substructures.
!  NY:      Integer NY(NBMAX,MBODY),  numbers of cells in the y-direction
!           in each block of the substructures.
!  NZ:      Integer NZ(NBMAX,MBODY),  numbers of cells in the z-direction
!           in each block of the substructures.
!  BLX:     Real BLX(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the x-direction.
!  BLY:     Real BLY(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the y-direction.
!  BLZ:     Real BLZ(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the z-direction.
!  XBL:     Real XBL(NBMAX,MBODY),  x-coordinates of each blocks in the
!           substructures.
!  YBL:     Real YBL(NBMAX,MBODY),  y-coordinates of each blocks in the
!           substructures.
!  ZBL:     Real ZBL(NBMAX,MBODY),  z-coordinates of each blocks in the
!           substructures.
!  RBC:     Real RBC(NBMAX,MBODY),  resistivities of each blocks of the
!           substructures.
!  CHRBC:   Real CHRBC(NBMAX,MBODY),  chargeabilities of each blocks of
!           the substructures.
!  TAUBC:   Real TAUBC(NBMAX,MBODY),  time constants of each blocks of
!           the substructures.
!  CFRBC:   Real CFRBC(NBMAX,MBODY),  frequency constants of each blocks of
!           the substructures.
!  DEBC:    Real DEBC(NBMAX,MBODY),  dielectric permittivities of blocks
!           in the substructures.
!  DCHRBC:  Real DCHRBC(NBMAX,MBODY),  chargeabilities of the dielectric
!           permittivities of the blocks of the substructures.
!  DTAUBC:  Real DTAUBC(NBMAX,MBODY),  time constants of the dielectric
!           permittivities of the blocks of the substructures.
!  DCFRBC:  Real DCFRBC(NBMAX,MBODY),  freqeuncy constants of the dielectric
!           permittivities of the blocks of the substructures.
!  REPSB:   Real REPSB(NBMAX,NBODY), relative dielectric constants for the blocks of the substructures.
!  RMUB:    Real RMUB(NBMAX,NBODY), relative permeability for the blocks of the substructures.
!
!Note that the word "block" means differently for the input and output.
!In the input it is the blocks that are read from the data input file
!"MARCO.DAT".  In the output it is the blocks for computation purpose.
!
!
      IMPLICIT NONE
!
      INTEGER I,IB,II,IMAX,PARTITION,N1,N2,             &
              NCLIM,NCMAX,NM,NBODY1
!
!  -- Determine the total number of cells
!
      NCTT=0
      DO II=1,TRGT_BLCK
         NCTT=NCTT+BLCK_NX(II)*BLCK_NY(II)*BLCK_NZ(II)
      END DO

!  -- Determine the value of SUB_CELL_MAX according to SOLVER
!
!      For large models the code will however overide the choice of SOVLER
!      by the user so that it won't crush because of lack of memory.
!      This limit is currently set to about 1200 cells which correspond to
!      104 MB for the scattering matrix.

      IF (SOLVER==1) THEN
         SUB_CELL_MAX=NCTT
         IF (NCTT > 1200) THEN
            WRITE(*,1)
            WRITE(NW,1)
            SUB_CELL_MAX=900		! was 300
         END IF
      ELSE
!  -- For the iterative solver use a maximum of 300 cells
         SUB_CELL_MAX=MIN(NCTT/2,900) 	! was 300
      END IF
!
!
! ======== DIVIDE THE STRUCTURE BLOCKS INTO SUBSTRUCTURES =======
!
!-- If the total number of the substructure cells does not exceed the
!   designed limits or if accurate solution is needed
!
!*** This criterion may be changed !!
!
      IF (NCTT<=SUB_CELL_MAX.AND.TRGT_BLCK<=NBMAX.AND.KACC>1) THEN
!********************************************************************
!*                                                                  *
         NBODY=1
!
         ALLOCATE(BLX(TRGT_BLCK,1),BLY(TRGT_BLCK,1),BLZ(TRGT_BLCK,1),      &
                  XBL(TRGT_BLCK,1),YBL(TRGT_BLCK,1),ZBL(TRGT_BLCK,1),      &
                  NX(TRGT_BLCK,1),NY(TRGT_BLCK,1),NZ(TRGT_BLCK,1),         &
                  NCT(1),NCELL(TRGT_BLCK,1),                               &
                  RBC(TRGT_BLCK,1),DEBC(TRGT_BLCK,1),CHRBC(TRGT_BLCK,1),   &
                  TAUBC(TRGT_BLCK,1),CFRBC(TRGT_BLCK,1),                   &
                  RMUB(TRGT_BLCK,1),                                       &
                  DCHRBC(TRGT_BLCK,1),DTAUBC(TRGT_BLCK,1),                 &
                  DCFRBC(TRGT_BLCK,1),SUB_BLOCK(1))
!
         SUB_BLOCK(1)=TRGT_BLCK
         NCT(1)=0
         DO I=1,SUB_BLOCK(1)
            BLX(I,1)=BLCK_LX(I)
            BLY(I,1)=BLCK_LY(I)
            BLZ(I,1)=BLCK_LZ(I)
            XBL(I,1)=BLCK_CX(I)
            YBL(I,1)=BLCK_CY(I)
            ZBL(I,1)=BLCK_CZ(I)
            NX(I,1)=BLCK_NX(I)
            NY(I,1)=BLCK_NY(I)
            NZ(I,1)=BLCK_NZ(I)
            NCELL(I,1)=NX(I,1)*NY(I,1)*NZ(I,1)
            NCT(1)=NCT(1)+NCELL(I,1)
            RBC(I,1)=RSB(I)
            DEBC(I,1)=REPSP(I)
            IF (COLE_COLE==1) THEN
               CHRBC(I,1)=CHRSB(I)
               TAUBC(I,1)=TAUSB(I)
               CFRBC(I,1)=CFRSB(I)
            END IF
            RMUB(I,1) =RMUP(I)
         END DO
!*                                                                  *
!********************************************************************
      ELSE
!********************************************************************
!*                                                                  *
!
! -- Determine the number of substructures according to number of
!    cells in the substructures
!
!    NBODY1 is used as a working parameter that is the maximal number of
!    substructures for the fast solver with KACC=1
!
         NBODY1=MAX(NCTT/10+1,TRGT_BLCK)
         ALLOCATE(NX(1,NBODY1),NY(1,NBODY1),NZ(1,NBODY1),NCT(NBODY1),   &
                  NCELL(1,NBODY1))
!
         NBODY=TRGT_BLCK
!
         DO IB=1,NBODY
            NX(1,IB)=BLCK_NX(IB)
            NY(1,IB)=BLCK_NY(IB)
            NZ(1,IB)=BLCK_NZ(IB)
         END DO
!
! --- Break the block that has the maximal number of cells in the
!     direction of maximal cell numbers.
!
         DO PARTITION=1,100000
!
            DO IB=1,NBODY
               NCT(IB)=0
               NCELL(1,IB)=NX(1,IB)*NY(1,IB)*NZ(1,IB)
               NCT(IB)=NCT(IB)+NCELL(1,IB)
            END DO
!
            NCMAX=0
            DO IB=1,NBODY
               IF (NCMAX<NCT(IB)) THEN
                  NCMAX=NCT(IB)
                  IMAX=IB
               END IF
            END DO
!
!--- No further division necessary if the maximal number of
!    cells in a subbstructure is less than SUB_CELL_MAX/4 or if
!    the maximal number of substructurs is reached
!
!    In case an approximate solution is sought,  the body
!    is divided into maximal number of substructures defined by NCLIM
!
            IF (KACC==1) THEN
               NCLIM=10
            ELSE
               NCLIM=SUB_CELL_MAX/4
            END IF
!
!      --   NBODY1 is the maximum for the number of substructures
            IF (NCMAX<=NCLIM.OR.NBODY==NBODY1) THEN
               EXIT
            END IF
!
! -- Increase the number of substructures by 1
!
            NBODY=NBODY+1
!
! -- Move the blocks
!
            DO IB=NBODY,IMAX+2,-1
               NX(1,IB)=NX(1,IB-1)
               NY(1,IB)=NY(1,IB-1)
               NZ(1,IB)=NZ(1,IB-1)
            END DO
!
! -- divide the block imax into two
!
            NM=NX(1,IMAX)
            II=1
            IF (NM<NY(1,IMAX)) THEN
               NM=NY(1,IMAX)
               II=2
            END IF
            IF (NM<NZ(1,IMAX)) THEN
               NM=NZ(1,IMAX)
               II=3
            END IF
            N1=NM/2
            N2=NM-N1
!
            IF (II==1) THEN
               NX(1,IMAX+1)=N2
               NY(1,IMAX+1)=NY(1,IMAX)
               NZ(1,IMAX+1)=NZ(1,IMAX)
               NX(1,IMAX)=N1
            END IF
!
            IF (II==2) THEN
               NX(1,IMAX+1)=NX(1,IMAX)
               NY(1,IMAX+1)=N2
               NZ(1,IMAX+1)=NZ(1,IMAX)
               NY(1,IMAX)=N1
            END IF
!
            IF (II==3) THEN
               NX(1,IMAX+1)=NX(1,IMAX)
               NY(1,IMAX+1)=NY(1,IMAX)
               NZ(1,IMAX+1)=N2
               NZ(1,IMAX)=N1
            END IF
!
         END DO
!
! --- Now that the exact number of substructures is determined, reallocate
!     the arrays NX etc. and complete the restructuring.
!
         DEALLOCATE(NX,NY,NZ,NCT,NCELL)
         ALLOCATE(NX(1,NBODY),NY(1,NBODY),NZ(1,NBODY),NCT(NBODY),         &
                  NCELL(1,NBODY),BLX(1,NBODY),BLY(1,NBODY),BLZ(1,NBODY),  &
                  XBL(1,NBODY),YBL(1,NBODY),ZBL(1,NBODY),                 &
                  RBC(1,NBODY),DEBC(1,NBODY),CHRBC(1,NBODY),              &
                  TAUBC(1,NBODY),CFRBC(1,NBODY),                          &
                  RMUB(1,NBODY),                                          &
                  DCHRBC(1,NBODY),DTAUBC(1,NBODY),                        &
                  DCFRBC(1,NBODY),SUB_BLOCK(NBODY))
         NBODY1=NBODY
!
! --  Now divide the blocks into substructures as determined above.
!     Note that the following rules are identical the above.
!
         NBODY=TRGT_BLCK
!
! -- SUB_BLOCK for all substructures set to be one.
!
         DO IB=1,NBODY1
            SUB_BLOCK(IB)=1
         END DO
!
         NCT=0
         DO IB=1,NBODY
            BLX(1,IB)=BLCK_LX(IB)
            BLY(1,IB)=BLCK_LY(IB)
            BLZ(1,IB)=BLCK_LZ(IB)
            XBL(1,IB)=BLCK_CX(IB)
            YBL(1,IB)=BLCK_CY(IB)
            ZBL(1,IB)=BLCK_CZ(IB)
            NX(1,IB)=BLCK_NX(IB)
            NY(1,IB)=BLCK_NY(IB)
            NZ(1,IB)=BLCK_NZ(IB)
            NCELL(1,IB)=NX(1,IB)*NY(1,IB)*NZ(1,IB)
            NCT(IB)=NCT(IB)+NCELL(1,IB)
            RBC(1,IB)=RSB(IB)
            DEBC(1,IB)=REPSP(IB)
            IF (COLE_COLE==1) THEN
               CHRBC(1,IB)=CHRSB(IB)
               TAUBC(1,IB)=TAUSB(IB)
               CFRBC(1,IB)=CFRSB(IB)
            END IF
            RMUB(1,IB)=RMUP(IB)
         END DO
!
! --- Break the block that has the maximal number of cells in the
!     direction of maximal cell numbers.
!
         DO PARTITION=1,100000
!
            DO IB=1,NBODY
               NCT(IB)=0
               NCELL(1,IB)=NX(1,IB)*NY(1,IB)*NZ(1,IB)
               NCT(IB)=NCT(IB)+NCELL(1,IB)
            END DO
!
            NCMAX=0
            DO IB=1,NBODY
               IF (NCMAX<NCT(IB)) THEN
                  NCMAX=NCT(IB)
                  IMAX=IB
               END IF
            END DO
!
!--- No further division necessary if the maximal number of
!    cells in a subbstructure is less than SUB_CELL_MAX/4 or if
!    the maximal number of substructurs is reached
!
!    In case an approximate solution is sought,  the body
!    is divided into maximal number of substructures defined by NCLIM
!
            IF (KACC==1) THEN
               NCLIM=10
            ELSE
               NCLIM=SUB_CELL_MAX/4
            END IF
!
            IF (NCMAX<=NCLIM.OR.NBODY==NBODY1) THEN
               EXIT
            END IF
!
! -- Increase the number of substructures by 1
!
            NBODY=NBODY+1
!
! -- Move the blocks
!
            DO IB=NBODY,IMAX+2,-1
               BLX(1,IB)=BLX(1,IB-1)
               BLY(1,IB)=BLY(1,IB-1)
               BLZ(1,IB)=BLZ(1,IB-1)
               XBL(1,IB)=XBL(1,IB-1)
               YBL(1,IB)=YBL(1,IB-1)
               ZBL(1,IB)=ZBL(1,IB-1)
               NX(1,IB)=NX(1,IB-1)
               NY(1,IB)=NY(1,IB-1)
               NZ(1,IB)=NZ(1,IB-1)
               RBC(1,IB)=RBC(1,IB-1)
               DEBC(1,IB)=DEBC(1,IB-1)
               IF (COLE_COLE==1) THEN
                  CHRBC(1,IB)=CHRBC(1,IB-1)
                  TAUBC(1,IB)=TAUBC(1,IB-1)
                  CFRBC(1,IB)=CFRBC(1,IB-1)
                  DCHRBC(1,IB)=DCHRBC(1,IB-1)
                  DTAUBC(1,IB)=DTAUBC(1,IB-1)
                  DCFRBC(1,IB)=DCFRBC(1,IB-1)
               END IF
               RMUB(1,IB)=RMUB(1,IB-1)
            END DO
!
! -- divide the block imax into two
!
            NM=NX(1,IMAX)
            II=1
            IF (NM<NY(1,IMAX)) THEN
               NM=NY(1,IMAX)
               II=2
            END IF
            IF (NM<NZ(1,IMAX)) THEN
               NM=NZ(1,IMAX)
               II=3
            END IF
            N1=NM/2
            N2=NM-N1
!
            IF (II==1) THEN
               BLX(1,IMAX+1)=BLX(1,IMAX)*N2/NM
               BLY(1,IMAX+1)=BLY(1,IMAX)
               BLZ(1,IMAX+1)=BLZ(1,IMAX)
               XBL(1,IMAX+1)=XBL(1,IMAX)-.5*BLX(1,IMAX)+.5*BLX(1,IMAX+1)
               YBL(1,IMAX+1)=YBL(1,IMAX)
               ZBL(1,IMAX+1)=ZBL(1,IMAX)
               NX(1,IMAX+1)=N2
               NY(1,IMAX+1)=NY(1,IMAX)
               NZ(1,IMAX+1)=NZ(1,IMAX)
               BLX(1,IMAX)=BLX(1,IMAX)*N1/NM
               XBL(1,IMAX)=XBL(1,IMAX+1)+.5*(BLX(1,IMAX)+BLX(1,IMAX+1))
               NX(1,IMAX)=N1
            END IF
!
            IF (II==2) THEN
               BLX(1,IMAX+1)=BLX(1,IMAX)
               BLY(1,IMAX+1)=BLY(1,IMAX)*N2/NM
               BLZ(1,IMAX+1)=BLZ(1,IMAX)
               XBL(1,IMAX+1)=XBL(1,IMAX)
               YBL(1,IMAX+1)=YBL(1,IMAX)-.5*BLY(1,IMAX)+.5*BLY(1,IMAX+1)
               ZBL(1,IMAX+1)=ZBL(1,IMAX)
               NX(1,IMAX+1)=NX(1,IMAX)
               NY(1,IMAX+1)=N2
               NZ(1,IMAX+1)=NZ(1,IMAX)
               BLY(1,IMAX)=BLY(1,IMAX)*N1/NM
               YBL(1,IMAX)=YBL(1,IMAX+1)+.5*(BLY(1,IMAX)+BLY(1,IMAX+1))
               NY(1,IMAX)=N1
            END IF
!
            IF (II==3) THEN
               BLX(1,IMAX+1)=BLX(1,IMAX)
               BLY(1,IMAX+1)=BLY(1,IMAX)
               BLZ(1,IMAX+1)=BLZ(1,IMAX)*N2/NM
               XBL(1,IMAX+1)=XBL(1,IMAX)
               YBL(1,IMAX+1)=YBL(1,IMAX)
               ZBL(1,IMAX+1)=ZBL(1,IMAX)-.5*BLZ(1,IMAX)+.5*BLZ(1,IMAX+1)
               NX(1,IMAX+1)=NX(1,IMAX)
               NY(1,IMAX+1)=NY(1,IMAX)
               NZ(1,IMAX+1)=N2
               BLZ(1,IMAX)=BLZ(1,IMAX)*N1/NM
               ZBL(1,IMAX)=ZBL(1,IMAX+1)+.5*(BLZ(1,IMAX)+BLZ(1,IMAX+1))
               NZ(1,IMAX)=N1
            END IF
!
            RBC(1,IMAX+1)=RBC(1,IMAX)
            DEBC(1,IMAX+1)=DEBC(1,IMAX)
            IF (COLE_COLE==1) THEN
               CHRBC(1,IMAX+1)=CHRBC(1,IMAX)
               TAUBC(1,IMAX+1)=TAUBC(1,IMAX)
               CFRBC(1,IMAX+1)=CFRBC(1,IMAX)
               DCHRBC(1,IMAX+1)=DCHRBC(1,IMAX)
               DTAUBC(1,IMAX+1)=DTAUBC(1,IMAX)
               DCFRBC(1,IMAX+1)=DCFRBC(1,IMAX)
            END IF
            RMUB(1,IMAX+1)=RMUB(1,IMAX)
!
         END DO
!
! -- Check is NBODY = NBODY1.  They must be identical, or something must
!    be wrong in determining NBODY and/or NBODY1.
!
         IF (NBODY1/=NBODY) THEN
            WRITE(NW,*) 'Error in routine STRUCTURING: NBODY1/=NBODY.'
            STOP 'Program aborted.  Check error message in file Marco.out'
         END IF
!*                                                                  *
!********************************************************************
      END IF
!
! --- Substructure information can be printed out as in program Sysem
!     if necessary.  Check file sysem.f, line 1594 ff.
!
      RETURN
1     FORMAT(' The model is too large for efficient use of the direct solver.',     &
             /' The code has automatically reverted to the iterative solver.')
!
      END SUBROUTINE STRUCTURING
!
   END SUBROUTINE COMPUTE_3D
!
!
 SUBROUTINE INIT_RHOMAX (DO3D,MBODY,NBMAX,NXMAX,NYMAX,KSYMM,NBODY,SUB_BLOCK,NX,  &
                         NY,XCELL,YCELL,BLX,BLY,NTXE,NCRD,TX_CRDX,TX_CRDY,N_RX,  &
                         RX_X,RX_Y,SUB_RX_MAX,N_SUB_RX,M_RX,                     &
                         RHOMIN,RMAX1,RMIN1,RMAX2,RMIN2)
!
!**** Determine the maximal dimension of the model geometry in the
!     lateral directions
!
! Input parameters:
!
!  MBODY:   Integer,  maximal number of substructures allowed in the


!           program.
!  NBMAX:   Integer,  maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  NXMAX:   Integer,  maximal number of cells in the x-direction
!           in a block.
!  NYMAX:   Integer,  maximal number of cells in the y-direction
!           in a block.
!  KSYMM:   Integer,  controlling parameter for the two-plane symmetry
!           for the 3D model.  KSYMM=1:  symmetric model;  =0:  non-sym-
!           metric model.
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:  Integer SUB_BLOCK(MBODY),  number of blocks in each substructure.
!  NX:      Integer NX(NBMAX,MBODY),  numbers of cells in the x-direction
!           in each block of the substructures.
!  NY:      Integer NY(NBMAX,MBODY),  numbers of cells in the y-direction
!           in each block of the substructures.
!  XCELL:   Real XCELL(NXMAX,NBMAX,MBODY),  x-coordinates of the cells.
!  YCELL:   Real YCELL(NYMAX,NBMAX,MBODY),  y-coordinates of the cells.
!  BLX:     Real BLX(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the x-direction.
!  BLY:     Real BLY(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the y-direction.
!  NTXE:    Integer,  number of excitations.
!  NCRD:    Integer,  number of electrodes or number of different coordinates
!           for the source configuration per excitation.
!  RX_X,RX_Y:  Real*8 RX_X(SUB_RX_MAX,M_RX,NTXE), RX_Y(SUB_RX_MAX,M_RX,NTXE),
!           receiver sites coordinates in the
!           x, and y-directions the receivers of each excitation.
!  N_RX:    Integer N_RX(NTXE),  number of receivers for each excitation.
!  N_SUB_RX:
!  M_RX:    Integer,  maximal number of receivers for controlled source
!           problems.
!  RHOMIN:  Real,  minimum of the lateral grid (rho) which determines
!           the minimum of rho in the Hankel integrals.  RHOMIN=0.1 for
!           the low frequency module and RHOMIN=0.01 for the high
!           frequency module.
!  RMAX1:   Real,  the maximum of the geometric dimensions of the model
!           in the lateral direction.
!  RMIN1:   Real,  the minimum of the geometric dimensions of the model
!           in the lateral direction.
!  RMAX2:   Real,  the maximum of the geometric dimensions of the model.
!  RMIN2:   Real,  the minimum of the geometric dimensions of the model.
!
!
!Output parameter:
!
!
!**** Called by:  main
!
!**** Calls:      none

 IMPLICIT NONE

 INTEGER I,IB,IB2,II,J,JJ,KSYMM,L,LL,LSYM,MBODY,M_RX,NBMAX,NBODY,NCRD,     &
         JX,NN,NSYM,NTXE,NXMAX,NYMAX,NX(NBMAX,MBODY),NY(NBMAX,MBODY),    &
         SUB_BLOCK(MBODY),N_RX(NTXE),N_SUB_RX(M_RX,NTXE),SUB_RX_MAX,DO3D
 REAL RHOMIN,RMAX,RMAX1,RMAX2,RMIN1,RMIN2,RR1,RR2,RR3,RR4,RR5,SX,SY, &
      BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),XCELL(NXMAX,NBMAX,MBODY),    &
      YCELL(NYMAX,NBMAX,MBODY)
 REAL :: RX_X(SUB_RX_MAX,M_RX,NTXE),RX_Y(SUB_RX_MAX,M_RX,NTXE),  &
         TX_CRDX(NCRD,NTXE),TX_CRDY(NCRD,NTXE)
!
! -- Determine the maximal source-receiver distance
!
 RMAX=0.
 DO I=1,NTXE
   DO JJ=1,N_RX(I)
   DO LL=1,N_SUB_RX(JJ,I)
!
! -- Note that circular loops are checked by their maximal and
!    minimal wire locations.
!
     DO J=1,NCRD
       RR1=REAL(SQRT((RX_X(LL,JJ,I)-TX_CRDX(J,I))**2+             &
                     (RX_Y(LL,JJ,I)-TX_CRDY(J,I))**2))
       IF (RR1>RMAX) RMAX=RR1
     END DO
   END DO
   END DO
 END DO
!
 RMAX1=RMAX
 IF (DO3D/=1) GOTO 100
!
! ---- Determine the maximal dimensions of the structure in
!    the lateral direction (the range of Rho).
!    The minimum should always be rhomin
!
   RMAX=0.
   DO IB=1,NBODY
     DO L=1,SUB_BLOCK(IB)
       DO I=1,NX(L,IB)
         DO J=1,NY(L,IB)
           DO IB2=1,NBODY
             DO LL=1,SUB_BLOCK(IB2)
               DO II=1,NX(LL,IB2)
                 DO JJ=1,NY(LL,IB2)
                   IF (IB/=IB2.OR.L/=LL.OR.I/=II.OR.J/=JJ) THEN
                      RR1=SQRT((XCELL(I,L,IB)-XCELL(II,LL,IB2))    &
                        **2+(YCELL(J,L,IB)-YCELL(JJ,LL,IB2))**2)
                   END IF
                   RR2=SQRT((ABS(XCELL(I,L,IB)-XCELL(II,LL,IB2))   &
                       +.5*BLX(LL,IB2))**2+(ABS(YCELL(J,L,IB)-     &
                       YCELL(JJ,LL,IB2)))**2)
                   RR3=SQRT((ABS(XCELL(I,L,IB)-XCELL(II,LL,IB2))   &
                       -.5*BLX(LL,IB2))**2+(ABS(YCELL(J,L,IB)-     &
                       YCELL(JJ,LL,IB2)))**2)
                   RR4=SQRT((ABS(XCELL(I,L,IB)-XCELL(II,LL,IB2)))  &
                      **2+(ABS(YCELL(J,L,IB)-YCELL(JJ,LL,IB2))    &
                       +.5*BLY(LL,IB2))**2)
                   RR5=SQRT((ABS(XCELL(I,L,IB)-XCELL(II,LL,IB2)))  &
                       **2+(ABS(YCELL(J,L,IB)-YCELL(JJ,LL,IB2))    &
                       -.5*BLY(LL,IB2))**2)
                   RMAX=MAX(RR1,RR2,RR3,RR4,RR5,RMAX)
                   IF (KSYMM==1) THEN
                     RR2=SQRT((ABS(XCELL(I,L,IB)+XCELL(II,LL,IB2))   &
                         +.5*BLX(LL,IB2))**2+(ABS(YCELL(J,L,IB)+     &
                         YCELL(JJ,LL,IB2))+.5*BLY(LL,IB2))**2)
                     IF (RR2>RMAX) RMAX=RR2
                   END IF
                 END DO
               END DO
             END DO
           END DO
         END DO
       END DO
     END DO
   END DO
   RMIN2=RHOMIN
   RMAX2=RMAX
!
!-- Determine maximal source-target distance
!
 RMAX=0.
 DO IB=1,NBODY
   DO L=1,SUB_BLOCK(IB)
     DO I=1,NX(L,IB)
       DO J=1,NY(L,IB)
         IF (KSYMM==0) THEN
           NSYM=1
         ELSE
           NSYM=4
         END IF
         DO LSYM=1,NSYM
           IF (LSYM==1) THEN
             SX=1.
             SY=1.
           END IF
           IF (LSYM==2) THEN
             SX=-1.
             SY=1.
           END IF
           IF (LSYM==3) THEN
             SX=1.
             SY=-1.
           END IF
           IF (LSYM==4) THEN
             SX=-1.
             SY=-1.
           END IF
           DO JX=1,NTXE
             NN=NCRD
             DO JJ=1,NN
               RR1=SQRT(REAL((TX_CRDX(JJ,JX)-XCELL(I,L,IB))**2+      &
                             (TX_CRDY(JJ,JX)-YCELL(J,L,IB))**2))
               RR2=SQRT(REAL((ABS(TX_CRDX(JJ,JX)-SX*XCELL(I,L,IB))   &
                            +.5*BLX(L,IB))**2+(ABS(TX_CRDY(JJ,JX)-   &
                             SY*YCELL(J,L,IB)))**2))
               RR3=SQRT(REAL((ABS(TX_CRDX(JJ,JX)-SX*XCELL(I,L,IB))   &
                            -.5*BLX(L,IB))**2+(ABS(TX_CRDY(JJ,JX)-   &
                             SY*YCELL(J,L,IB)))**2))
               RR4=SQRT(REAL((ABS(TX_CRDX(JJ,JX)-SX*XCELL(I,L,IB)))    &
                            **2+(ABS(TX_CRDY(JJ,JX)-SY*YCELL(J,L,IB))  &
                            +.5*BLY(L,IB))**2))
               RR5=SQRT(REAL((ABS(TX_CRDX(JJ,JX)-SX*XCELL(I,L,IB)))    &
                            **2+(ABS(TX_CRDY(JJ,JX)-SY*YCELL(J,L,IB))  &
                            -.5*BLY(L,IB))**2))
               RMAX=MAX(RR1,RR2,RR3,RR4,RR5,RMAX)
             END DO
           END DO
         END DO
       END DO
     END DO
   END DO
 END DO

      RMAX1=AMAX1(RMAX1,RMAX)
!
!-- Determine maximal target-receiver distance
!
 RMAX=0.
 DO JX=1,NTXE
   DO JJ=1,N_RX(JX)
   DO LL=1,N_SUB_RX(JJ,JX)
     DO IB=1,NBODY
       DO L=1,SUB_BLOCK(IB)
         DO I=1,NX(L,IB)
           DO J=1,NY(L,IB)
             IF (KSYMM==0) THEN
             NSYM=1
             ELSE
             NSYM=4
             END IF
             DO LSYM=1,NSYM
             IF (LSYM==1) THEN
             SX=1.
             SY=1.
             END IF
             IF (LSYM==2) THEN
             SX=-1.
             SY=1.
             END IF
             IF (LSYM==3) THEN
             SX=1.
             SY=-1.
             END IF
             IF (LSYM==4) THEN
             SX=-1.
             SY=-1.
             END IF
             RR1=SQRT(REAL((RX_X(LL,JJ,JX)-XCELL(I,L,IB))**2+      &
                           (RX_Y(LL,JJ,JX)-YCELL(J,L,IB))**2))
             RR2=SQRT(REAL((ABS(RX_X(LL,JJ,JX)-SX*XCELL(I,L,IB))   &
                           +.5*BLX(L,IB))**2+(ABS(RX_Y(LL,JJ,JX)-  &
                           SY*YCELL(J,L,IB)))**2))
             RR3=SQRT(REAL((ABS(RX_X(LL,JJ,JX)-SX*XCELL(I,L,IB))   &
                           -.5*BLX(L,IB))**2+(ABS(RX_Y(LL,JJ,JX)-  &
                           SY*YCELL(J,L,IB)))**2))
             RR4=SQRT(REAL((ABS(RX_X(LL,JJ,JX)-SX*XCELL(I,L,IB)))    &
                           **2+(ABS(RX_Y(LL,JJ,JX)-SY*YCELL(J,L,IB)) &
                           +.5*BLY(L,IB))**2))
             RR5=SQRT(REAL((ABS(RX_X(LL,JJ,JX)-SX*XCELL(I,L,IB)))    &
                           **2+(ABS(RX_Y(LL,JJ,JX)-SY*YCELL(J,L,IB)) &
                           -.5*BLY(L,IB))**2))
             RMAX=MAX(RR1,RR2,RR3,RR4,RR5,RMAX)
             END DO
           END DO
         END DO
       END DO
     END DO
   END DO
   END DO
 END DO

 RMAX1=AMAX1(RMAX1,RMAX)
 RMIN1=RHOMIN  ! Always set RMIN1=RHOMIN

! -- RMIN1 can sometimes be zero,  as in the case of 1D downhole
!     computation.

  IF (RMAX1<RHOMIN) RMAX1=RHOMIN

! -- In order to avoid unaccounted errors,  increase the values of
!     RMAX1 and RMAX2

    RMAX2=1.1*RMAX2
100 RMAX1=1.2*RMAX1
!
  END SUBROUTINE INIT_RHOMAX
!
!
      SUBROUTINE TEST_WIRE_PATH (SOURCE_TYPE,DMIN,NCRD,NTXE,TX_CRDX,TX_CRDY,  &
                                 TX_CRDZ,WIRE_PATH,CS_TYPE)
!
!**** Assign internal parameter CS_TYPE as and test 3D wire path
!
!
!  ** Output parameter:
!
!      CS_TYPE:   Transmitter parameter for internal use of Marco, same as
!                 SOURCE_TYPE, except that CS_TYPE is passed further down the
!                 levels of the routines.
!      WIRE_PATH: =0, transmitters lie on flat ground or level;
!                 =1,
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: NCRD,NTXE,SOURCE_TYPE
      REAL, INTENT(IN) :: DMIN
      REAL, INTENT(IN) :: TX_CRDX(NCRD,NTXE),TX_CRDY(NCRD,NTXE),TX_CRDZ(NCRD,NTXE)
!
      INTEGER, INTENT(OUT) :: WIRE_PATH,CS_TYPE
!
      INTEGER :: J,I
!
!  -- Define cs_type
!
      IF (SOURCE_TYPE==1) CS_TYPE=4  ! it is IMPORTANT to set cs_type to 4 so that
                                     ! routine one_d_green will take out charge terms for
                                     ! loops, unless source_type is passed into one_d_green.
      IF (SOURCE_TYPE==2) CS_TYPE=3
      IF (SOURCE_TYPE==3) CS_TYPE=9
!
!  -- Test the special case of vertical electric bipoles, CS_TYPE=2.
!
!     Analytical integration of the bipole is used for strictly vertical
!     current bipole (CS_TYPE=2).  However,  this function is possible if
!     all the transmitters in the computation are vertical bipoles.  If
!     vertical bipoles are computed together with other non-vertical bipoles
!     all integrations along the bipole lines will be numerical.  This is
!     due to the fact that the Hankel kernels are not designed to compute
!     the integrated and non-integrated (along z') simultaneously.
!
      IF (SOURCE_TYPE==2) THEN
         DO J=1,NTXE
            DO I=2,NCRD
               IF (ABS(TX_CRDX(1,J)-TX_CRDX(I,J))>DMIN.OR.  &
                   ABS(TX_CRDY(1,J)-TX_CRDY(I,J))>DMIN) THEN
                  GOTO 100
               END IF
            END DO
         END DO
         CS_TYPE=2    ! Strictly vertical bipoles are integrated analytically in the kernels
         WIRE_PATH=0  !
!
         RETURN       ! return if cs_type=2
!
      END IF
!
  100 WIRE_PATH=0
!
      DO J=1,NTXE
!
         DO I=2,NCRD
            IF (ABS(TX_CRDZ(1,J)-TX_CRDZ(I,J))>DMIN) THEN
                WIRE_PATH=1
                EXIT
            END IF
         END DO
!
      END DO
!
      END SUBROUTINE TEST_WIRE_PATH
!
!
      SUBROUTINE INIT_CMPLX_CD_1D(NW,FRQ,COLE_COLE,MLAYER,KANIS,HVK,         &
                                  RES_LYR,CHRG_LYR,TAU_LYR,FRQC_LYR,         &
                                  RMU_LYR,RESP_LYR,DCHRG_LYR,DTAU_LYR,       &
                                  DFRQC_LYR,CDH,CDV,KKH)
!
!**** Compute the complex conductivities of the earths and the cells
!
!   Note that units 61 and 62 are used to read and store cells
!   conductivity parameters.   The reading sequence must be consistent
!   with the writing sequence in routine READATA.


!Input parameters:

!  FRQ:    Real,  the frequency.
!  COLE_COLE:    Integer,  parameter controlling whether the model (including
!          the earth) is polarizable.  If so,  Cole-Cole models are used
!          to represent the complex resistivities of the model.
!  MLAYER: Integer,  number of layers of the earth.
!  KANIS:  Integer,  parameter controlling whether the earth is vertically
!          anisotropic in conductivity.  KANIS=1, yes;  =0,  no.
!  HVK:     Real HVK(0:MLAYER), the anisotropy coefficients of
!           the layer conductivities as defined by the square
!           root of the ratio of horizontal conductivity to
!           vertical conductivity.
!  RES_LYR:  Real RES_LYR(MLAYER),  resistivities of each layer of the earth.
!  CHRG_LYR: Real CHRG_LYR(MLAYER),  chargeabilities of the earths.
!  TAU_LYR: Real TAU_LYR(MLAYER),  time constants of the earths.
!  FRQC_LYR: Real FRQC_LYR(MLAYER), frequency constants of the earths.
!  RESP_LYR:   Real RESP_LYR(MLAYER),  dielectric permittivities of the earths.
!  DCHRG_LYR: Real DCHRG_LYR(MLAYER), chargeabilities of the frequency-
!           dependent permittivities of the earth as described by
!           Cole-Cole models.
!  DTAU_LYR: Real DTAU_LYR(MLAYER),  time constants of the frequency-
!           dependent permittivities of the earth.
!  DFRQC_LYR: Real DFRQC_LYR(MLAYER), frequency constants of the frequency-
!           dependent permittivities of the earth.
!  RMU
!
! Output parameters:
!
!  CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!          the layers in the lateral direction including the
!          air (layer 0).
!  CDV:    Complex CDV(0:MLAYER),  complex conductivities of
!          the layers in the vertical direction including the
!          air (layer 0).
!  KKH:    Complex(*8) KKH(0:MLAYER),  square ( **2) of the complex wave
!          number of the layers (in the lateral direction) including
!          the air (layer number 0).
!
!**** Called by:  main
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL AIRCD,FRQ,MU0,EPSL0,OMEGA,PI,TOLCC
      INTEGER I,KANIS,COLE_COLE,MLAYER,NW
      COMPLEX ONE,SIG,P,CALF,DSIG,DP,DCALF,WMU,CDH(0:MLAYER),                &
              CDV(0:MLAYER),KKH(0:MLAYER)
      REAL RES_LYR(MLAYER),CHRG_LYR(MLAYER),TAU_LYR(MLAYER),                       &
           FRQC_LYR(MLAYER),RESP_LYR(MLAYER),DCHRG_LYR(MLAYER),                      &
           DTAU_LYR(MLAYER),DFRQC_LYR(MLAYER),HVK(0:MLAYER),RMU_LYR(MLAYER)
!
      DATA ONE /(1.,0.)/, PI /3.141592654/, EPSL0 /8.854156E-12/,            &
           TOLCC /1.E-12/
!
!-- The conductivity of the air is set to 1.E-20.  This is
!   necessary for the elimination of singularity of the kernels
!   of the Hankel transforms at high frequencies.  As thus,
!   there should be no air layers added to the earth.  Such
!   an air layer may reduce the accuracy of the results

      AIRCD=1.E-20

!-- Issue warnings if there is an air layer in the input

      IF (RES_LYR(1)>=1.E+8) THEN
         WRITE (*,1010)
         WRITE (NW,1010)
      END IF
!
      MU0=PI*4.E-7
      OMEGA=2.*PI*FRQ
      WMU=CMPLX(0.,MU0*OMEGA)
      CDH(0)=CMPLX(AIRCD,EPSL0*OMEGA)
      DO I=0,MLAYER
         IF (KANIS==0) HVK(I)=1.

!-- Note that the values of RESP_LYR, DCHRG_LYR etc for the 1D layers
!   have been assigned in the routine READATA regardless of the
!   value of HIGH_FRQ.
         IF (I/=0) THEN
            SIG=CMPLX(1./RES_LYR(I),0.)
            DSIG=CMPLX(0.,OMEGA*EPSL0*RESP_LYR(I))
            IF (COLE_COLE/=1) THEN
               CDH(I)=SIG+DSIG
            ELSE
!
!  -- Add Cole-Cole models to the conductivities and permitivities
!
               P=(0.,0.)
               DP=(0.,0.)
               IF ((TAU_LYR(I)>TOLCC).AND.(FRQC_LYR(I)>TOLCC))     &
                   P=CMPLX(0.,OMEGA*TAU_LYR(I))**FRQC_LYR(I)
               IF ((DTAU_LYR(I)>TOLCC).AND.(DFRQC_LYR(I)>TOLCC))   &
                   DP=CMPLX(0.,OMEGA*DTAU_LYR(I))**DFRQC_LYR(I)
               CALF=CMPLX((1.-CHRG_LYR(I)),0.)
               DCALF=CMPLX((1.-DCHRG_LYR(I)),0.)
               CDH(I)=SIG*(ONE+P)/(ONE+CALF*P)+DSIG*(ONE+DP)  &
                      /(ONE+DCALF*DP)
            END IF
         END IF

         CDV(I)=CDH(I)/HVK(I)**2
         KKH(I)=WMU*CDH(I)
      END DO
!
!  -- Multiply KKH with rmu
      DO I=1,MLAYER
         KKH(I)=KKH(I)*RMU_LYR(I)
      END DO
!
      RETURN
 1010 FORMAT (' WARNING: THE INTRODUCTION OF AN AIR LAYER MAY REDUCE',  &
              ' THE ACCURACY'/10X,'OF THE RESULTS!  USE NEGATIVE',      &
              ' Z-COORDINATES INSTEAD.')
      END

!**** End of INIT_CMPLX_CD_1D
!
!
 SUBROUTINE INIT_CMPLX_CD_3D (FRQ,COLE_COLE,NBMAX,NBODY,SUB_BLOCK,NCELL,BLZ,ZBND,       &
                              NLAYER,RMU,NSUBCM,CDB,RBC,CHRBC,TAUBC,CFRBC,DEBC,RMUB)
!-----------------------------------------------------------------------------------
!**** Compute the complex conductivities of the earths and the cells
!
!   Note that units 61 and 62 are used to read and store cells
!   conductivity parameters.   The reading sequence must be consistent
!   with the writing sequence in routine READATA.
!   No need ot check outcrop since this is fixed in READ3D
!
!Input parameters:
!
!  FRQ:    Real,  the frequency.
!  COLE_COLE:    Integer,  parameter controlling whether the model (including
!          the earth) is polarizable.  If so,  Cole-Cole models are used
!          to represent the complex resistivities of the model.
!  NBMAX:   Integer,  maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:  Integer SUB_BLOCK(NBODY),  number of blocks in each substructure.
!  NCELL:   Integer NCELL(NBMAX,NBODY),  number of cells in each block
!           of the substructures.
!  NSUBCM:  Integer,  maximal number of cells in a substructure.
!  CDB:    COMPLEX CDB(NSUBCM,NBMAX),  working array for the
!          complex conductivities of the cells in a substructure.
!          Its values are all stored on the disk in unit 62
!  RBC:     Real RBC(NBMAX,NBODY),  resistivities of each blocks of the
!           substructures.
!  CHRBC:   Real CHRBC(NBMAX,NBODY),  chargeabilities of each blocks of
!           the substructures.
!  TAUBC:   Real TAUBC(NBMAX,NBODY),  time constants of each blocks of
!           the substructures.
!  CFRBC:   Real CFRBC(NBMAX,NBODY),  frequency constants of each blocks of
!           the substructures.
!
!  DEBC:   Real DEBC(NBMAX,NBODY), relative dielectric constants of the blocks.
!
!  RMUB:    Real RMUB(NBMAX,NBODY), relative permeability of the blocks.
!
!  ZBND:    layer boundaries
!  BLZ:     block centre cordinates in z.   NOTE that a block must be restricted within
!           a single layer.  Otherwise cell z-coordinated must be used in this routine
!  RMU:     layer permeability
!
! Output parameters:
!
!  Complex conductivities of the 3D cells are stored in unit
!  62 on the disk.
!
!**** Called by:  main
!**** Calls:      none

 IMPLICIT NONE

 REAL, PARAMETER :: TOL=1.E-6, PI=3.141592654, EPSL0=8.854156E-12
 COMPLEX, PARAMETER :: ONE = (1.,0.)
 INTEGER I,IB,J,COLE_COLE,NBMAX,NBODY,NSUBCM,NOB,IOB,NLAYER
 COMPLEX CDB(NSUBCM,NBMAX)
 INTEGER SUB_BLOCK(NBODY),NCELL(NBMAX,NBODY)
 REAL RBC(NBMAX,NBODY),CHRBC(NBMAX,NBODY),TAUBC(NBMAX,NBODY),           &
      CFRBC(NBMAX,NBODY),DEBC(NBMAX,NBODY),RMUB(NBMAX,NBODY),          &
      BLZ(NBMAX,NBODY),ZBND(0:NLAYER),RMU(NLAYER)

 REAL FRQ,OMEGA
 COMPLEX P,SIG,CALF

!  Assign 1D conductivities and add displacement current term to the air

 OMEGA=2.*PI*FRQ

 DO IB=1,NBODY
   DO J=1,SUB_BLOCK(IB)
     SIG=CMPLX(1./RBC(J,IB),0.)
     IF (COLE_COLE == 1 .AND. TAUBC(J,IB) > TOL .AND.  &
!  Add Cole-Cole models to the conductivities and permittivities
       CFRBC(J,IB) > TOL) THEN
       P = CMPLX (0., OMEGA * TAUBC(J,IB))**CFRBC(J,IB)
       CALF = CMPLX ((1. - CHRBC(J,IB)), 0.)
       SIG = SIG * (ONE + P)/ (ONE + CALF*P)
     END IF

!  Store the cell conductivity in array CDB for writing into file CONDT (unit 62)

     DO I=1,NCELL(J,IB)
       CDB(I,J)=SIG+CMPLX(0.,DEBC(J,IB)*EPSL0*OMEGA)
     END DO
   END DO
!
!  Multiply relative permeabilities normalised by those of the layers.
! *** Block centre coordinate is used instead of cell centres!  This simplifies the code
!     at the cost of restricting the blocks to be within every single layer.

   NOB=0
   DO J=1,SUB_BLOCK(IB)
     LP1: DO I=1,NCELL(J,IB)
       DO IOB=NLAYER-1,0,-1
         IF (BLZ(J,IB) >= ZBND(IOB)) THEN
           NOB=IOB+1
           CDB(I,J)=CDB(I,J)*RMUB(J,IB)/RMU(NOB)
           CYCLE LP1
         END IF
       END DO
     END DO LP1
   END DO
! --- Store the cell conductivity to file CONDT (unit 62)

   WRITE (62) ((CDB(I,J),I=1,NCELL(J,IB)),J=1,SUB_BLOCK(IB))

 END DO

 REWIND (61)
 REWIND (62)

 END SUBROUTINE INIT_CMPLX_CD_3D
!
!
      SUBROUTINE INIT_COMPUTATION (DMIN,MBODY,NBMAX,NXMAX,NYMAX,NZMAX,           &
                                   CS_TYPE,KSYMM,NTXE,SUB_RX_MAX,M_RX,           &
                                   N_RX,N_SUB_RX,RX_X,RX_Y,RX_Z,                 &
                                   ZMT,MT_PROFL,MT_STATN,XRMT,YRMT,              &
                                   NBODY,SUB_BLOCK,NX,NY,NZ,BLX,BLY,BLZ,XBL,YBL, &
                                   ZBL,X1,Y1,Z1,NCT,NET,NCELL,                   &
                                   NCTT,NEQ,XCELL,YCELL,ZCELL,KCELL,             &
                                   KBOUND,MLAYER,ZBND,                           &
                                   KSFT,KEYSF,KGHP,BLMIN)
!
!**** Initial computations
!
!   Set input parameters to those suitable for computation,
!   discretize the blocks into cell,  etc.
!
!   Note that after this routine is excuted,  the arrays BLX,  BLY,
!   and BLZ become the dimensions of the cells
!
!
! Input parameters:
!
!  DMIN:    Real,  minimal dimension value that is considered to be
!           zero.  DMIN=0.1 for the low frequency module and DMIN=0.001
!           for the high frequency module.
!  MBODY:   Integer(*4),  maximal number of substructures allowed in
!           the program.
!  NBMAX:   Integer,  maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  NXMAX:   Integer,  maximal number of cells in the x-direction
!           in a block.
!  NYMAX:   Integer,  maximal number of cells in the y-direction
!           in a block.
!  NZMAX:   Integer,  maximal number of cells in the z-direction
!           in a block.
!  CS_TYPE:    Integer,  type of excitation and configuration.
!           See documentation "MARCO.DOC" for description.
!  KSYMM:   Integer,  controlling parameter for the two-plane symmetry
!           fo the 3D model.  KSYMM=1:  symmetric model;  =0:  non-sym-
!           metric model.
!  NTXE:    Integer,  number of excitations.
!  N_RX:    Integer N_RX(NTXE),  number of receiver sites.
!  N_SUB_RX:
!  MT_STATN:    Integer,  number of receivers on one profile for MT probelms.
!  RX_X,RX_Y,RX_Z:  Real*8 RX_X(SUB_RX_MAX,M_RX,NTXE), RX_Y(SUB_RX_MAX,M_RX,NTXE),
!           REAL RX_Z(SUB_RX_MAX,M_RX,NTXE), receiver sites coordinates in the x, y,
!           and z-directions for receiver sites,  respectively.
!  ZMT:     Real,  z coordinate of the measuring plane for MT stations.
!  M_RX:    Integer,  maximal number of receivers for controlled source
!           problems and maximal number of receivers on one profile for
!           MT problems.
!  MT_PROFL:    Integer,  number of profiles for MT problems.
!  XRMT:    Real XRMT(MT_PROFL),  x-coordinates of the MT profiles.
!  YRMT:    Real YRMT(MT_STATN),  y-coordinates of the MT profiles.
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:   Integer SUB_BLOCK(MBODY),  number of blocks in each substructure.
!  NX:      Integer NX(NBMAX,MBODY),  numbers of cells in the x-direction
!           in each block of the substructures.
!  NY:      Integer NY(NBMAX,MBODY),  numbers of cells in the y-direction
!           in each block of the substructures.
!  NZ:      Integer NZ(NBMAX,MBODY),  numbers of cells in the z-direction
!           in each block of the substructures.
!  BLX:     Real BLX(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the x-direction.
!  BLY:     Real BLY(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the y-direction.
!  BLZ:     Real BLZ(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the z-direction.
!  XBL:     Real XBL(NBMAX,MBODY),  x-coordinates of each blocks in the
!           substructures.
!  YBL:     Real YBL(NBMAX,MBODY),  y-coordinates of each blocks in the
!           substructures.
!  ZBL:     Real ZBL(NBMAX,MBODY),  z-coordinates of each blocks in the
!           substructures.
!  X1, Y1, Z1: Real X1(NXMAX), Y1(NYMAX), Z1(NZMAX),  working arrays for
!           center coordinates of the cells.
!  ZBND:    Real ZBND(0:MLAYER), the z-coordinates of the layer
!           boundaries with the air-earth interface being always
!           0 (zbnd(0)=0).
!
!
! Output parameters:
!
!  NCT:     Integer NCT(MBODY),  number of cells in each substructure.
!  NET:     Integer NET(MBODY),  number of unknowns in each substructure.
!           NET=3*NCT.
!  NCELL:   Integer NCELL(NBMAX,MBODY),  number of cells in each block
!           of the substructures.
!  NCTT:     Integer,  total number of cells for the whole structure.
!  NEQ:     Integer,  total number of cells in one quadrant of a symmetric
!           model.
!  XCELL:   Real XCELL(NXMAX,NBMAX,MBODY),  x-coordinates of the cells.
!  YCELL:   Real YCELL(NYMAX,NBMAX,MBODY),  y-coordinates of the cells.
!  ZCELL:   Real ZCELL(NZMAX,NBMAX,MBODY),  z-coordinates of the cells.
!  KCELL:   Integer KCELL(MBODY), controlling parameter whether all cells
!           in each substructure are equal-sized.
!  KBOUND:  Integer,  parameter controlling whether the structure
!           intersects any layer boundary.  kbound=1: yes; =0: no.
!  KFST, KEYSF: Integer KFST, KEYSF(NBMAX,MBODY),  controlling parameters
!           whether there are outcropping cells for the whole structure
!           (KSFT) and for the blocks in each substructure (KEYSF).
!           KEYSF, KSFT=1: yes; KEYSF, KSFT=0:,no.
!  KGHP:    Integer, parameter controlling whether there is a receiver
!           located within the target.
!  BLMIN:   Real,  redius and height of a cylinder to be removed
!           from computation for the treatment of singularity
!           arising in the computation of magnetic fields due to
!           an outcropping cell.  See description for KUTCRP
!           in routine THR_D_GREEN for more details.
!  BLX:     Real BLX(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the x-direction.
!  BLY:     Real BLY(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the y-direction.
!  BLZ:     Real BLZ(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the z-direction.
!
!**** Called by:  main
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER SUB_RX_MAX,KBOUND,KGHP,KSFT,CS_TYPE,KSYMM,MBODY,MLAYER,        &
              M_RX,NBMAX,NBODY,NCTT,NEQ,MT_PROFL,MT_STATN,NSR,NSR1,          &
              NTXE,NXMAX,NYMAX,NZMAX,                                        &
              NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY),               &
              NCELL(NBMAX,MBODY),NCT(MBODY),NET(MBODY),                      &
              KCELL(MBODY),SUB_BLOCK(MBODY),KEYSF(NBMAX,MBODY),              &
              N_RX(NTXE),N_SUB_RX(M_RX,NTXE)
      REAL, INTENT(IN) :: RX_X(SUB_RX_MAX,M_RX,NTXE),                        &
                          RX_Y(SUB_RX_MAX,M_RX,NTXE),                        &
                          RX_Z(SUB_RX_MAX,M_RX,NTXE)
      REAL BLMIN,DMIN,XJ,YJ,ZJ,ZMT,XRMT(MT_PROFL),YRMT(MT_STATN),            &
           BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),               &
           XBL(NBMAX,MBODY),YBL(NBMAX,MBODY),ZBL(NBMAX,MBODY),               &
           XCELL(NXMAX,NBMAX,MBODY),YCELL(NYMAX,NBMAX,MBODY),                &
           ZCELL(NZMAX,NBMAX,MBODY),X1(NXMAX),Y1(NYMAX),Z1(NZMAX),           &
           ZBND(0:MLAYER)
      INTEGER II,I,IB,J,JJ,JB,K,L
!
      NCTT=0
      DO IB=1,NBODY
         NCT(IB)=0
         DO I=1,SUB_BLOCK(IB)
            NCELL(I,IB)=NX(I,IB)*NY(I,IB)*NZ(I,IB)
            NCT(IB)=NCT(IB)+NCELL(I,IB)
         END DO
!
         NET(IB)=3*NCT(IB)
         NCTT=NCTT+NCT(IB)
      END DO
!
! ---- NEQ is the total number of cells in a quater used by
!    group theoretical reduction
!
      IF (KSYMM==1.AND.CS_TYPE/=1) THEN
         NEQ=0
         DO IB=1,NBODY
            NEQ=NEQ+NET(IB)
         END DO
      END IF
!
! ----- Dividing the blocks into cells
!
      DO IB=1,NBODY
         DO I=1,SUB_BLOCK(IB)
            CALL INIT_DISCRETIZATION(BLX(I,IB),BLY(I,IB),BLZ(I,IB),NX(I,IB), &
                                     NY(I,IB),NZ(I,IB),XBL(I,IB),YBL(I,IB),  &
                                     ZBL(I,IB),X1,Y1,Z1)
! ----- Note BLX BLY and BLZ become now the dimensions of the cells
            DO J=1,NX(I,IB)
               XCELL(J,I,IB)=X1(J)
            END DO
            DO J=1,NY(I,IB)
               YCELL(J,I,IB)=Y1(J)
            END DO
            DO J=1,NZ(I,IB)
               ZCELL(J,I,IB)=Z1(J)
            END DO
         END DO
      END DO
!
!
! --- Determine if all the cells in a substructure have the same size.
!   KCELL(ib)=1: yes; KCELL(ib)=0: no.
      DO IB=1,NBODY
         KCELL(IB)=1
         DO L=2,SUB_BLOCK(IB)
            IF (ABS(BLX(L,IB)-BLX(1,IB))>DMIN.OR.  &
                ABS(BLY(L,IB)-BLY(1,IB))>DMIN.OR.  &
                ABS(BLZ(L,IB)-BLZ(1,IB))>DMIN) KCELL(IB)=0
         END DO
      END DO
!
!
! ----- Check if the structure intersects any layer boundary.
!     kbound=1: yes; =0: no.
!
      KBOUND=0
      DO IB=1,NBODY
         DO L=1,SUB_BLOCK(IB)
            DO I=1,NZ(L,IB)
               DO J=MLAYER-1,0,-1
                  IF (ZCELL(I,L,IB)>=ZBND(J)) THEN
                     NSR=J+1
                     GOTO 10
                  END IF
               END DO
               NSR=0
   10          IF (IB==1.AND.L==1.AND.I==1) THEN
                  NSR1=NSR
                  CYCLE
               END IF
               IF (NSR/=NSR1) THEN
                  KBOUND=1
                  GOTO 100
               END IF
            END DO
         END DO
      END DO
!
! --- Determine if there are any outcropping blocks
!   KEYSF, KSFT=1: yes; KEYSF, KSFT=0:,no.
!
  100 DO I=1,NBODY
         DO L=1,SUB_BLOCK(I)
            IF (ABS(ZCELL(1,L,I)-.5*BLZ(L,I))<DMIN) THEN
               KEYSF(L,I)=1
            ELSE
               KEYSF(L,I)=0
            END IF
         END DO
      END DO
      KSFT=0
      DO I=1,NBODY
         DO L=1,SUB_BLOCK(I)
            IF (KEYSF(L,I)==1) THEN
               KSFT=1
               GOTO 200
            END IF
         END DO
      END DO
!
! ---- Determine if there are downhole receivers that are
!    located in the 3D structure.  If so, of if the structure
!    outcrops, the Green's functions, (especially the magnetic
!    Green's function), will be separated into primary and
!    secondary parts in computation.
!
!    kghp=1: no receiver within the body; =0: yes.
!
!    Note the parameter kghp has been disabled lately.
!    Now the Green's functions are no more separated into
!    primary and secondary terms in computing the EM fields
!    at receiver sites.  The following design for kghp is
!    still perserved.  But it is not effective.
!
  200 KGHP=1
!
      IF (KSFT==1) THEN
         KGHP=0
         GOTO 300
      END IF
!
      IF (CS_TYPE==1) THEN
!
         IF (ZMT>=DMIN) THEN
!
!---  Check if any receivers are located on the top or within
!     the body if zmt >0.
!
            KGHP=1
!
            DO JB=1,NBODY
               DO J=1,SUB_BLOCK(JB)
! ---  Note that blx, bly and blz are the dimensions of the cells
!      after discretization.
                  XJ=.5*BLX(J,JB)*NX(J,JB)+DMIN
                  YJ=.5*BLY(J,JB)*NY(J,JB)+DMIN
                  ZJ=.5*BLZ(J,JB)*NZ(J,JB)+DMIN
                  DO I=1,MT_PROFL
                     DO K=1,MT_STATN
                        IF (XRMT(I)>XBL(J,JB)-XJ.AND.XRMT(I)<XBL(J,JB)   &
                            +XJ.AND.YRMT(K)>YBL(J,JB)-YJ.AND.YRMT(K)     &
                            <YBL(J,JB)+YJ.AND.ZMT>ZBL(J,JB)-ZJ.AND.      &
                            ZMT<ZBL(J,JB)+ZJ) THEN
                           KGHP=0
                           GOTO 300
                        END IF
                     END DO
                  END DO
               END DO
!
            END DO
         END IF
         GOTO 300
      END IF
!
!---  Check downhole receivers
!
      DO JB=1,NBODY
         DO J=1,SUB_BLOCK(JB)
! --  Note that blx, bly and blz are the dimensions of the cells
!   after discretization.
            XJ=.5*BLX(J,JB)*NX(J,JB)+DMIN
            YJ=.5*BLY(J,JB)*NY(J,JB)+DMIN
            ZJ=.5*BLZ(J,JB)*NZ(J,JB)+DMIN
            DO II=1,NTXE
               DO I=1,N_RX(II)
                  DO JJ=1,N_SUB_RX(I,II)
                     IF (RX_X(JJ,I,II)>XBL(J,JB)-XJ.AND.RX_X(JJ,I,II)<XBL(J,JB)   &
                         +XJ.AND.RX_Y(JJ,I,II)>YBL(J,JB)-YJ.AND.RX_Y(JJ,I,II)     &
                         <YBL(J,JB)+YJ.AND.RX_Z(JJ,I,II)>ZBL(J,JB)-ZJ.AND.        &
                         RX_Z(JJ,I,II)<ZBL(J,JB)+ZJ) THEN
                        KGHP=0
                        GOTO 300
                     END IF
                  END DO
               END DO
            END DO
         END DO
      END DO
!
! ---- In case of outcropping structures a minmal length, blmin,
!    is determined which is the radius and the height of a
!    small cylinder to be excluded in the numerical integration
!    of the magnetic Green's functions for the treatments of
!    singularities when the receiver is located on the top of
!    an outcropping cell. Note that the electric fields on the
!    top of outcropping cells are determined be the scattering
!    currents directly.
!
!    Note that blmin is also used for vertical bipole
!    excitations. In order to avoid singularity that may occur
!    due to inapproperiate discretizations of the structures
!    which makes some cell centers coincide with the source
!    lines, the current lines may be cut into many intervals
!    with a distance of blmin to the receivers of cell centers.
!
  300 BLMIN=100000.
      DO IB=1,NBODY
         DO L=1,SUB_BLOCK(IB)
            BLMIN=AMIN1(BLMIN,BLX(L,IB),BLY(L,IB),BLZ(L,IB))
         END DO
      END DO
!
!--- Take one tenth of the minimal dimension as blmin
!
      BLMIN=BLMIN/10.

!
      RETURN
      END
!
!**** End of INIT_COMPUTATION
!
!
      SUBROUTINE INIT_3D_INPUT_TEST(NW,KAUTO,KSYMM,DMIN,NSUBCM,MBODY,        &
                                    NBMAX,NXMAX,NYMAX,NZMAX,NBODY,TRGT_BLCK, &
                                    BLCK_LX,BLCK_LY,BLCK_LZ,BLCK_CX,BLCK_CY, &
                                    BLCK_CZ,NCT,SUB_BLOCK,NX,NY,NZ,BLX,BLY,  &
                                    BLZ,XBL,YBL,ZBL,MLAYER,ZBND,ZCELL)
!
!**** Test 3D data
!
!Input parameters:
!
!  NXMAX:   Integer(*4),  maximal number of cells in the x-direction
!           in a block.
!  NYMAX:   Integer(*4),  maximal number of cells in the y-direction
!           in a block.
!  NZMAX:   Integer(*4),  maximal number of cells in the z-direction
!           in a block.
!
!Other parameters for this routine are the same as those in routine
!READATA.
!
!**** Called by:  INIT_INPUT_TEST
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL DMIN,RR1,XI,XJ,YI,YJ,ZI,ZJ
      INTEGER I,IB,II,J,JB,JJ,K,KAUTO,KEYBZ,KK,KSYMM,L,MBODY,MLAYER,   &
              NBMAX,NBODY,TRGT_BLCK,NSR,NSR1,NW
      INTEGER NSUBCM,NXMAX,NYMAX,NZMAX
      INTEGER NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY),         &
              SUB_BLOCK(MBODY),NCT(MBODY)
      REAL BLCK_LX(TRGT_BLCK),BLCK_LY(TRGT_BLCK),BLCK_LZ(TRGT_BLCK),   &
           BLCK_CX(TRGT_BLCK),BLCK_CY(TRGT_BLCK),BLCK_CZ(TRGT_BLCK),   &
           BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),         &
           XBL(NBMAX,MBODY),YBL(NBMAX,MBODY),ZBL(NBMAX,MBODY),         &
           ZCELL(NZMAX,NBMAX,MBODY)
      REAL ZBND(0:MLAYER)
!
      IF (KAUTO/=0) THEN
!**************************************************
!*                                                *
!
! --- Test if there is a block out of quadrant
!
         IF (KSYMM==1) THEN
            DO I=1,TRGT_BLCK
               IF (BLCK_CX(I)-.5*BLCK_LX(I)<-.0001.OR.      &
                   BLCK_CY(I)-.5*BLCK_LY(I)<-.0001) THEN
                  WRITE (NW,*) ' Block #',I,' is out of quadrant I. ',  &
                         ' Program aborted. Please check the input'
                  STOP   &
             'Program aborted. Please check the error messages in Marco.out'
               END IF
            END DO
         END IF
!
! ----- Test if the blocks overlap each other
!
         DO I=1,TRGT_BLCK
            DO J=1,TRGT_BLCK
!
               IF (I/=J) THEN
!
                  XJ=.5*BLCK_LX(J)-DMIN
                  YJ=.5*BLCK_LY(J)-DMIN
                  ZJ=.5*BLCK_LZ(J)-DMIN
                  DO II=1,5
                     DO JJ=1,5
                        DO KK=1,5
                           XI=BLCK_CX(I)-.5*BLCK_LX(I)+BLCK_LX(I)*(II-1.)/4.
                           YI=BLCK_CY(I)-.5*BLCK_LY(I)+BLCK_LY(I)*(JJ-1.)/4.
                           ZI=BLCK_CZ(I)-.5*BLCK_LZ(I)+BLCK_LZ(I)*(KK-1.)/4.
                           IF (XI>BLCK_CX(J)-XJ.AND.XI<BLCK_CX(J)+XJ.AND.  &
                               YI>BLCK_CY(J)-YJ.AND.YI<BLCK_CY(J)+YJ.AND.  &
                               ZI>BLCK_CZ(J)-ZJ.AND.ZI<BLCK_CZ(J)+ZJ) THEN
                               WRITE (NW,*) ' Block #',I,  &
                                 ' overlaps with block #',J
                               WRITE (NW,*)   &
                              'Program aborted.  Please check the input'
                              STOP   &
             'Program aborted. Please check the error messages in Marco.out'
                           END IF
                        END DO
                     END DO
                  END DO
               END IF
!
            END DO
         END DO
!*                                                *
!**************************************************
      END IF
!
      IF (KAUTO==0) THEN
!**************************************************
!*                                                *
         IF (KSYMM==1) THEN
!-------------------------------------------
!|                                         |
            DO IB=1,NBODY
               DO I=1,SUB_BLOCK(IB)
                  IF (XBL(I,IB)-.5*BLX(I,IB)<-.0001.OR.YBL(I,IB)  &
                      -.5*BLY(I,IB)<-.0001) THEN
                     WRITE (NW,*) ' Block #',I,' of substructure #',IB,  &
                            ' is out of quadrant I. ',  &
                            ' Program aborted. Please check the input'
                     STOP   &
             'Program aborted. Please check the error messages in Marco.out'
                  END IF
               END DO
            END DO
!|                                         |
!-------------------------------------------
         ELSE
!-------------------------------------------
!|                                         |
            DO IB=1,NBODY
               DO I=1,SUB_BLOCK(IB)
                  IF (NX(I,IB)>NXMAX.OR.NY(I,IB)>NYMAX.OR.NZ(I,IB)      &
                      >NZMAX) THEN
                     WRITE (NW,*)  &
                             'Cell number in one of the x, y, and z-',  &
                            'direction exceeds the limit.'
                     WRITE (NW,*) 'Program aborted ',  &
                            'Please check the input'
                     WRITE (NW,*)   &
                           'Advice: if you need more cells, please use '  &
                           ,'more blocks.'
                     WRITE (NW,*) 'The limits are set for each block alone.'
                     STOP   &
             'Program aborted. Please check the error messages in Marco.out'
                  END IF
               END DO
            END DO
!
! ----- Test if the blocks overlap each other
!
            DO IB=1,NBODY
               DO I=1,SUB_BLOCK(IB)
                  DO JB=1,NBODY
                     DO J=1,SUB_BLOCK(JB)
!
                        IF (IB/=JB.OR.I/=J) THEN
!
                           XJ=.5*BLX(J,JB)-DMIN
                           YJ=.5*BLY(J,JB)-DMIN
                           ZJ=.5*BLZ(J,JB)-DMIN
                           DO II=1,5
                              DO JJ=1,5
                              DO KK=1,5
                              XI=XBL(I,IB)-.5*BLX(I,IB)+BLX(I,IB)*(II-1.)/4.
                              YI=YBL(I,IB)-.5*BLY(I,IB)+BLY(I,IB)*(JJ-1.)/4.
                              ZI=ZBL(I,IB)-.5*BLZ(I,IB)+BLZ(I,IB)*(KK-1.)/4.
                              IF (XI>XBL(J,JB)-XJ.AND.XI<XBL(J,JB)           &
                                  +XJ.AND.YI>YBL(J,JB)-YJ.AND.               &
                                  YI<YBL(J,JB)+YJ.AND.ZI>ZBL(J,JB)           &
                                  -ZJ.AND.ZI<ZBL(J,JB)+ZJ) THEN
                              WRITE (NW,*) ' Block #',I,                     &
                                 ' of substructure #',IB,                    &
                                 ' overlaps with block #',J,                 &
                                 ' of substructure #',JB,                    &
                              'Program aborted.  Please check the input'
                              STOP   &
             'Program aborted. Please check the error messages in Marco.out'
                              END IF
                              END DO
                              END DO
                           END DO
                        END IF
!
                     END DO
                  END DO
               END DO
            END DO
!|                                         |
!-------------------------------------------
         END IF
!*                                                *
!**************************************************
      END IF
!
      DO IB=1,NBODY
         IF (NCT(IB)>NSUBCM) THEN
            WRITE (NW,*) ' Total number of cells of a substructure',  &
                         ' exceeds maximum allowed!  Program aborted.'
            STOP   &
             'Program aborted. Please check the error messages in Marco.out'
         END IF
      END DO
!
! --- Check if there is any cell across a layer boundary.
!   KEYBZ=1: yes; KEYBZ=0: no.
      KEYBZ=0
      DO IB=1,NBODY
         DO L=1,SUB_BLOCK(IB)
            DO I=1,NZ(L,IB)
               DO J=MLAYER-1,0,-1
! ---  In order to increase stability .499 is used here instead of .5
                  IF (ZCELL(I,L,IB)-.499*BLZ(L,IB)>=ZBND(J)) THEN
                     NSR=J+1
                     GOTO 10
                  END IF
               END DO
               NSR=0
   10          DO J=MLAYER-1,0,-1
                  IF (ZCELL(I,L,IB)+.499*BLZ(L,IB)>=ZBND(J)) THEN
                     NSR1=J+1
                     GOTO 20
                  END IF
               END DO
               NSR1=0
   20          IF (NSR/=NSR1) THEN
                  KEYBZ=1
                  GOTO 100
               END IF
            END DO
         END DO
      END DO
!
! ---- It is not allowed to have a cell lying across any layer
!   boundary due to the restrictions arising from the separation
!   of the Green's functions into primary and secondary parts.
!
  100 IF (KEYBZ==1) THEN
         WRITE (NW,*) ' It is not allowed to have a cell across a',       &
                      ' layer boundary.  Please re-discretize the body',  &
                      ' in the z-direction.'
         STOP   &
             'Program aborted. Please check the error messages in Marco.out'
      END IF
!
! ---- No outcroping above the earth's surface is allowed
!
!    Tests have shown that the current version is not capable of
!    modeling models in free space
!
      DO IB=1,NBODY
         DO L=1,SUB_BLOCK(IB)
            DO K=1,NZ(L,IB)
               RR1=ZCELL(K,L,IB)-.5*BLZ(L,IB)
               IF (RR1<-.001) THEN
                  WRITE (NW,*) ' A block is above the earths surface.',  &
                         ' Please check the input.  Program aborted.'
                  STOP   &
             'Program aborted. Please check the error messages in Marco.out'
               END IF
            END DO
         END DO
      END DO
!
!
      END SUBROUTINE INIT_3D_INPUT_TEST
!
!**** End of INIT_3D_INPUT_TEST
!
!
      SUBROUTINE INIT_DISCRETIZATION (BLX,BLY,BLZ,NX,NY,NZ,XCD,YCD,ZCD,X,Y,Z)
!
!*****  Discretize a blck into equal-size cells
!
      IMPLICIT NONE
!
      REAL BLX,BLY,BLZ,X,XCD,Y,YCD,Z,ZCD
      INTEGER I,N1,NX,NY,NZ
      DIMENSION X(NX),Y(NY),Z(NZ)
      BLX=BLX/FLOAT(NX)
      BLY=BLY/FLOAT(NY)
      BLZ=BLZ/FLOAT(NZ)
      IF (ABS(AMOD(FLOAT(NX),2.))<.2) THEN
         N1=NX/2
         DO I=1,NX
            X(I)=BLX*(FLOAT(I)-FLOAT(N1))-BLX/2.+XCD
         END DO
      ELSE
         N1=NX/2+1
         DO I=1,NX
            X(I)=BLX*(I-N1)+XCD
         END DO
      END IF
      IF (ABS(AMOD(FLOAT(NY),2.))<.2) THEN
         N1=NY/2
         DO I=1,NY
            Y(I)=BLY*(FLOAT(I)-FLOAT(N1)-.5)+YCD
         END DO
      ELSE
         N1=NY/2+1
         DO I=1,NY
            Y(I)=BLY*(FLOAT(I)-FLOAT(N1))+YCD
         END DO
      END IF
      IF (ABS(AMOD(FLOAT(NZ),2.))<.2) THEN
         N1=NZ/2
         DO I=1,NZ
            Z(I)=BLZ*(FLOAT(I)-FLOAT(N1)-.5)+ZCD
         END DO
      ELSE
         N1=NZ/2+1
         DO I=1,NZ
            Z(I)=BLZ*(FLOAT(I)-FLOAT(N1))+ZCD
         END DO
      END IF
      RETURN
      END
!
!
      SUBROUTINE INIT_REF_CELL_DIM(NW,MBODY,NBMAX,NBODY,SUB_BLOCK,   &
                                   BLX,BLY,BLZ,DMIN,KCLMN,CLMN)
!
!**** Determine the reference length for numerical integration
!   of the Green's functions as required by the accuracy levels
!   determined by teh paramter KACC.
!
!   If clmn(ib)=0., it is then replaced by the default value which
!   is chosen as follows. The code finds at first two cells with
!   maximal diagonal lengths. Note that in each block the cells
!   have the same size. Let the dimensions of one of these two cells,
!   blx1, bly1, and blz1 be arranged in an increasing order, say,
!   blx1<=bly1<=blz1, then the mediate length of the cell is bly1.
!   The mediate length of the other cell can be found in the same
!   way. The value of clmn(ib) is then the average of those two
!   mediate lengths.
!
!   Note that clmn takes its value for each substructure.
!
!
!Input parameters:
!
!  MBODY:   Integer(*4),  maximal number of substructures allowed in
!           the program.
!  NBMAX:   Integer,  maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:  Integer SUB_BLOCK(MBODY),  number of blocks in each substructure.
!  BLX:     Real BLX(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the x-direction.
!  BLY:     Real BLY(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the y-direction.
!  BLZ:     Real BLZ(NBMAX,MBODY),  dimensions of each blocks of the
!           substructures in the z-direction.
!  DMIN:    Real,  minimal dimension value that is considered to be
!           zero.  DMIN=0.1 for the low frequency module and DMIN=0.001
!           for the high frequency module.
!  KCLMN:   Integer,  parameter controlling whether values for CLMN
!           need to be input or to be set automatically by this routine.
!
!Output parameters:
!
!  CLMN:    Real CLMN(MBODY),  the reference lengths in each substructure.
!
!
!**** Called by:  main
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL AA1,AA2,CL1,CLMN1,CLMN2,CLXM,CLYM,CLZM,DMIN
      INTEGER IB,KCLMN,L,LL,LM,LMN,LN,MBODY,NBMAX,NBODY,NW
      REAL BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),CLMN(MBODY)
      INTEGER SUB_BLOCK(MBODY)
!
      DO IB=1,NBODY
!
         IF (KCLMN==0) CLMN(IB)=0.
!
! ---- cl1 is the diagonal length of a cell
         CL1=SQRT(BLX(1,IB)**2+BLY(1,IB)**2+BLZ(1,IB)**2)
         LMN=1
         CLXM=BLX(1,IB)
         CLYM=BLY(1,IB)
         CLZM=BLZ(1,IB)
         DO L=2,SUB_BLOCK(IB)
            AA1=SQRT(BLX(L,IB)**2+BLY(L,IB)**2+BLZ(L,IB)**2)
            IF (CL1<AA1) THEN
               CL1=AA1
               CLXM=BLX(L,IB)
               CLYM=BLY(L,IB)
               CLZM=BLZ(L,IB)
               LMN=L
            END IF
         END DO
!
         LL=1
!
   50    AA1=AMAX1(CLXM,CLYM,CLZM)
         AA2=AMIN1(CLXM,CLYM,CLZM)
!
         IF (ABS(CLXM-AA1)<=DMIN) LM=1
         IF (ABS(CLYM-AA1)<=DMIN) LM=2
         IF (ABS(CLZM-AA1)<=DMIN) LM=3
         IF (ABS(CLXM-AA2)<=DMIN) LN=1
         IF (ABS(CLYM-AA2)<=DMIN) LN=2
         IF (ABS(CLZM-AA2)<=DMIN) LN=3
!
         IF (LM==2) THEN
!
            IF (LN==2) THEN
               CLMN1=CLYM
            ELSEIF (LN==3) THEN
               CLMN1=CLXM
            ELSE
               CLMN1=CLZM
            END IF
         ELSEIF (LM==3) THEN
!
            IF (LN==2) THEN
               CLMN1=CLXM
            ELSEIF (LN==3) THEN
               CLMN1=CLZM
            ELSE
               CLMN1=CLYM
            END IF
!
         ELSEIF (LN==2) THEN
            CLMN1=CLZM
         ELSEIF (LN==3) THEN
            CLMN1=CLYM
         ELSE
            CLMN1=CLXM
         END IF
!
         IF (SUB_BLOCK(IB)/=1) THEN
            IF (LL==1) THEN
!
! ---- Determine the second mediate length
               CL1=0.
               DO L=1,SUB_BLOCK(IB)
                  IF (L/=LMN) THEN
                     AA1=SQRT(BLX(L,IB)**2+BLY(L,IB)**2+BLZ(L,IB)**2)
                     IF (CL1<AA1) THEN
                        CL1=AA1
                        CLXM=BLX(L,IB)
                        CLYM=BLY(L,IB)
                        CLZM=BLZ(L,IB)
                     END IF
                  END IF
               END DO
!
               CLMN2=CLMN1
               LL=2
               GOTO 50
!
            ELSE
               CLMN1=(CLMN1+CLMN2)/2.
!
            END IF
         END IF
         IF (CLMN(IB)<.0) THEN
            WRITE (NW,*) ' Warning: negative CLMN entered, replaced',  &
                         ' by default value.'
         END IF
         IF (CLMN(IB)<DMIN) CLMN(IB)=CLMN1
         IF (CLMN(IB)<CLMN1) THEN
            WRITE (NW,1010) IB
            WRITE (*,1010) IB
         END IF
!
      END DO
!
      RETURN
 1010 FORMAT (' Warning: entered CLMN for substructure #',I3,  &
              ' is less than the default value',               &
              /'  (average of the mediate lengths ',           &
              'of two biggest cells).',/'   Number of steps ', &
              'in numerical integrations increases.')
      END
!
!**** End of INIT_REF_CELL_DIM
!
!
      SUBROUTINE INIT_SUPER_BLOCK(NW,MBODY,NBMAX,NSMR,KSYMM,DMIN,NXMAX,NYMAX, &
                                  NZMAX,NBODY,SUB_BLOCK,BLX,BLY,BLZ,NX,NY,NZ, &
                                  XBL,YBL,ZBL,XCELL,YCELL,ZCELL,SBX,SBY,SBZ,  &
                                  XSB,YSB,ZSB,SCX,SCY,SCZ,NXS,NYS,NZS,KSMR)
!
!**** Determine the super block for the spatial symmetry reductions
!
!   This routine find the super block that contains all the
!   structural blocks of the 3D body.  All disrectized cells
!   must coincide with the cells of the super block to facilitate
!   the spatial symmetry reduction.
!
!   Note that unlike in routine INIT_COMPUTATION, the arrays BLX,  BLY,
!   and BLZ containes the dimensions of the cells instead of the
!   blocks.
!
!Input parameters:
!
!  MBODY:   Integer(*4), the maximal number of substructures allowed
!           in the program.
!  NBMAX:   Integer,  the maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  NSMR:    Integer,  the maximal number of non-identical elements
!           for the scattering matrix which is determined by the
!           paramters NZSR, NZOB and NHFILM of the code.  See the corresponding
!           paramter list in the main program for detail.
!  KSYMM:   Integer,  controlling parameter for the two-plane symmetry
!           fo the 3D model.  KSYMM=1:  symmetric model;  =0:  non-sym-
!           metric model.
!  DMIN:    Real,  minimal dimension value that is considered to be
!           zero.  DMIN=0.1 for the low frequency module and DMIN=0.001
!           for the high frequency module.
!  NXMAX:   Integer,  maximal number of cells in the x-direction
!           in a block.
!  NYMAX:   Integer,  maximal number of cells in the y-direction
!           in a block.
!  NZMAX:   Integer,  maximal number of cells in the z-direction
!           in a block.
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:  Integer SUB_BLOCK(MBODY),  number of blocks in each substructure.
!  BLX:     Real BLX(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the x-direction.
!  BLY:     Real BLY(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the y-direction.
!  BLZ:     Real BLZ(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the z-direction.
!  NX:      Integer NX(NBMAX,MBODY),  numbers of cells in the x-direction
!           in each block of the substructures.
!  NY:      Integer NY(NBMAX,MBODY),  numbers of cells in the y-direction
!           in each block of the substructures.
!  NZ:      Integer NZ(NBMAX,MBODY),  numbers of cells in the z-direction
!           in each block of the substructures.
!  XBL:     Real XBL(NBMAX,MBODY),  x-coordinates of each blocks in the
!           substructures.
!  YBL:     Real YBL(NBMAX,MBODY),  y-coordinates of each blocks in the
!           substructures.
!  ZBL:     Real ZBL(NBMAX,MBODY),  z-coordinates of each blocks in the
!           substructures.
!  XCELL:   Real XCELL(NXMAX,NBMAX,MBODY),  x-coordinates of the cells.
!  YCELL:   Real YCELL(NYMAX,NBMAX,MBODY),  y-coordinates of the cells.
!  ZCELL:   Real ZCELL(NZMAX,NBMAX,MBODY),  z-coordinates of the cells.
!
!
!Output parameters:
!
!  SBX:     Real,  dimension of the super block in the x-direction.
!  SBY:     Real,  dimension of the super block in the y-direction.
!  SBZ:     Real,  dimension of the super block in the z-direction.
!  XSB:     Real,  x-ccordinate of the superblock.
!  YSB:     Real,  y-ccordinate of the superblock.
!  ZSB:     Real,  z-ccordinate of the superblock.
!  SCX:     Real,  dimension the cells of the super block in the
!           x-direction.
!  SCY:     Real,  dimension the cells of the super block in the
!           y-direction.
!  SCZ:     Real,  dimension the cells of the super block in the
!           z-direction.
!  NXS:     Integer,  number of cells in the x-direction of the superblock.
!  NYS:     Integer,  number of cells in the y-direction of the superblock.
!  NZS:     Integer,  number of cells in the z-direction of the superblock.
!  KSMR:    Integer,  controlling parameter whether spatial symmetry can
!           be used or not.  KSMR=1:  yes;  =0:  no.
!
!**** Called by:  main
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL DMIN,SBX,SBX1,SBX2,SBY,SBY1,SBY2,SBZ,SBZ1,SBZ2,SCX,SCY,SCZ,   &
           XI,XSB,YI,YSB,ZI,ZSB
      INTEGER I,IB,II,J,JB,JJ,K,KCELLT,KK,KSMR,KSYMM,L,MBODY,NBMAX,      &
              NBODY,NSMR,NXMAX,NXS,NYMAX,NYS,NW
      INTEGER NZMAX,NZS
      INTEGER SUB_BLOCK(MBODY),NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY)
      REAL BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),           &
           XBL(NBMAX,MBODY),YBL(NBMAX,MBODY),ZBL(NBMAX,MBODY),           &
           XCELL(NXMAX,NBMAX,MBODY),YCELL(NYMAX,NBMAX,MBODY),            &
           ZCELL(NZMAX,NBMAX,MBODY)
! ---- Determine if the spatial symmetry reduction can be used
!
! --- Determine if all the cells have the same size.
!   KCELLT=1: yes; =0: no
!
      KCELLT=1
      DO IB=1,NBODY
         DO L=1,SUB_BLOCK(IB)
            IF (IB/=1.OR.L/=1) THEN
               IF (ABS(BLX(L,IB)-BLX(1,1))>DMIN.OR.  &
                   ABS(BLY(L,IB)-BLY(1,1))>DMIN.OR.  &
                   ABS(BLZ(L,IB)-BLZ(1,1))>DMIN) THEN
                  KCELLT=0
                  GOTO 100
               END IF
            END IF
         END DO
      END DO
!
! --- If all the cells have the same size (kcellt=1), great saving
!   can be achieved by spatial symmetry reduction in forming the
!   scattering matrix.
!
!
!-- Find the dimension of the super block.
!   Note that the parameters blx etc. are the cell dimensions now
!   xbl etc. are still the coordinates of the blocks.
!
      SBX1=1.E12
      SBY1=1.E12
      SBZ1=1.E12
      SBX2=-1.E12
      SBY2=-1.E12
      SBZ2=-1.E12
!
      DO IB=1,NBODY
         DO L=1,SUB_BLOCK(IB)
            SBX1=AMIN1(SBX1,XBL(L,IB)-.5*BLX(L,IB)*NX(L,IB))
            SBX2=AMAX1(SBX2,XBL(L,IB)+.5*BLX(L,IB)*NX(L,IB))
            SBY1=AMIN1(SBY1,YBL(L,IB)-.5*BLY(L,IB)*NY(L,IB))
            SBY2=AMAX1(SBY2,YBL(L,IB)+.5*BLY(L,IB)*NY(L,IB))
            SBZ1=AMIN1(SBZ1,ZBL(L,IB)-.5*BLZ(L,IB)*NZ(L,IB))
            SBZ2=AMAX1(SBZ2,ZBL(L,IB)+.5*BLZ(L,IB)*NZ(L,IB))
         END DO
      END DO
!
      SBX=SBX2-SBX1
      SBY=SBY2-SBY1
      SBZ=SBZ2-SBZ1
!
!-- For symmetric structures the super block need to include
!   the block that are not input.  The super block must also
!   include the full region covered by the SBX2 instead of
!   SBX2-SBX1
!
      IF (KSYMM==1) THEN
         SBX=2.*SBX2
         SBY=2.*SBY2
      END IF
!
!-- Determine the center coordinates of the super block
!
      IF (KSYMM==0) THEN
         XSB=SBX2-.5*SBX
         YSB=SBY2-.5*SBY
      ELSE
         XSB=0.
         YSB=0.
      END IF
      ZSB=SBZ2-.5*SBZ
!
!-- Determine the number of cells of the super block
!
      NXS=INT(SBX/BLX(1,1)+.2)
      NYS=INT(SBY/BLY(1,1)+.2)
      NZS=INT(SBZ/BLZ(1,1)+.2)
!
!-- Check if all cells coincide with the cells of the super block.
!   If so, the symmetry reduction can be used, and the parameter
!   KSMR is set to be 1.  Otherwise, the symmetry reduction cannot
!   be used even if kcellt=1, and KSMR is assigned a 0.
!
!   This may be done by comparing the dimensions of a cell of the
!   super block and the dimensions of a cell of the original body.
!   But such a check may fail if a block in between does not coincide
!   with the super block cells.
!
!   Note the blocks in other three quadrants for a symmetric
!   structure need not be tested since the super block automatically
!   contain them by reflection.
!
!-- Compute the cell dimension of the super block
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
      DO IB=1,NBODY
         DO L=1,SUB_BLOCK(IB)
!
            DO I=1,NX(L,IB)
               DO J=1,NY(L,IB)
                  DO K=1,NZ(L,IB)
                     DO II=1,NXS
                        DO JJ=1,NYS
                           DO KK=1,NZS
                              XI=XSB-.5*SBX+.5*SCX+(II-1)*SCX
                              YI=YSB-.5*SBY+.5*SCY+(JJ-1)*SCY
                              ZI=ZSB-.5*SBZ+.5*SCZ+(KK-1)*SCZ
                              IF (ABS(XI-XCELL(I,L,IB))<DMIN.AND.  &
                                  ABS(YI-YCELL(J,L,IB))<DMIN.AND.  &
                                  ABS(ZI-ZCELL(K,L,IB))<DMIN) THEN
                              GOTO 5
                              END IF
!
                           END DO
                        END DO
                     END DO
!
!-- If any cell of the original body fails to identify a cell
!   from the super block, ksmr=0
!
                     KSMR=0
!
                     WRITE (*,1010) XCELL(I,L,IB),YCELL(I,L,IB),ZCELL(I,L,IB)
                     WRITE (NW,1010) XCELL(I,L,IB),YCELL(I,L,IB),ZCELL(I,L,IB)
!
!-- Patial use of the spatial symmetry may be possible for
!   substructures with one block
!
                     IF (KSYMM==0) THEN
                        DO JB=1,NBODY
                           IF (SUB_BLOCK(JB)==1) THEN
                              WRITE (*,1020) JB
                              WRITE (NW,1020) JB
                           END IF
                        END DO
                     END IF
!
                     GOTO 100
!
    5             END DO
               END DO
            END DO
         END DO
      END DO
!
!-- Now that all cells passed the test, namely, all cells have
!   successfully identified a cell from the super block, symmetry
!   reduction can be used
!
      KSMR=1
!
! ** The following is disfunctioned in F90 version.  Only the value
!    of NSMR is returned instead
!
! -- Final check on the total number of cells of the super block.
!    Symmetry reduction can be used only if it is within the
!    designed limit.
!
!      IF (9*NXS*NYS*NZS*(NZS+1)/2<=NSMR) THEN
!         WRITE (*,1030)
!         WRITE (NW,1030)
!      ELSE
!         KSMR=0
!         WRITE (*,1040)
!         WRITE (NW,1040)
!      END IF
!
  100 IF (KCELLT==0) KSMR=0
!
      IF (KSMR==1) NSMR=9*NXS*NYS*NZS*(NZS+1)/2
!
      RETURN
 1010 FORMAT ('The spatial symmetry reduction cannot be used ',            &
              'for the whole body',                                        &
              /'because the cell with the coordinates',/'   (',3F14.5,     &
              ' )',/'does not coincide with any cell of the ',             &
              'super block.',                                              &
              /'You may need to re-discretize the body if you ',           &
              /'still wish to use the spatial symmetry reduction.')
 1020 FORMAT (/'Partial use of spatial symmetry reduction for ',           &
              'substructure #',I4)
! 1030 FORMAT (/'  --- Spatial symmetry reduction used ! ---')
! 1040 FORMAT (/'  --- Total number of the non-identical elements of ',     &
!              'scattering matrix ',                                        &
!              /'      for the super block exceeds maximum desigen',        &
!              /'      Spatial symmetry reduction cannot be used !',        &
!              /'      You may need to reduce the number of cells, ',       &
!              /'      especially in the vertical direction in order to ',  &
!              /'      facilitate spatial symmetry reduction')
      END
!
!**** End of INIT_SUPER_BLOCK
!
!
   SUBROUTINE Z_ZP_LVLS (NW,MZGRID,CS_TYPE,NTXE,N_SUB_RX,                 &
                         M_RX,SUB_RX_MAX,N_RX,NCRD,TX_CRDZ,RX_Z,          &
                         WIRE_PATH,DMIN,NZSRMAX,NZSR,ZSRG,NZOB,ZOBG)
!
!**** Determine the z and z'-levels in the vertical direction
!
!     Hankel integrals are computed at various z- and z'-levels for all rho
!     (in the lateral direction) for interpolations for computing the
!     Green's tensors.
!
!  Input parameters:
!
!    MZRGID:  Integer,  dimension parameter for the arrays ZOBG and
!             ZSRG.  MZGRID must be much larger than NZTMAX since
!             these two arrays also works as working arrays.
!    CS_TYPE:  CS_TYPE is use only for the case  when it is equal to 2 as a
!              vertical electric bipole.  This is a special case of SOURCE_TYPE=2
!              because vertical electric bipoles are integrated analytically.
!
!              Note that CS_TYPE = 2 is a very special case. It is used only if
!              all the transmitter bipoles are strictly vertical.  This does not
!              include vertical bipoles that are mixed among other arbitrarily
!              oriented 3D current bipoles, as in the case of WIRE_PATH=1 (non-
!              flat-earth).
!
!    NTXE:   Integer,  nubmer of  excitations.
!    M_RX:
!    N_RX:    Integer N_RX(NTXE),  number of receiver sites.
!    N_SUB_RX:
!    SUB_RX_MAX:
!    NCRD:
!    TX_CRDZ:    TX_CRDZ(NCRD,NTXE), z-coordinates of electrodes or the center
!             z-coordinates of a current loop or a magnetic dipole for all the
!             excitations.
!    RX_Z:    Real RX_Z(SUB_RX_MAX,M_RX,NTXE),  receiver sites coordinates in the
!             z-direction for the receiver sites.
!    DMIN:
!    WIRE_PATH:  =1, 3D wire;
!                =0, flat wire path
!
!  Output parameters:
!
!     NZOB:   Integer, number of z-levels for the excitation sources.
!     NZSR:   Integer,  number of z-levels for the excitation sources.
!     ZOBG:  Real ZOBG(MZGRID),  the coordinates of the nzob z-levels
!             for the excitation sources.
!     ZSRG:   Real ZSRG(MZGRID), the coordinates of the nzsr z-levels
!             for the excitation sources.
!
!
!**** Called by:  main
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) ::  MZGRID,NTXE,NCRD,M_RX,NW,  &
                              SUB_RX_MAX,NZSRMAX
      INTEGER, INTENT(IN) ::  N_RX(NTXE),N_SUB_RX(M_RX,NTXE),WIRE_PATH,CS_TYPE
      INTEGER, INTENT(OUT) :: NZOB,NZSR
      REAL, INTENT(IN) :: DMIN,RX_Z(SUB_RX_MAX,M_RX,NTXE)
!  -- The two electrodes in TX_CRDZ for vertical bipoles may be reversed here
!      REAL, INTENT(INOUT) :: TX_CRDZ(NCRD,NTXE)  !*** May not be right for arbitrary loop or wire path.
!
!   ** INTENT removed for Lahey -chkglobal crashes here
      REAL :: TX_CRDZ(NCRD,NTXE)
      REAL, INTENT(OUT) :: ZOBG(MZGRID),ZSRG(2,MZGRID)
!
      INTEGER ::  I,J,II,JJ,K
      REAL :: ZSR1,ZMIN,ZMAX
!
! --- ZWORK is an allocatable working array for sorting
!
      REAL, ALLOCATABLE :: ZWORK(:),ZWORK2(:,:)
!
! --- Determine the z-levels for the receivers
!
!     Firstly all different z-levels are found.  They are then
!     re-arranged later.
!
      ZOBG(1)=RX_Z(1,1,1)
      JJ=1
      DO J=1,NTXE
         DO I=1,N_RX(J)
            DO K=1,N_SUB_RX(I,J)
               DO II=1,JJ
                  IF (ABS(RX_Z(K,I,J)-ZOBG(II))<=DMIN) GOTO 2
               END DO
               JJ=JJ+1
!
!        --  Test if JJ <= MZGRID.  If not,  increase MZGRID and re-compile the code
!
               IF (JJ > MZGRID) THEN
                  WRITE (NW,*) 'Total number of working z-levels exceeds design limit.'
                  WRITE (NW,*) 'Increase the value of MZGRID and re-compile the code.'
                  STOP 'Increase the value of MZGRID and re-compile the code.'
               END IF
               ZOBG(JJ)=RX_Z(K,I,J)
   2           CONTINUE
            END DO
         END DO
      END DO
      NZOB=JJ
!
!  -- Arrange the elements of ZOBG in an increasing order.
!
!     This part is a bit tricky,  but it's organized as follows:
!     The Order_loop finds the (next) minimal ZOBG(:) and put them
!     in a increasing order;  the Minimization_loop identifies the
!     element that is smaller than the current one;  and the Skip_loop
!     skips those that have already been identified which are always
!     <= the current one.
!
!  -- Allocate the working array
!
      ALLOCATE(ZWORK(NZOB+1))
!
      ZWORK(1)=ZOBG(1)
      Order_loop:  DO I=1,NZOB
         Minimization_loop:  DO J=1,NZOB
            IF (ZOBG(J)<ZWORK(I)) THEN
               Skip_loop:  DO JJ=1,I-1
                  IF (ZOBG(J)<=ZWORK(JJ)) CYCLE Minimization_loop
               END DO Skip_loop
               ZWORK(I)=ZOBG(J)
            END IF
         END DO Minimization_loop
         ZWORK(I+1)=1.E20
      END DO Order_loop
!
      ZOBG(1:NZOB)=ZWORK(1:NZOB)
!
!  -- Deallocate the working array
!
      DEALLOCATE(ZWORK)
!
! --- Determine the z_prime levels for different excitations
!     in controlled source cases.
!
   IF (WIRE_PATH==0) THEN
!
!     This part for flat wire path is identical to older versions of MARCO
!
!     The technique used here is exactly the same as in the above
!
!
! --- Make sure that vertical coordinate of the second electrode is larger
!     than that of the first one for vertical current bipoles.
!
      IF (CS_TYPE==2) THEN
         DO J=1,NTXE
            IF (TX_CRDZ(2,J).LT.TX_CRDZ(1,J)) THEN
               ZSR1=TX_CRDZ(1,J)
               TX_CRDZ(1,J)=TX_CRDZ(2,J)
               TX_CRDZ(2,J)=ZSR1
               WRITE(NW,223) J
               WRITE( *,223) J
            END IF
         END DO
      END IF
!
      ZSRG(1,1)=TX_CRDZ(1,1)
      IF (CS_TYPE==2) THEN
         ZSRG(2,1)=TX_CRDZ(2,1)
      ELSE
         ZSRG(2,1)=TX_CRDZ(1,1)
      END IF
      JJ=1
!
      DO J=1,NTXE
!
         DO I=1,JJ
            IF (CS_TYPE==2) THEN
               IF (ABS(TX_CRDZ(1,J)-ZSRG(1,I))<=DMIN .AND.     &
                   ABS(TX_CRDZ(2,J)-ZSRG(2,I))<=DMIN) GOTO 5
            ELSE
               IF (ABS(TX_CRDZ(1,J)-ZSRG(1,I))<=DMIN) GOTO 5
            END IF
         END DO
!
         JJ=JJ+1
         IF (CS_TYPE==2) THEN
            ZSRG(1,JJ)=TX_CRDZ(1,J)
            ZSRG(2,JJ)=TX_CRDZ(2,J)
         ELSE
            ZSRG(1,JJ)=TX_CRDZ(1,J)
            ZSRG(2,JJ)=TX_CRDZ(1,J)
         END IF
!
   5     CONTINUE
!
      END DO
!
      NZSR=JJ
!
!  -- Allocate the working array
!
      ALLOCATE(ZWORK2(2,NZSR+1))
!
!  -- Arrange the elements of ZSRG in an increasing order according
!     to ZSRG(1,*).
!
      ZWORK2(1:2,1)=ZSRG(1:2,1)
      Order_loop2:  DO I=1,NZSR
         Minimization_loop2:  DO J=1,NZSR
            IF (ZSRG(1,J)<ZWORK2(1,I)) THEN
            Skip_loop2:  DO JJ=1,I-1
                  IF (ZSRG(1,J)<ZWORK2(1,JJ) .OR.                 &
                      (ABS(ZSRG(1,J)-ZWORK2(1,JJ))<DMIN.AND.      &
                       ABS(ZSRG(2,J)-ZWORK2(2,JJ))<DMIN))    THEN
                     Cycle Minimization_loop2
                  END IF
               END DO Skip_loop2
               ZWORK2(1:2,I)=ZSRG(1:2,J)
            END IF
         END DO Minimization_loop2
         ZWORK2(1,I+1)=1.E20
      END DO Order_loop2
!
      ZSRG(1:2,1:NZSR)=ZWORK2(1:2,1:NZSR)
!
      DEALLOCATE(ZWORK2)
!
   ELSE IF (WIRE_PATH==1) THEN
!
!  -- For 3D wire paths simply define NZSRMAX z'-levels between the maximumand minimun
!     Not that these z'-levels greatly increase memory requirements!
!
      ZMIN=1.E8
      ZMAX=0.
      DO J=1,NTXE
         DO I=1,NCRD
            IF (ZMIN>TX_CRDZ(I,J)) ZMIN=TX_CRDZ(I,J)
            IF (ZMAX<TX_CRDZ(I,J)) ZMAX=TX_CRDZ(I,J)
         END DO
      END DO
      NZSR=NZSRMAX
      DO I=1,NZSR
         ZSRG(1,I)=ZMIN+(ZMAX-ZMIN)/NZSRMAX*(I-1)
         ZSRG(2,I)=ZSRG(1,I)  ! zsrg(2,*) are not used
      END DO
!
   END IF
!
   RETURN
!
 223    FORMAT(/'Warning: the order of the electrode for ',    &
                'excitation #',I3,' is reversed as required',  &
               /'by the program. Primary and secondary ',      &
                'field quantities reverse signs.')
!
   END SUBROUTINE Z_ZP_LVLS
!
!
   SUBROUTINE INIT_ZLVLS(NW,MBODY,NBMAX,NZMAX,KSMR,NBODY,SUB_BLOCK,       &
                         NZS,NZ,SBZ,SCZ,ZSB,ZCELL,BLZ,                    &
                         MZGRID,DMIN,NZSR,ZSRG,NZOB,ZOBG)
!
!**** Determine the z and z'-levels in the vertical direction
!
!     The program automatically finds all z and z'-levels for the
!     3D body and for the sources and receivers.  Hankel integrals
!     are computed at those levels for various rho (in the lateral
!     direction) for interpolations for computing the (integrated)
!     Green's tensors.
!
!  Input parameters:
!
!  MBODY:   Integer,  maximal number of substructures allowed in the
!           program.
!  NBMAX:   Integer,  maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  NZMAX:   Integer,  maximal number of cells in the z-direction
!           in a block.
!  KSMR:    Integer,  controlling parameter whether spatial symmetry can
!           be used or not.  KSMR=1:  yes;  =0:  no.
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:  Integer SUB_BLOCK(MBODY),  number of blocks in each substructure.
!  NZS:     Integer,  number of cells in the z-direction of the superblock.
!  NZ:      Integer NZ(NBMAX,MBODY),  numbers of cells in the z-direction
!           in each block of the substructures.
!  SBZ:     Real,  dimension of the super block in the z-direction.
!  SCZ:     Real,  dimension the cells of the super block in the
!           z-direction.
!  ZSB:     Real,  z-ccordinate of the superblock.
!  ZCELL:   Real ZCELL(NZMAX,NBMAX,MBODY),  z-coordinates of the cells.
!  BLZ:     Real BLZ(NBMAX,MBODY),  dimensions of each cells of the
!           substructures in the z-direction.
!  MZRGID:  Integer,  dimension parameter for the arrays ZOBG and
!           ZSRG.  MZGRID must be much larger than NZTMAX since
!           these two arrays also works as working arrays.
!  DMIN:
!
!  Output parameters:
!
!     NZOB:   Integer, number of z-levels for the cells of the 3D bodies.
!     NZSR:   Integer,  number of z-levels for the 3D bodies.
!     ZOBG:   Real ZOBG(MZGRID),  the coordinates of the nzob z-levels
!             for the 3D bodies.
!     ZSRG:   Real ZSRG(MZGRID), the coordinates of the nzsr z-levels
!             for the cells of the 3D bodies.
!
!**** Called by:  main
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: KSMR,MBODY,MZGRID,NBMAX,NBODY,NZMAX,NZS,NW,    &
                             SUB_BLOCK(MBODY),NZ(NBMAX,MBODY)
      REAL,    INTENT(IN) :: DMIN,SBZ,SCZ,ZSB,BLZ(NBMAX,MBODY),             &
                             ZCELL(NZMAX,NBMAX,MBODY)
      INTEGER, INTENT(OUT) :: NZOB,NZSR
      REAL,    INTENT(OUT) :: ZOBG(MZGRID),ZSRG(2,MZGRID)
!
      INTEGER :: I,II,J,JJ,IB
!
! --- ZWORK is an allocatable working array for sorting
!
      REAL, ALLOCATABLE :: ZWORK(:),ZWORK2(:,:)
!
! --- Life is easy with spatially symmetric models
!
      IF (KSMR==1) THEN
         NZOB=NZS
         NZSR=NZS
!
         DO I=1,NZS
            ZOBG(I)=ZSB-.5*SBZ+.5*SCZ+(I-1)*SCZ
            ZSRG(1,I)=ZSB-.5*SBZ+(I-1)*SCZ
            ZSRG(2,I)=ZSB-.5*SBZ+I*SCZ
         END DO
         RETURN
      END IF
!
! ----- Determine the z-levels for storing the values of the
!     Green's functions (the Hankel transforms) in the z-direction
!
!     Note that the z and z'-levels are different with and
!     without spatial symmetry reductions if there more than
!     two separated blocks.
!
!     Firstly all different z-levels are found.  They are then
!     re-arranged later.
!
      JJ=1
      ZOBG(1)=ZCELL(1,1,1)
      DO IB=1,NBODY
         DO I=1,SUB_BLOCK(IB)
            DO J=1,NZ(I,IB)
               DO II=1,JJ
                  IF (ABS(ZCELL(J,I,IB)-ZOBG(II))<=DMIN) GOTO 2
               END DO
               JJ=JJ+1
!--- The maximal value of JJ is MZGRID
               IF (JJ>MZGRID) THEN
                  WRITE (*,1010)
                  WRITE (NW,1010)
                  STOP   &
       'Program aborted. Please check the error messages in Marco.out'
               END IF
               ZOBG(JJ)=ZCELL(J,I,IB)
   2           CONTINUE
            END DO
         END DO
      END DO
      NZOB=JJ
!  -- Arrange the elements of ZOBG in an increasing order.
!
!     This part is a bit tricky,  but it's organized as follows:
!     The Order_loop finds the (next) minimal ZOBG(:) and put them
!     in a increasing order;  the Minimization_loop identifies the
!     element that is smaller than the current one;  and the Skip_loop
!     skips those that have already been identified which are always
!     <= the current one.
!
!  -- Allocate the working array
!
      ALLOCATE(ZWORK(NZOB+1))
!
      ZWORK(1)=ZOBG(1)
      Order_loop:  DO I=1,NZOB
         Minimization_loop:  DO J=1,NZOB
            IF (ZOBG(J)<ZWORK(I)) THEN
               Skip_loop:  DO JJ=1,I-1
                  IF (ZOBG(J)<=ZWORK(JJ)) CYCLE Minimization_loop
               END DO Skip_loop
               ZWORK(I)=ZOBG(J)
            END IF
         END DO Minimization_loop
         ZWORK(I+1)=1.E20
      END DO Order_loop
!
      ZOBG(1:NZOB)=ZWORK(1:NZOB)
!
!  -- Deallocate the working array
!
      DEALLOCATE(ZWORK)
!
!
! ---  Determine the z'-levels for storing the values of the
!      Green's functions integrated in the z'-direction
!
!     The technique used here is exactly the same as in the above
!
!
      JJ=1
      ZSRG(1,JJ)=ZCELL(1,1,1)-.5*BLZ(1,1)
      ZSRG(2,JJ)=ZCELL(1,1,1)+.5*BLZ(1,1)
      DO IB=1,NBODY
         DO I=1,SUB_BLOCK(IB)
            DO J=1,NZ(I,IB)
               DO II=1,JJ
                  IF (ABS(ZSRG(1,II)-ZCELL(J,I,IB)-.5*BLZ(I,IB))<=DMIN.AND. &
                      ABS(ZSRG(2,II)-ZCELL(J,I,IB)+.5*BLZ(I,IB))<=DMIN) GOTO 4
               END DO
               JJ=JJ+1
               ZSRG(1,JJ)=ZCELL(J,I,IB)-.5*BLZ(I,IB)
               ZSRG(2,JJ)=ZCELL(J,I,IB)+.5*BLZ(I,IB)
   4           CONTINUE
            END DO
         END DO
      END DO
      NZSR=JJ
!
!  -- Allocate the working array
!
      ALLOCATE(ZWORK2(2,NZSR+1))
!
!  -- Arrange the elements of ZSRG in an increasing order according
!     to ZSRG(1,*).
!
      ZWORK2(1:2,1)=ZSRG(1:2,1)
      Order_loop2:  DO I=1,NZSR
         Minimization_loop2:  DO J=1,NZSR
            IF (ZSRG(1,J)<ZWORK2(1,I)) THEN
            Skip_loop2:  DO JJ=1,I-1
                  IF (ZSRG(1,J)<ZWORK2(1,JJ) .OR.                 &
                      (ABS(ZSRG(1,J)-ZWORK2(1,JJ))<DMIN.AND.      &
                       ABS(ZSRG(2,J)-ZWORK2(2,JJ))<DMIN))    THEN
                     Cycle Minimization_loop2
                  END IF
               END DO Skip_loop2
               ZWORK2(1:2,I)=ZSRG(1:2,J)
            END IF
         END DO Minimization_loop2
         ZWORK2(1,I+1)=1.E20
      END DO Order_loop2
!
      ZSRG(1:2,1:NZSR)=ZWORK2(1:2,1:NZSR)
!
      DEALLOCATE(ZWORK2)
!
      RETURN
!
 1010 FORMAT (/'The sum of all the cell numbers in the vertical',          &
               'direction of all blocks exceed designed limit.',           &
             'Please either change the value of the parameter MZGRID or',  &
             'try to use less blocks or reduce the cells in the vertical', &
             'direction.')
!
   END SUBROUTINE INIT_ZLVLS
!
!
!===== Subroutines called directly by the main program -- major structuring
!      of the program
!
      SUBROUTINE MAIN_PRM_AT_CELL(NW,FRQ,MLAYER,ZBND,LRYTH,HVK,KKH,CDH,   &
                                  KANIS,HIGH_FRQ,CS_TYPE,KSYMM,MBODY,     &
                                  NBMAX,NSUBCM,NMAX,NXMAX,NYMAX,NZMAX,    &
                                  NTXE,MD_ANGLE,NCRD,N_VRTX,TX_CRDX,    &
                                  TX_CRDY,TX_CRDZ,RAD,                    &
                                  NPOL,LP1,LP2,NBODY,SUB_BLOCK,           &
                                  NET,NEQ,NX,NY,NZ,NCELL,XCELL,YCELL,     &
                                  ZCELL,NXI,NYI,NZI,NCELLI,XCELLI,YCELLI, &
                                  ZCELLI,CDB,EN,EMT,ENT,EJGS,EJGS2,       &
                                  RHOMIN,RHOMAX,NZOB,ZOBG,NZSR,ZSRG,NZBG, &
                                  ZBG,KACC,AJ,DMIN,NHFILM,ALMAX,BLMIN,    &
                                  GRHF,RRG,GRHO0)
!
!**** calculate the incident fields at cell centres
!
!   Results (electric fields at cell centers) for non-symmetric
!   models are stored on the disk in unit 10 if there is more than
!   one excitation and/or more than one substructure.  Results for
!   for symmetric models are always stored in unit 20 on the disk.
!   Access to those units must be in the same sequence as
!   used here in this routine.
!
!
!Input parameters:
!
!  FRQ:     Real,  the frequency.
!  MLAYER:  Integer,  number of layers of the earth.
!  ZBND:    Real ZBND(0:MLAYER), the z-coordinates of the layer
!           boundaries with the air-earth interface being always
!           0 (zbnd(0)=0).
!  LRYTH:   Real LRYTH(MLAYER), the thickness of the layers.
!  HVK:     Real HVK(0:MLAYER), the anisotropy coefficients of
!           the layer conductivities as defined by the square
!           root of the ratio of horizontal conductivity to
!           vertical conductivity.
!  KKH:    Complex(*8) KKH(0:MLAYER),  square ( **2) of the complex wave
!          number of the layers (in the lateral direction) including
!          the air (layer number 0).
!  CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!          the layers in the lateral direction including the
!          air (layer 0).
!  KANIS:  Integer,  parameter controlling whether the earth is vertically
!          anisotropic in conductivity.  KANIS=1, yes;  =0,  no.
!  The above parameters FRQ etc. are to be passed into subroutines.
!  HIGH_FRQ:  Integer,  controlling parameter for high frequency (in the
!           tens of MHz range) or low frequency (conventional frequency
!           ranges) computation.
!           HIGH_FRQ = 0:  low frequency ranges;  and
!                  = 1:  high frequency ranges.
!  CS_TYPE:    Integer,  type of excitation and configuration.
!           See documentation "MARCO.DOC" for description.
!  KSYMM:   Integer,  controlling parameter for the two-plane symmetry
!           fo the 3D model.  KSYMM=1:  symmetric model;  =0:  non-sym-
!           metric model.
!  MBODY:   Integer,  maximal number of substructures allowed in the
!           program.
!  NBMAX:   Integer,  maximal number of blocks allowed in a
!           substructure.  It is the maximum of SUB_BLOCK used for
!           array definitions.
!  NSUBCM:  Integer,  maximal nuber of cells in a substructure.
!  NMAX:    Integer,  maximal number of unknowns in a substructure.
!           NMAX=3*NSUBCM.
!  NXMAX:   Integer,  maximal number of cells in the x-direction
!           in a block.
!  NYMAX:   Integer,  maximal number of cells in the y-direction
!           in a block.
!  NZMAX:   Integer,  maximal number of cells in the z-direction
!           in a block.
!  NTXE:    Integer,  nubmer of excitations.
!  MD_ANGLE:  Real MD_ANGLE(2,NTXE),  orientations of arbitrary magnetic
!           dipoles for CS_TYPE=9 for each excitation.  For each excitation
!           the two elements of MD_ANGLE(1:2,J) contain the dip angle
!           MD_ANGLE(1,J) and the azimuthal angle MD_ANGLE(2,J) of the Jth
!           magnetic dipole.  The dip angle is the angle from the axis down
!           to the earth (note that this is the internal positive z-axis
!           which differs from the input-output z-axis that points upwards).
!           The azimuthal angle is the angle from the north,  the y-axis.
!           Thus for a vertical magnetic dipole MD_ANGLE(1,J)=180 for
!           pointing up air and MD_ANGLE(1,J) =0 for pointing down.  A
!           horizontal magnetic dipole pointing north will have MD_ANGLE(1,J)
!           =90 and MD_ANGLE(2,J)=0,  and a horizontal magnetic dipole
!           pointing east will have MD_ANGLE(1,J)=90 and MD_ANGLE(2,J)=90.
!  NCRD:    Integer,  nubmer of electrodes or number of different coordinates
!           for the source configuration per excitation.
!  TX_CRDX, TX_CRDY, TX_CRDZ: Real TX_CRDX(NCRD,NTXE), TX_CRDY(NCRD,NTXE),
!  TX_CRDZ(NCRD,NTXE):
!           coordinates of electrodes (the end points of current bipoles
!           or loop corners) or the center coordinates of a current loop
!           or a magnetic dipole for all the excitations.   For various
!           values of CS_TYPE,  the four elements for the first index of
!           TX_CRDX, TX_CRDY,  and TX_CRDZ contain the following information:
!           CS_TYPE =2, and 3:  the first two elements of TX_CRDX etc.
!                    represent the two electrodes of the bipoles;
!                =4: the arrays TX_CRDX etc. show the coordinates
!                    of the four corner of the rectangular loop.
!                =5, and 6: the first elements of TX_CRDX etc. contain the
!                    coordinates of the centre of the circular
!                    loop;  and
!                =7, 8, and 9: the first elements of TX_CRDX etc.
!                    contain the coordinates of the centre of the
!                    magnetic dipole.
!  RAD:     Real RAD(NTXE),  radius of the loops.
!  NPOL, LP1, LP2: Integer,  the controlling parameters for the
!           polarizations in MT computations.
!  NBODY:   Integer,  number of substructures.
!  SUB_BLOCK:  Integer SUB_BLOCK(MBODY),  number of blocks in each substructure.
!  NET:     Integer NET(MBODY),  number of unknowns in each substructure.
!  NEQ:     Integer,  total number of cells in one quadrant of a symmetric
!           model.
!  NX:      Integer NX(NBMAX,MBODY),  numbers of cells in the x-direction
!           in each block of the substructures.
!  NY:      Integer NY(NBMAX,MBODY),  numbers of cells in the y-direction
!           in each block of the substructures.
!  NZ:      Integer NZ(NBMAX,MBODY),  numbers of cells in the z-direction
!           in each block of the substructures.
!  NCELL:   Integer NCELL(NBMAX,MBODY),  number of cells in each block
!           of the substructures.
!  XCELL:   Real XCELL(NXMAX,NBMAX,MBODY),  x-coordinates of the cells.
!  YCELL:   Real YCELL(NYMAX,NBMAX,MBODY),  y-coordinates of the cells.
!  ZCELL:   Real ZCELL(NZMAX,NBMAX,MBODY),  z-coordinates of the cells.
!  NXI, NYI, NZI, NCELLI, XCELLI, YCELLI, and ZCELLI:   working arrays
!           corresponding to NX, NY, NZ, NCELL, XCELL, YCELL, and
!           ZCELL for each substructure.
!  CDB:     COMPLEX CDB(NSUBCM,NBMAX),  working array for the
!           complex conductivities of the cells in a substructure.
!           Its values are all stored on the disk in unit 62.
!  EN:      Complex EN(NMAX),  the incident electric fields in a
!           substructure. It is used as a working array.
!  DMIN:    Real,  minimal dimension value that is considered to be
!           zero.  DMIN=0.1 for the low frequency module and DMIN=0.001
!           for the high frequency module.
!
!  Parameters RHOMIN, RHOMAX, NZOB, ZOBG, NZSR, ZSRG, ZBG, KACC,
!  AJ, NHFILM, HF, HF1, BLMIN, GRHF, RRG, ALMAX, and GRHO0 are to be passed
!  into routine ONE_D_HF_TABLE.  Check ONE_D_HF_TABLE for descriptions
!
!Output parameter:
!
!
!  ENT:    Complex ENT(NMAX),  the incident electric fields in a
!          substructure multiplied by the conductivity difference
!          between the target and the host.  ENT won't be used in
!          this version.
!  EJGS:   Complex EJGS(4*NMAX*MBODY),  the incident electric fields
!          for all cells of a symmetric model with KSYMM=1.  Note
!          that the input data contain only the model in the first
!          quadrant,  but the actual computation is done for all the
!          body.
!  EJGS2:  Complex EJGS2(4*NMAX*MBODY),  the transformed incident
!          fields for the four block matrices of group reductions.
!
!
!**** Called by:  main
!
!**** Calls:      ONE_D_HF_TABLE,  EN_PRM,  EN_PRM_CS,  EN_PRM_GS,  and
!                 MTRX_UNITARY
!
!
      IMPLICIT NONE
!
      REAL AJ,ALMAX,BLMIN,DMIN,FRQ,RADI,RHOMAX,RHOMIN,U
      INTEGER I,IB,IEXCI,II,IQ,IR,J,JCOL,JJ,KACC,KANIS,HIGH_FRQ,KEYG,KPOL, &
              CS_TYPE,KSYMM,LP1,LP2,LPC,LPR,NCRDI,NW
      INTEGER LQC,LQR,MBODY,MLAYER,SUB_BLOCKI,NBMAX,NBODY,NCB1,NCRD,          &
              NEQ,NETI,NHFILM,NRG,NMAX,NPOL,NSUBCM,NTXE,NXMAX,NYMAX
      INTEGER NZMAX,NZOB,NZSR,NZBG
      COMPLEX EN(NMAX),EMT(NMAX),ENT(NMAX,NBODY),EJGS(4*NMAX*MBODY),          &
              EJGS2(4*NMAX*MBODY),CDH(0:MLAYER),KKH(0:MLAYER),                &
              CDB(NSUBCM,NBMAX),GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      REAL  ZBND(0:MLAYER),LRYTH(MLAYER),HVK(0:MLAYER)
      REAL  ZOBG(NZOB),ZSRG(2,NZSR),ZBG(2,NZBG),RRG(NHFILM)
      REAL XCELL(NXMAX,NBMAX,MBODY),YCELL(NYMAX,NBMAX,MBODY),                 &
           ZCELL(NZMAX,NBMAX,MBODY),XCELLI(NXMAX,NBMAX),                      &
           YCELLI(NYMAX,NBMAX),ZCELLI(NZMAX,NBMAX),RAD(NTXE),            &
           TX_CRDX(NCRD,NTXE),TX_CRDY(NCRD,NTXE),                   &
           TX_CRDZ(NCRD,NTXE)
      INTEGER N_VRTX(NTXE)
      INTEGER NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY),                &
              NCELL(NBMAX,MBODY),NET(MBODY),SUB_BLOCK(MBODY),                 &
              NXI(NBMAX),NYI(NBMAX),NZI(NBMAX),NCELLI(NBMAX)
      REAL :: MD_ANGLE(2,NTXE)
      REAL :: ANGLES(2)
!
!  Transmitter coordinates in single precision for internal computations.
!  Use of double precision Tx coordinates stop at the level of this routine.
!
      REAL, ALLOCATABLE, DIMENSION(:) :: TX_CRDXI,TX_CRDYI,TX_CRDZI
!
!  -- Allocate working array for the electrode coordinates of the loops
!
      ALLOCATE(TX_CRDXI(NCRD),TX_CRDYI(NCRD),TX_CRDZI(NCRD))
!
      KEYG=1
!
      IF (CS_TYPE/=1) THEN
!
! ---- Compute the grid values for the interpolation of the
!    Hankel transforms in integrating current sources.
!
         CALL ONE_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,        &
                     BLMIN,CS_TYPE,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,ZOBG,     &
                     NZSR,ZSRG,NZBG,ZBG,ALMAX,GRHF,RRG,NRG,GRHO0)
!
      END IF
!
      DO IEXCI=1,NTXE
!
!-- Determine the orientation of the magnetic dipoles
!
         IF (CS_TYPE==7.OR.CS_TYPE==8.OR.CS_TYPE==9) THEN
            ANGLES(1)=MD_ANGLE(1,IEXCI)
            ANGLES(2)=MD_ANGLE(2,IEXCI)
         END IF
!
         IF (CS_TYPE/=1) THEN
            IF (CS_TYPE==4) THEN
               NCRDI=N_VRTX(IEXCI)
            ELSE
               NCRDI=NCRD
            END IF
            DO I=1,NCRDI
!
! ---- Corrections are made for 1D loop-loop responses only.
!    Issue warnings otherwise.
!
               IF (FRQ>1.E+07 .AND. TX_CRDZ(I,IEXCI)<0.) THEN
                  WRITE (*,*)   &
                    'Warning: Corrections made for 1D Hxz and Hyz only!'
                  WRITE (NW,*)   &
                    'Warning: Corrections made for 1D Hxz and Hyz only!'
               END IF
!
               TX_CRDXI(I)=REAL(TX_CRDX(I,IEXCI))
               TX_CRDYI(I)=REAL(TX_CRDY(I,IEXCI))
               TX_CRDZI(I)=REAL(TX_CRDZ(I,IEXCI))
            END DO
            RADI=RAD(IEXCI)
         END IF
!
         IF (KSYMM==0.OR.CS_TYPE==1) THEN
! *********************************
! *                               *
            DO KPOL=LP1,LP2
!
               DO IB=1,NBODY
                  SUB_BLOCKI=SUB_BLOCK(IB)
                  NETI=NET(IB)
                  DO I=1,SUB_BLOCKI
                     NXI(I)=NX(I,IB)
                     NYI(I)=NY(I,IB)
                     NZI(I)=NZ(I,IB)
                     NCELLI(I)=NCELL(I,IB)
                     DO J=1,NXI(I)
                        XCELLI(J,I)=XCELL(J,I,IB)
                     END DO
                     DO J=1,NYI(I)
                        YCELLI(J,I)=YCELL(J,I,IB)
                     END DO
                     DO J=1,NZI(I)
                        ZCELLI(J,I)=ZCELL(J,I,IB)
                     END DO
                  END DO
!
                  IF (CS_TYPE==1) THEN
!
! ----- Note that the array emt is not used.  Thus the value of
!     the array cdb is arbitrary
!
                     CALL EN_PRM(FRQ,MLAYER,ZBND,LRYTH,KKH,CDH,NETI,         &
                                 SUB_BLOCKI,NSUBCM,NZMAX,NXI,NYI,NZI,        &
                                 NCELLI,ZCELLI,CDB,KPOL,EN,EMT)
                  ELSE
                     CALL EN_PRM_CS(NETI,SUB_BLOCKI,NSUBCM,NXMAX,NYMAX,NZMAX,&
                                NXI,NYI,NZI,NCELLI,XCELLI,YCELLI,ZCELLI,CDB, &
                                CS_TYPE,NCRDI,TX_CRDXI,TX_CRDYI,TX_CRDZI,    &
                                RADI,EN,EMT,FRQ,MLAYER,ZBND,KKH,CDH,ANGLES,  &
                                KEYG,KACC,AJ,NZOB,ZOBG,NZSR,ZSRG,            &
                                RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
                  END IF
!
                  DO J=1,NETI
                     ENT(J,IB)=EN(J)
                  END DO
!
               END DO
!
! --- Store ent in case of multiple excitations
!
               IF (NTXE>1.OR.(CS_TYPE==1.AND.NPOL==2)) THEN
                  DO IB=1,NBODY
                     WRITE (10) (ENT(I,IB),I=1,NET(IB))
                  END DO
               END IF
!
            END DO
! *                               *
! *********************************
         END IF
!
         IF (KSYMM==1.AND.CS_TYPE/=1) THEN
! *********************************
! *                               *
            CALL EN_PRM_GS(NEQ,NBODY,SUB_BLOCK,NBMAX,NXMAX,NYMAX,NZMAX,NET, &
                       NX,NY,NZ,NCELL,XCELL,YCELL,ZCELL,CS_TYPE,NCRDI,      &
                       TX_CRDXI,TX_CRDYI,TX_CRDZI,RADI,EJGS,FRQ,MLAYER,     &
                       ZBND,KKH,CDH,ANGLES,KEYG,KACC,AJ,NZOB,ZOBG,          &
                       NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
! --- The arrays EJGS and EJGS2 are very big.  They share the
!   memory with GA and GHF2 etc.  The unitary transforms
!   require both EJGS and EJGS2. But the array GHF2 storing
!   the grid values of the Hankel transforms is still in use
!   for computing the incident fields.  Thus EJGS must be
!   stored for now.
!
            WRITE (20) (EJGS(I),I=1,4*NEQ)
! *                               *
! *********************************
         END IF
!
      END DO
!
! --- Transform the incident field by the unitary matrix for
!   symmetrical model under controlled source excitations
!
      IF (KSYMM==1.AND.CS_TYPE/=1) THEN
!
         REWIND (20)
!
         DO IEXCI=1,NTXE
!
            READ (20) (EJGS(I),I=1,4*NEQ)
!
            DO LPR=1,NEQ/3
               DO LQR=1,4
                  DO II=1,3
                     IR=NEQ*(LQR-1)+3*(LPR-1)+II
                     EJGS2(IR)=(0.,0.)
                     DO LPC=1,NEQ/3
                        DO LQC=1,4
                           DO JJ=1,3
!
!--- Note that the entries of the unitary matrix for
!    lpr .ne. lpc and ii .ne. jj are zero
!
                              IF (LPR==LPC.AND.II==JJ) THEN
                              CALL MTRX_UNITARY(LPR,LQR,II,LPC,LQC,JJ,U)
!--- PMAX=NEQ/3.  JCOL is not computed in MTRX_UNITARY
                              JCOL=12*(LPC-1)+3*(LQC-1)+JJ
                              EJGS2(IR)=EJGS2(IR)+U*EJGS(JCOL)
                              END IF
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
!
! ---  Store EJGS2 in four files which correspond to the four
!    block matrices
!
!    The do loop IB is necessary because the incident fields
!    will be read so during system iteration later on
!
            NCB1=0
            DO IB=1,NBODY
               IF (IB>1) NCB1=NCB1+NET(IB-1)
               DO IQ=1,4
                  WRITE (40+IQ) (EJGS2(NCB1+I+NEQ*(IQ-1)),I=1,NET(IB))
               END DO
            END DO
!
         END DO
!
      END IF
!
      IF (CS_TYPE/=1.AND.KSYMM==1) THEN
         REWIND (20)
         DO IQ=1,4
            REWIND (40+IQ)
         END DO
      ELSEIF (NTXE>1.OR.(CS_TYPE==1.AND.NPOL==2)) THEN
         REWIND (10)
      END IF
!
      RETURN
      END
!
!**** End of MAIN_PRM_AT_CELL
!
!
      SUBROUTINE MAIN_SUPER_GRID(GSB1,HIGH_FRQ,CLMN2,KANIS,SBX,SBY,SBZ,   &
                                 NXS,NYS,NZS,XSB,YSB,ZSB,NSMR,FRQ,MLAYER,    &
                                 ZBND,LRYTH,KKH,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG, &
                                 DMIN,NHFILM,RHOMIN,RHOMAX,RRG,RRG3,GRHF,    &
                                 GRHF3,GRHO0,GRHO03,ALMAX,KSFT,KCLMN,        &
                                 BLMIN,KACC,KUTCRP)
!
!**** Compute the nonidentical elements of the scattering matrix for the
!   use of spatial symmetry reduction.  This must be an independent
!   subroutine called directly by the main program because of memory
!   management.  See comments about the definittion of the arrays
!   GSB1 and GSB2 in the main program for detail.
!
!
!  SBX,SBY,SBZ,NXS,NYS,NZS,XSB,YSB,ZSB,NSMR,GSB1 are to be passed
!  into routine GSB
!
!
!
!**** Called by:  main
!
!**** Calls:      THR_D_HF_TABLE,  GSB,
!
!
      IMPLICIT NONE
!
      REAL ALMAX,BLMIN,CLMN2,DMIN,FRQ,RHOMAX,RHOMIN,                        &
           SBX,SBY,SBZ,XSB,YSB,ZSB
      INTEGER KACC,KANIS,KCLMN,HIGH_FRQ,KEYG,KSFT,KUTCRP,MLAYER,NHFILM,  &
              NRG,NRG3,NSMR,NXS,NYS,NZOB,NZS,NZSR
      COMPLEX GSB1(NSMR/3,3),GRHF(11,NHFILM,NZSR,NZOB),                     &
              GRHF3(11,NHFILM,NZSR),GRHO0(4,NZSR,NZOB),                     &
              GRHO03(4,NZSR),KKH(0:MLAYER),CDH(0:MLAYER)
      REAL ZOBG(NZOB),ZSRG(2,NZSR),RRG(NHFILM),RRG3(NHFILM),                &
           LRYTH(MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER)
!
! ---- Compute the grid values for the interpolation of the
!    Hankel transforms
!
      KEYG=1
!
      CALL THR_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,   &
                          KSFT,BLMIN,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,ZOBG,   &
                          NZSR,ZSRG,ALMAX,RRG,NRG,RRG3,NRG3,GRHF,GRHF3,   &
                          GRHO0,GRHO03)
!
! ---- Compute the scattering matrix elements of the super block
!    used in spatial symmetry reduction.
!
      CALL MTRX_SPSGSB(SBX,SBY,SBZ,NXS,NYS,NZS,XSB,YSB,ZSB,NSMR,GSB1,FRQ,    &
                       MLAYER,ZBND,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,  &
                       NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,     &
                       CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
!
      RETURN
      END
!
!**** End of MAIN_SUPER_GRID
!
!
      SUBROUTINE MAIN_MATRICES(NW,HIGH_FRQ,NPOL,KSMR,CLMN,KANIS,KBOUND,   &
                               KSYMM,CS_TYPE,KCOND,GA,GSB2,IND,VV,GAI,EN,    &
                               EMT,CDB,MBODY,NBMAX,NXMAX,NYMAX,NZMAX,NSUBCM, &
                               NBODY,SUB_BLOCK,NET,NX,NY,NZ,NCELL,BLX,BLY,   &
                               BLZ,XCELL,YCELL,ZCELL,KCELL,NEQ,NMAX,NXI,NYI, &
                               NZI,NCELLI,BLXI,BLYI,BLZI,XCELLI,YCELLI,      &
                               ZCELLI,NXJ,NYJ,NZJ,NCELLJ,XCELLJ,YCELLJ,      &
                               ZCELLJ,SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NSMR,FRQ,  &
                               MLAYER,ZBND,LRYTH,KKH,CDH,CDV,HVK,NZOB,ZOBG,  &
                               NZSR,ZSRG,DMIN,NHFILM,RHOMIN,RHOMAX,RRG,RRG3, &
                               GRHF,GRHF3,GRHO0,GRHO03,ALMAX,KSFT,KCLMN,     &
                               BLMIN,KACC,KUTCRP)
!
!**** Form the scattering matrices
!
!
!
!  Parameters NHFILM, LRYTH,
!                  KANIS,KSFT,BLMIN,DMIN,RHOMIN,RHOMAX,
!                 NZOB,ZOBG,NZSR,ZSRG,ALMAX,
!                 RRG,NRG,RRG3,NRG3,GRHF,GRHF3,GRHO0,GRHO03
!  are to be passed into routine THR_D_HF_TABLE,  check THR_D_HF_TABLE for
!  their descriptions.
!
!  SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NSMR,GSB1 are to be passed
!  into routine GSB
!
!  commonly:
!  FRQ,MLAYER,ZBND,HVK,KKH,BLMIN,NZOB,ZOBG,NZSR,ZSRG,
!  RRG,NRG,DMIN,RHOMIN,NHFILM,GRHF,GRHF3,GRHO0,GRHO03
!
!
!**** Called by:  main
!
!**** Calls:  THR_D_HF_TABLE,  GSB,  MTRX_SPS,  MTRX_SPS1B,  MTRX_1MS,  MTRX_1M,
!             MTRX_SLV_FACTOR,  MTRX_SPSS,  MTRX_3MS,  MTRX_3M,  MTRX_GS,
!             MTRX_SPSM,  MTRX_M,  MTRX_GS,  MTRX_SPSSM,  MTRX_MS,
!
!
      IMPLICIT NONE
!
      REAL AEM,ALMAX,ANORM1,ANORM3,BLMIN,CLMN2,COND1,COND3,DMIN,FRQ,          &
           RHOMAX,RHOMIN,SBX,SBY,SBZ,ZSB
      INTEGER I,IB,II,IQ,J,JB,JJ,KACC,KANIS,KBOUND,KCLMN,KCOND,HIGH_FRQ,   &
              KEYG,KK,KS,KSFT,KSMR,CS_TYPE,KSYMM,NW
      INTEGER KUTCRP,LL,MBODY,MLAYER,N2,SUB_BLOCKI,SUB_BLOCKJ,NBMAX,NBODY,    &
              NCB1,NEQ,NETI,NETJ,NHFILM,NMAX,NPOL,NRG,NRG3,NSMR,NSUBCM
      INTEGER NXMAX,NXS,NYMAX,NYS,NZMAX,NZOB,NZS,NZSR
      COMPLEX GA(NMAX,NMAX),GSB2(NSMR/3,3)
!
      REAL  VV(NMAX),GAI(NMAX)
      INTEGER IND(NMAX)
      COMPLEX EN(NMAX),EMT(NMAX)
      INTEGER NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY),          &
              NCELL(NBMAX,MBODY),                                       &
              NXI(NBMAX),NYI(NBMAX),NZI(NBMAX),NXJ(NBMAX),              &
              NYJ(NBMAX),NZJ(NBMAX),NCELLI(NBMAX),NCELLJ(NBMAX),        &
              NET(MBODY),KCELL(MBODY),SUB_BLOCK(MBODY)
      REAL BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),          &
           XCELL(NXMAX,NBMAX,MBODY),YCELL(NYMAX,NBMAX,MBODY),           &
           ZCELL(NZMAX,NBMAX,MBODY)
      REAL BLXI(NBMAX),BLYI(NBMAX),BLZI(NBMAX),                         &
           XCELLI(NXMAX,NBMAX),YCELLI(NYMAX,NBMAX),                     &
           ZCELLI(NZMAX,NBMAX),XCELLJ(NXMAX,NBMAX),                     &
           YCELLJ(NYMAX,NBMAX),ZCELLJ(NZMAX,NBMAX)
      COMPLEX GRHF(11,NHFILM,NZSR,NZOB),GRHF3(11,NHFILM,NZSR),          &
              GRHO0(4,NZSR,NZOB),GRHO03(4,NZSR),                        &
              KKH(0:MLAYER),CDH(0:MLAYER),CDV(0:MLAYER)
      COMPLEX CDB(NSUBCM,NBMAX)
      REAL ZOBG(NZOB),ZSRG(2,NZSR),RRG(NHFILM),RRG3(NHFILM),            &
           LRYTH(MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER)
      REAL CLMN(NBODY)
!
      complex, allocatable :: g12(:,:)

      allocate (g12(nmax,12))
!
! ---- Compute the grid values for the interpolation of the
!    Hankel transforms if KSMR=0
!
      IF (KSMR==0) THEN
!
         KEYG=1
!
         CALL THR_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS, &
                             KSFT,BLMIN,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,ZOBG, &
                             NZSR,ZSRG,ALMAX,RRG,NRG,RRG3,NRG3,GRHF,GRHF3, &
                             GRHO0,GRHO03)
!
      END IF
!
! --- compute the diagonal submatrices
!
      DO IB=1,NBODY
         SUB_BLOCKI=SUB_BLOCK(IB)
         NETI=NET(IB)
         DO I=1,SUB_BLOCKI
            NXI(I)=NX(I,IB)
            NYI(I)=NY(I,IB)
            NZI(I)=NZ(I,IB)
            NCELLI(I)=NCELL(I,IB)
            BLXI(I)=BLX(I,IB)
            BLYI(I)=BLY(I,IB)
            BLZI(I)=BLZ(I,IB)
            DO J=1,NXI(I)
               XCELLI(J,I)=XCELL(J,I,IB)
            END DO
            DO J=1,NYI(I)
               YCELLI(J,I)=YCELL(J,I,IB)
            END DO
            DO J=1,NZI(I)
               ZCELLI(J,I)=ZCELL(J,I,IB)
            END DO
         END DO
! --- Read cell conductivity from file CONDT (unit 62)
         READ (62) ((CDB(J,I),J=1,NCELL(I,IB)),I=1,SUB_BLOCK(IB))
!
         CLMN2=CLMN(IB)
!
         IF (KCELL(IB)==1.AND.(KANIS==0.OR.KBOUND==0)) THEN
! ----- The scattering matrix is symmetric
            KS=1
         ELSE
! ----- The scattering matrix is non-symmetric
            KS=0
         END IF
!
         IF (KSYMM==1.AND.CS_TYPE==1) THEN
!
! -------- Symmetric structure (two plane symmetries) with
!        plane wave excitations (MT)
!
!---- Compute the contributions due to quadrant II and III
!
            IF (KS/=1) THEN
               CALL MTRX_3M(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,NCELLI,  &
                            NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,BLXI,     &
                            BLYI,BLZI,CDB,2,GA,FRQ,MLAYER,ZBND,CDH,CDV,HVK,  &
                            NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,  &
                            GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,CLMN2,KCLMN,   &
                            BLMIN,KACC,KUTCRP)
! ----  Symmetric scattering matrix
            ELSEIF (KSMR==1) THEN
               CALL MTRX_SPSS(NSMR,MLAYER,ZBND,CDH,CDV,SBX,SBY,SBZ,NXS,NYS,  &
                              NZS,ZSB,NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,   &
                              NZI,NCELLI,NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,    &
                              ZCELLI,CDB,2,GA,GSB2)
            ELSE
               CALL MTRX_3MS(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,        &
                             NCELLI,NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,  &
                             BLXI,BLYI,BLZI,CDB,2,GA,FRQ,MLAYER,ZBND,CDH,    &
                             CDV,HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,        &
                             NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,      &
                             GRHO03,CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
! ----  Non-symmetric scattering matrix
            END IF
!
!---- Store the results in GREEN5
!     The do loop is used in order to match the read later on
            DO I=1,NETI
               WRITE (35) (GA(J,I),J=1,NETI)
            END DO
            REWIND (35)
!
!---- Compute the contributions due to quadrant I and IV
!
            IF (KS/=1) THEN
               CALL MTRX_3M(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,         &
                            NCELLI,NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,   &
                            BLXI,BLYI,BLZI,CDB,1,GA,FRQ,MLAYER,ZBND,CDH,     &
                            CDV,HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,         &
                            NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,       &
                            GRHO03,CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
! ----  Symmetric scattering matrix
            ELSEIF (KSMR==1) THEN
               CALL MTRX_SPSS(NSMR,MLAYER,ZBND,CDH,CDV,SBX,SBY,SBZ,NXS,NYS,  &
                              NZS,ZSB,NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,   &
                              NZI,NCELLI,NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,    &
                              ZCELLI,CDB,1,GA,GSB2)
            ELSE
               CALL MTRX_3MS(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,        &
                             NCELLI,NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,  &
                             BLXI,BLYI,BLZI,CDB,1,GA,FRQ,MLAYER,ZBND,CDH,    &
                             CDV,HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,        &
                             NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,      &
                             GRHO03,CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
! ----  Non-symmetric scattering matrix
            END IF
!
!---- Store the results in GREEN6
!
            DO I=1,NETI
               WRITE (36) (GA(J,I),J=1,NETI)
            END DO
            REWIND (36)
!
! -------- Form the scattering matrix for B-polarization
!
            IF (NPOL/=1) THEN
               DO I=1,NETI
! ---- Read the results in GREEN5 by column
                  READ (35) (EMT(J),J=1,NETI)
                  DO J=1,NETI
                     GA(J,I)=GA(J,I)+EMT(J)
                  END DO
               END DO
!
               REWIND (35)
!
! ---- Factor the matrix with condition number computation
!
               CALL MTRX_SLV_FACTOR(NW,GA,NMAX,NETI,IND,VV,EN,GAI,KS,KCOND,  &
                                    ANORM1,ANORM3,COND1,COND3,AEM)
!
               WRITE (63) (IND(I),I=1,NETI)
!
               IF (KCOND==1) THEN
                  WRITE (NW,1010) IB,ANORM1,ANORM3
                  WRITE (NW,1020) COND1,COND3,AEM
               END IF
!
! --- Store the factored matrix
!
               DO I=1,NETI
                  WRITE (31) (GA(J,I),J=1,NETI)
               END DO
!
            END IF
!
! -------- Form the scattering matrix for E-polarization
!
            IF (NPOL/=0) THEN
!
!--- Read the contribution of quadrant I and IV from GREEN6
!
               DO I=1,NETI
                  READ (36) (GA(J,I),J=1,NETI)
               END DO
               REWIND (36)
!
               DO I=1,NETI
! ---- Read the results in GREEN5 by column
                  READ (35) (EMT(J),J=1,NETI)
                  DO J=1,NETI
                     GA(J,I)=GA(J,I)-EMT(J)
                  END DO
               END DO
!
               REWIND (35)
!
! ---- Factor the matrix with condition number computation
!
               CALL MTRX_SLV_FACTOR(NW,GA,NMAX,NETI,IND,VV,EN,GAI,KS,KCOND,  &
                                    ANORM1,ANORM3,COND1,COND3,AEM)
!
!--- The array IND for E-polarization must be stored in
!    another file
!
               WRITE (64) (IND(I),I=1,NETI)
!
               IF (KCOND==1) THEN
                  WRITE (NW,1030) IB,ANORM1,ANORM3
                  WRITE (NW,1040) COND1,COND3,AEM
               END IF
!
! --- Store the factored matrix
!
               DO I=1,NETI
                  WRITE (33) (GA(J,I),J=1,NETI)
               END DO
!
!
            END IF
         ELSEIF (KSYMM==1.AND.CS_TYPE/=1) THEN
!
! -------- Symmetric structure (two plane symmetries) with
!        arbitrary excitations (CSAMT).
!
!        Block diagonalization using group theory.
!        Note that all the four block matrices obtained
!        by block diagonalization are further partioned
!        into block submatrices to be used by system
!        iteration.  Here the diagonal submatrices for
!        each of the four block matrices are computed.
!
!        In order to save memory as much as possible,
!        only one column for each of the four block
!        matrices is computed at a time which is
!        then stored.
!
            NCB1=0
            DO LL=1,SUB_BLOCKI
               IF (LL>1) NCB1=NCB1+NCELLI(LL-1)
               DO II=1,NXI(LL)
                  DO JJ=1,NYI(LL)
                     DO KK=1,NZI(LL)
!
                        N2=(II-1)*NYI(LL)*NZI(LL)+(JJ-1)*NZI(LL)+KK+NCB1
!
                        CALL MTRX_GS(KSMR,NSMR,NXS,NYS,NZS,SBX,SBY,SBZ,ZSB,   &
                                   KS,1,12,N2,BLXI(LL),BLYI(LL),BLZI(LL),     &
                                   XCELLI(II,LL),YCELLI(JJ,LL),ZCELLI(KK,LL), &
                                   NMAX,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,NCELLI, &
                                   NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,    &
                                   CDB,G12,GSB2,FRQ,MLAYER,ZBND,CDH,CDV,HVK,   &
      !    CDB,GA,GSB2,FRQ,MLAYER,ZBND,CDH,CDV,HVK,   & ! error in older versions that affect sub-structure with less than 4 cells.
                                   NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,NHFILM,    &
                                   RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03, &
                                   CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
!
! --- Store the four submatrices
!
                        DO IQ=1,4
                           DO J=1,3
                              WRITE (31+IQ) (G12(I,3*(IQ-1)+J),I=1,NETI)
                   !           WRITE (31+IQ) (GA(I,3*(IQ-1)+J),I=1,NETI)
                           END DO
                        END DO
!
                     END DO
                  END DO
               END DO
            END DO
         ELSE
!
! -------- General, non-symmeytric structure
!
            IF (KS/=1) THEN
! ----  Non-symmetric scattering matrix
               CALL MTRX_1M(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,      &
                          NCELLI,NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,  &
                          BLXI,BLYI,BLZI,CDB,GA,FRQ,MLAYER,ZBND,CDH,CDV,  &
                          HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,            &
                          NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,      &
                          GRHO03,CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
! ----  Symmetric scattering matrix
            ELSEIF (KSMR==1) THEN
               CALL MTRX_SPS(NSMR,MLAYER,ZBND,CDH,CDV,SBX,SBY,SBZ,NXS,NYS,NZS,&
                          ZSB,NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,NCELLI, &
                          NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,CDB,GSB2,GA)
            ELSEIF (SUB_BLOCKI==1) THEN
!--- Use the spatial symmetry reduction for a single block
!    substructure if it cannot be use for the whole structure
               CALL MTRX_SPS1B(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,NSUBCM,&
                          SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,BLXI,BLYI,BLZI,   &
                          CDB,GA,FRQ,MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,     &
                          NZSR,ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,   &
                          NRG3,GRHF3,GRHO0,GRHO03,CLMN2,KCLMN,BLMIN,KACC,   &
                          KUTCRP)
            ELSE
               CALL MTRX_1MS(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXI,NYI,NZI,NCELLI, &
                             NSUBCM,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,BLXI,    &
                             BLYI,BLZI,CDB,GA,FRQ,MLAYER,ZBND,CDH,CDV,HVK,   &
                             NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG, &
                             GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,CLMN2,KCLMN,  &
                             BLMIN,KACC,KUTCRP)
            END IF
!
! ---- Factor the matrix with condition number computation.
!    EN works here as a working array only
!
            CALL MTRX_SLV_FACTOR(NW,GA,NMAX,NETI,IND,VV,EN,GAI,KS,KCOND,     &
                                 ANORM1,ANORM3,COND1,COND3,AEM)
!
!--- Store ind in file index1 in unit 63
!
            WRITE (63) (IND(I),I=1,NETI)
!
            IF (KCOND==1) THEN
               WRITE (NW,1050) IB,ANORM1,ANORM3
               WRITE (NW,1060) COND1,COND3,AEM
            END IF
!
! --- Store the factored matrix in unit 31
!   The do loop is used to reduced the stacks for excution
!
!   Note that if nbody = 1 the array ga needs not to be stored
!
            IF (NBODY>1) THEN
               DO I=1,NETI
                  WRITE (31) (GA(J,I),J=1,NETI)
               END DO
!
            END IF
         END IF
!
      END DO
!
      IF (KSYMM==1.AND.CS_TYPE/=1) THEN
         DO IQ=1,4
            REWIND (31+IQ)
         END DO
      ELSE
         IF (KSYMM==1.OR.NBODY>1) REWIND (31)
         IF (KSYMM==1.AND.CS_TYPE==1) REWIND (33)
      END IF
!
      IF (KSYMM/=0.AND.CS_TYPE/=1) THEN
!
! --- Read the submatrices in units 32, 33, 34, and 35 and
!   factorize them and store them in unit 31, 32, 33, and 34
!
         DO IQ=1,4
!
            IF (KCOND==1) WRITE (NW,1070) IQ
!
            DO IB=1,NBODY
               NETI=NET(IB)
!
               IF (KCELL(IB)==1.AND.(KANIS==0.OR.KBOUND==0)) THEN
! ----- The block matrix is symmetric
                  KS=1
               ELSE
! ----- The block matrix is non-symmetric
                  KS=0
               END IF
!
               DO I=1,NETI
                  READ (31+IQ) (GA(J,I),J=1,NETI)
               END DO
!
! ---- Determine the lower triangles of the block matrices
!    for symmetric matrices
!
               IF (KS==1) THEN
                  DO I=1,NETI
                     DO J=1,NETI
                        IF (J<I) GA(J,I)=GA(I,J)
                     END DO
                  END DO
               END IF
!
! ---- Factor the matrix with condition number computation.
!    EN works here as a working array only
!
               CALL MTRX_SLV_FACTOR(NW,GA,NMAX,NETI,IND,VV,EN,GAI,KS,KCOND,    &
                                    ANORM1,ANORM3,COND1,COND3,AEM)
!
!--- Store ind in files index1, index2, index3, or index4
!    in units 63, 64, 65, or 66 according to the value of IQ
!
               WRITE (62+IQ) (IND(I),I=1,NETI)
!
               IF (KCOND==1) THEN
                  IF (NBODY==1) WRITE (NW,1080) ANORM1,ANORM3
                  IF (NBODY>1) WRITE (NW,1090) IB,ANORM1,ANORM3
                  WRITE (NW,1100) COND1,COND3,AEM
               END IF
!
! --- Store the factored matrix in unit 31, 32, 33, and 34
!
               DO I=1,NETI
                  WRITE (30+IQ) (GA(J,I),J=1,NETI)
               END DO
!
            END DO
!
            REWIND (31+IQ)
!
         END DO
!
         DO IQ=1,4
            REWIND (30+IQ)
         END DO
      END IF
!
      REWIND (62)
!
      DO IQ=1,4
         REWIND (62+IQ)
      END DO
!
! ---------- Form the mutual-coupling, or off-diagonal matrices.
!          Note that the interaction matrices between two
!          substructures, ib and jb, are assumed to be
!          non-symmetric, i.e., the reciprocity do not hold
!          true due to different cell sizes in general cases.
!
!---- For efficiency in array references in interpolation,
!     jb is designed to be the out-loop here
!
!
!---- In case of spatial symmetry reductions,  the mutual
!     coupling matrices need not be formed here.  They will
!     be computed in each iteration in order to save both
!     the disk storage requirement and the disk access time.
!     For symmetric bodies with group reduction the computation
!     time needed for complete the block diagonalizations is
!     too much to be economical.  Thus the mutual interaction
!     matrices will be always stored unless the total disk
!     storage requirements exceed ca. 200 M-bytes, i.e., about
!     800 cells per quadrant.
!
!
      IF (.NOT.(NBODY==1.OR.KSMR==1.AND.(KSYMM==0.OR.CS_TYPE==1).OR.  &
          KSMR==1.AND.CS_TYPE/=1.AND.KSYMM==1.AND.NEQ/3>800)) THEN
!
         DO JB=1,NBODY
!
            SUB_BLOCKJ=SUB_BLOCK(JB)
            NETJ=NET(JB)
            DO I=1,SUB_BLOCKJ
               NXJ(I)=NX(I,JB)
               NYJ(I)=NY(I,JB)
               NZJ(I)=NZ(I,JB)
               NCELLJ(I)=NCELL(I,JB)
               DO J=1,NXJ(I)
                  XCELLJ(J,I)=XCELL(J,I,JB)
               END DO
               DO J=1,NYJ(I)
                  YCELLJ(J,I)=YCELL(J,I,JB)
               END DO
               DO J=1,NZJ(I)
                  ZCELLJ(J,I)=ZCELL(J,I,JB)
               END DO
            END DO
!
            DO IB=1,NBODY
!
               SUB_BLOCKI=SUB_BLOCK(IB)
               NETI=NET(IB)
               DO I=1,SUB_BLOCKI
                  NXI(I)=NX(I,IB)
                  NYI(I)=NY(I,IB)
                  NZI(I)=NZ(I,IB)
                  NCELLI(I)=NCELL(I,IB)
                  BLXI(I)=BLX(I,IB)
                  BLYI(I)=BLY(I,IB)
                  BLZI(I)=BLZ(I,IB)
                  DO J=1,NXI(I)
                     XCELLI(J,I)=XCELL(J,I,IB)
                  END DO
                  DO J=1,NYI(I)
                     YCELLI(J,I)=YCELL(J,I,IB)
                  END DO
                  DO J=1,NZI(I)
                     ZCELLI(J,I)=ZCELL(J,I,IB)
                  END DO
               END DO
!
               CLMN2=CLMN(IB)
!
               IF (IB/=JB) THEN
!
                  IF (KSYMM==1.AND.CS_TYPE/=1) THEN
!
! ---- Groupe reduction for controlled source problems
!
                     NCB1=0
                     DO LL=1,SUB_BLOCKI
                        IF (LL>1) NCB1=NCB1+NCELLI(LL-1)
                        DO II=1,NXI(LL)
                           DO JJ=1,NYI(LL)
                              DO KK=1,NZI(LL)
!
                              N2=(II-1)*NYI(LL)*NZI(LL)+(JJ-1)*NZI(LL)   &
                                 +KK+NCB1
!
! ---   cdb is not used and is thus arbitrary
!
                              CALL MTRX_GS(KSMR,NSMR,NXS,NYS,NZS,SBX,SBY,SBZ,  &
                                         ZSB,0,0,12,N2,BLXI(LL),BLYI(LL),      &
                                         BLZI(LL),XCELLI(II,LL),YCELLI(JJ,LL), &
                                         ZCELLI(KK,LL),NMAX,NXMAX,NYMAX,NZMAX, &
                                         NXJ,NYJ,NZJ,NCELLJ,NSUBCM,SUB_BLOCKJ, &
                                         XCELLJ,YCELLJ,ZCELLJ,CDB,G12,GSB2,FRQ,  &
   !      XCELLJ,YCELLJ,ZCELLJ,CDB,GA,GSB2,FRQ,  &  ! error in older versions that affect sub-structure with less than 4 cells.
                                         MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,    &
                                         NZSR,ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG, &
                                         GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,    &
                                         CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
!
! --- Store the four submatrices
!
!   Note that the submatrices as computed by the routines
!   MTRX_SPSM, MTRX_M, MTRX_SPSSM, MTRX_MS, MTRX_SPSSM, and MTRX_MS
!   have their sign reversed as compared with the results
!   here.  Thus -GA is stored in order to use the same
!   algorithm for system iteration
!
                              DO IQ=1,4
                              DO J=1,3
                              WRITE (34+IQ) (-G12(I,3*(IQ-1)+J),I=1,NETJ)
                      !        WRITE (34+IQ) (-GA(I,3*(IQ-1)+J),I=1,NETJ)
                              END DO
                              END DO
!
                              END DO
                           END DO
                        END DO
!
                     END DO
                  ELSEIF (KSYMM==1.AND.CS_TYPE==1) THEN
!
! ---- Compute the contributions due to quadrant II and III
!    for plane wave excitations
!
                     IF (KSMR==1) THEN
                        CALL MTRX_SPSSM(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NMAX,    &
                           NETI,NXMAX,NYMAX,NZMAX,NXJ,NYJ,NZJ,NCELLJ,        &
                           SUB_BLOCKJ,XCELLJ,YCELLJ,ZCELLJ,NXI,NYI,NZI,      &
                           NCELLI,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,2,GA,NSMR, &
                           GSB2)
                     ELSE
                        CALL MTRX_MS(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXJ,NYJ,   &
                           NZJ,NCELLJ,SUB_BLOCKJ,XCELLJ,YCELLJ,ZCELLJ,NXI,  &
                           NYI,NZI,NCELLI,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,  &
                           BLXI,BLYI,BLZI,2,GA,FRQ,MLAYER,ZBND,CDH,HVK,     &
                           NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,                 &
                           NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,       &
                           GRHO03,CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
                     END IF
!
!---- Store the results in GREEN5
!     The do loop is used in order to match the read later on
                     DO I=1,NETI
                        WRITE (35) (GA(J,I),J=1,NETJ)
                     END DO
                     REWIND (35)
!
!---- Compute the contributions due to quadrant I and IV
!
                     IF (KSMR==1) THEN
                        CALL MTRX_SPSSM(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NMAX,    &
                           NETI,NXMAX,NYMAX,NZMAX,NXJ,NYJ,NZJ,NCELLJ,        &
                           SUB_BLOCKJ,XCELLJ,YCELLJ,ZCELLJ,NXI,NYI,NZI,      &
                           NCELLI,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,1,GA,NSMR, &
                           GSB2)
                     ELSE
                        CALL MTRX_MS(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXJ,NYJ,   &
                           NZJ,NCELLJ,SUB_BLOCKJ,XCELLJ,YCELLJ,ZCELLJ,NXI,  &
                           NYI,NZI,NCELLI,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,  &
                           BLXI,BLYI,BLZI,1,GA,FRQ,MLAYER,ZBND,CDH,HVK,     &
                           NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,                 &
                           NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,       &
                           GRHO03,CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
                     END IF
!
!---- Store the results in GREEN6
!
                     DO I=1,NETI
                        WRITE (36) (GA(J,I),J=1,NETJ)
                     END DO
                     REWIND (36)
!
! -------- Form the interaction matrices for B-polarization
!
                     IF (NPOL/=1) THEN
!
                        DO I=1,NETI
! ---- Read the results in GREEN5 by column
                           READ (35) (EMT(J),J=1,NETJ)
                           DO J=1,NETJ
                              GA(J,I)=GA(J,I)+EMT(J)
                           END DO
                        END DO
!
                        REWIND (35)
!
! ---- Store the B-p interaction matrices in GREEN2
!
                        DO I=1,NETI
                           WRITE (32) (GA(J,I),J=1,NETJ)
                        END DO
!
                     END IF
!
! -------- Form the interaction matrices for E-polarization
!
                     IF (NPOL/=0) THEN
!
!--- Read the contribution of quadrant I and IV from GREEN6
!
                        DO I=1,NETI
                           READ (36) (GA(J,I),J=1,NETJ)
                        END DO
                        REWIND (36)
!
                        DO I=1,NETI
! ---- Read the results in GREEN5 by column
                           READ (35) (EMT(J),J=1,NETJ)
                           DO J=1,NETJ
                              GA(J,I)=GA(J,I)-EMT(J)
                           END DO
                        END DO
!
                        REWIND (35)
!
! ---- Store the E-p interaction matrices in GREEN4
!
                        DO I=1,NETI
                           WRITE (34) (GA(J,I),J=1,NETJ)
                        END DO
!
                     END IF
                  ELSE
!
                     IF (KSMR==1) THEN
                        CALL MTRX_SPSM(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NMAX,NETI,&
                           NXMAX,NYMAX,NZMAX,NXJ,NYJ,NZJ,NCELLJ,SUB_BLOCKJ,  &
                           XCELLJ,YCELLJ,ZCELLJ,NXI,NYI,NZI,NCELLI,          &
                           SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,GA,NSMR,GSB2)
                     ELSE
                        CALL MTRX_M(NMAX,NETI,NXMAX,NYMAX,NZMAX,NXJ,NYJ,    &
                           NZJ,NCELLJ,SUB_BLOCKJ,XCELLJ,YCELLJ,ZCELLJ,NXI,  &
                           NYI,NZI,NCELLI,SUB_BLOCKI,XCELLI,YCELLI,ZCELLI,  &
                           BLXI,BLYI,BLZI,GA,FRQ,MLAYER,ZBND,CDH,HVK,       &
                           NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,                 &
                           NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,       &
                           GRHO03,CLMN2,KCLMN,BLMIN,KACC,KUTCRP)
                     END IF
!
! ---- Store the interaction matrices in GREEN2
!
                     DO I=1,NETI
                        WRITE (32) (GA(J,I),J=1,NETJ)
!
                     END DO
                  END IF
               END IF
!
            END DO
         END DO
!
         IF (KSYMM==1.AND.CS_TYPE/=1) THEN
            DO IQ=1,4
               REWIND (34+IQ)
            END DO
         ELSE
            REWIND (32)
            IF (KSYMM==1) REWIND (34)
         END IF
      END IF
!
      deallocate (g12)

      RETURN
 1010 FORMAT (/'Maximal column and maximal row norms of the ',           &
              'scattering matrix',/'  for substructure #',I3,            &
              ' for B-polarization:',2E15.7)
 1020 FORMAT ('Condition numbers after these two norms:',3X,2E15.7,      &
              /'Maximal diagonal element of the matrix:',4X,E15.7)
 1030 FORMAT (/'Maximal column and maximal row norms of the ',           &
              'scattering matrix',/'  for substructure #',I3,            &
              ' for E-polarization:',2E15.7)
 1040 FORMAT ('Condition numbers after these two norms:',3X,2E15.7,      &
              /'Maximal diagonal element of the matrix:',4X,E15.7)
 1050 FORMAT (/'Maximal column and maximal row norms of the ',           &
              'scattering matrix',/'  for substructure #',I3,':',16X,    &
              2E15.7)
 1060 FORMAT ('Condition numbers after these two norms:',2E15.7,         &
              /'Maximal diagonal element of the matrix:',E16.7)
 1070 FORMAT (/'Norms and condition numbers of the ',                    &
              'submatrices for quadrant',I2)
 1080 FORMAT (/'    Maximal column and row norms:           ',2E15.7)
 1090 FORMAT ('  Substructure #',I3,':',                                 &
              /'    Maximal column and row norms:           ',2E15.7)
 1100 FORMAT ('    Condition numbers after these two norms:',2E15.7,     &
              /'    Maximal diagonal element of the matrix:',E16.7)
      END
!
!**** End of MAIN_MATRICES
!
!
      SUBROUTINE MAIN_SOLVER(NW,GA,IND,EMT,EN,ENT,NET,JST,EJGS,EJGS2,        &
                             KACC,KSMR,KSYMM,CS_TYPE,KANIS,KBOUND,NTXE,    &
                             LP1,LP2,NPOL,MBODY,NBMAX,NXMAX,NYMAX,NZMAX,     &
                             NMAX,NBODY,SUB_BLOCK,NX,NY,NZ,NCELL,NCT,KCELL,  &
                             XCELL,YCELL,ZCELL,BLX,BLY,BLZ,NXI,NYI,NZI,      &
                             NCELLI,XCELLI,YCELLI,ZCELLI,BLXI,BLYI,BLZI,     &
                             NXJ,NYJ,NZJ,NCELLJ,XCELLJ,YCELLJ,ZCELLJ,        &
                             SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NSMR,GSB2,NEQ)
!
!--- NITMAX is the maximal number of iteration allowed in the
!    program.  It is also the maximal length of the array ERR.
!
      IMPLICIT NONE
!
      REAL EPS,FRACCN,SBX,SBY,SBZ,TJS,U,ZSB
      INTEGER I,IB,IEXCI,II,IQ,IROW,J,JB,JC,JJ,KACC,KANIS,KBOUND,KPOL,   &
              KSMR,CS_TYPE,KSYMM,LP1,LP2,LPC,NW
      INTEGER LPR,LQC,LQR,MBODY,SUB_BLOCKI,SUB_BLOCKJ,NBMAX,NBODY,NCB1,NCMAX,&
              NEQ,NERR,NETI,NETJ,NITER,NITM,NITMAX,NMAX,NPOL,NQ
      INTEGER NSMR,NUNIT,NTXE,NXMAX,NXS,NYMAX,NYS,NZMAX,NZS
      PARAMETER (NITMAX=500)
!
      REAL ERR(NITMAX)
!
      COMPLEX GA(NMAX,NMAX)

!**** Only one of them
      COMPLEX GSB2(NSMR/3,3)
!   COMPLEX GSB1(NSMR/3,3),GSB2(NSMR/3,3)

      INTEGER IND(NMAX)
      COMPLEX EN(NMAX),EMT(NMAX),ENT(NMAX,MBODY),JST(NMAX,MBODY),   &
              EJGS(4*NMAX*MBODY),EJGS2(4*NMAX*MBODY)
      INTEGER NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY),      &
              NCELL(NBMAX,MBODY),                                   &
              NXI(NBMAX),NYI(NBMAX),NZI(NBMAX),NXJ(NBMAX),          &
              NYJ(NBMAX),NZJ(NBMAX),NCELLI(NBMAX),NCELLJ(NBMAX),    &
              NCT(MBODY),NET(MBODY),KCELL(MBODY),SUB_BLOCK(MBODY)
      REAL BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),      &
           XCELL(NXMAX,NBMAX,MBODY),YCELL(NYMAX,NBMAX,MBODY),       &
           ZCELL(NZMAX,NBMAX,MBODY)
      REAL BLXI(NBMAX),BLYI(NBMAX),BLZI(NBMAX),                     &
           XCELLI(NXMAX,NBMAX),YCELLI(NYMAX,NBMAX),                 &
           ZCELLI(NZMAX,NBMAX),XCELLJ(NXMAX,NBMAX),                 &
           YCELLJ(NYMAX,NBMAX),ZCELLJ(NZMAX,NBMAX)
!
! --- Solving the matrix equations for the scattering currents
!   in the 3D structure using the system iteration method
!
!-- The maximal number of iterations is determined by the
!   number of substructures and the total number of cells.
!   500 cells as reference
!
      NCMAX=0
      DO IB=1,NBODY
         NCMAX=NCMAX+NCT(IB)
      END DO
      FRACCN=FLOAT(NCMAX)/500.
!
      NITM=2*NBODY**2
      IF (NITM<60) NITM=60
      NITM=INT(NITM*(1.+FRACCN))
      IF (NITM>NITMAX) NITM=NITMAX
!
!-- KACC=1 corresponds to approximate solutions with an
!   accuracy of 20%.  NITLM will also be limited to be 3
!   for the fast solver
!
      IF (KACC==1) THEN
         EPS=2.E-01
         NITM=3
      ELSEIF (KACC>=2.AND.KACC<=4) THEN
         EPS=1.E-04
      ELSE
         EPS=1.E-05
      END IF
!
      IF (KSYMM==1.AND.CS_TYPE/=1) THEN
         NQ=4
      ELSE
         NQ=1
      END IF
!
!--- Start the loop for the four quadrants in case of
!    group reduction
!
      DO IQ=1,NQ
!
! ---- Start the loop for multiple excitations
!
         DO IEXCI=1,NTXE
!
!--- Start system iteration for the B and E-polarization for
!    plane wave excitations
!
            DO KPOL=LP1,LP2
!
               IF (NQ/=1) THEN
! -- Read ent from unit 41, 42, 43, or 44 for the corresponding
!    quadrants
                  DO IB=1,NBODY
                     READ (40+IQ) (EMT(I),I=1,NET(IB))
                     DO J=1,NET(IB)
                        ENT(J,IB)=EMT(J)
                     END DO
                  END DO
! -- Read ent from unit 10 for multiple excitations
               ELSEIF (NTXE>1.OR.NPOL==2) THEN
                  DO IB=1,NBODY
                     READ (10) (EMT(I),I=1,NET(IB))
                     DO J=1,NET(IB)
                        ENT(J,IB)=EMT(J)
                     END DO
                  END DO
               END IF
!
! ---- Assign jst initial values (zero)
!
               DO IB=1,NBODY
                  DO I=1,NET(IB)
                     JST(I,IB)=(0.,0.)
                  END DO
               END DO
!
               NITER=1
   10          ERR(NITER)=0.
               TJS=0.
               NERR=0
!
! ---- Loop 4500 is for the solutions of the scattering currents
!    in the substructures (# JB)
!
               DO JB=1,NBODY
                  NETJ=NET(JB)
!    LET=NETJ*(NETJ+1)/2
                  NERR=NERR+NETJ
!
                  DO I=1,NETJ
                     EMT(I)=(0.,0.)
                  END DO
!
! ---- Computing mutual interactions, namely, the scattered fields
!    of all other substructure to substructures jb
!
!--- The mutual interaction matrices will be either read from
!    the disk or computed with pre-computed values using the
!    spatial symmetry property of the Green's functions.
!    See the comments before the line labeled 5800 for more
!    explanations
!
                  DO IB=1,NBODY
!
                     IF (IB/=JB) THEN
                        NETI=NET(IB)
!
                        IF (KSMR==1.AND.(KSYMM==0.OR.CS_TYPE==1).OR.  &
                            KSMR==1.AND.CS_TYPE/=1.AND.KSYMM==1.AND.  &
                            NEQ/3>800) THEN
!
!    END IF
!
! ---- Re-compute the matrices using spatial symmetries
!
! -- The following lines are similar to those for forming the
!    mutual-coupling matrices earlier in the program,  with
!    slight differences in some subroutines.
!
! -- The following lines for jb may be moved outside the
!    ib loop.
!
                           SUB_BLOCKJ=SUB_BLOCK(JB)
                           NETJ=NET(JB)
                           DO I=1,SUB_BLOCKJ
                              NXJ(I)=NX(I,JB)
                              NYJ(I)=NY(I,JB)
                              NZJ(I)=NZ(I,JB)
                              NCELLJ(I)=NCELL(I,JB)
                              DO J=1,NXJ(I)
                              XCELLJ(J,I)=XCELL(J,I,JB)
                              END DO
                              DO J=1,NYJ(I)
                              YCELLJ(J,I)=YCELL(J,I,JB)
                              END DO
                              DO J=1,NZJ(I)
                              ZCELLJ(J,I)=ZCELL(J,I,JB)
                              END DO
                           END DO
!
                           SUB_BLOCKI=SUB_BLOCK(IB)
                           NETI=NET(IB)
                           DO I=1,SUB_BLOCKI
                              NXI(I)=NX(I,IB)
                              NYI(I)=NY(I,IB)
                              NZI(I)=NZ(I,IB)
                              NCELLI(I)=NCELL(I,IB)
                              BLXI(I)=BLX(I,IB)
                              BLYI(I)=BLY(I,IB)
                              BLZI(I)=BLZ(I,IB)
                              DO J=1,NXI(I)
                              XCELLI(J,I)=XCELL(J,I,IB)
                              END DO
                              DO J=1,NYI(I)
                              YCELLI(J,I)=YCELL(J,I,IB)
                              END DO
                              DO J=1,NZI(I)
                              ZCELLI(J,I)=ZCELL(J,I,IB)
                              END DO
                           END DO
!
                           IF (KSYMM==1.AND.CS_TYPE/=1) THEN
!
! ---- Groupe reduction for controlled source problems
!
!
                              CALL MTRX_SMRGS(NXS,NYS,NZS,SBX,SBY,SBZ,ZSB,  &
                                 NMAX,NXMAX,NYMAX,NZMAX,NETI,SUB_BLOCKI,    &
                                 NCELLI,XCELLI,YCELLI,ZCELLI,NXI,NYI,       &
                                 NZI,NETJ,SUB_BLOCKJ,NCELLJ,NXJ,NYJ,NZJ,    &
                                 XCELLJ,YCELLJ,ZCELLJ,IQ,GA,NSMR,GSB2)
                           ELSEIF (KSYMM==1.AND.CS_TYPE==1) THEN
!
! ---- Plane wave excitations
!
                              CALL MTRX_SPSSM2(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB, &
                                 NMAX,NETJ,NETI,NXMAX,NYMAX,NZMAX,NXJ,      &
                                 NYJ,NZJ,NCELLJ,SUB_BLOCKJ,XCELLJ,YCELLJ,   &
                                 ZCELLJ,NXI,NYI,NZI,NCELLI,SUB_BLOCKI,      &

                                 XCELLI,YCELLI,ZCELLI,KPOL,GA,NSMR,GSB2)
                           ELSE
!
!
                              CALL MTRX_SPSM(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,    &
                                 NMAX,NETI,NXMAX,NYMAX,NZMAX,NXJ,NYJ,        &
                                 NZJ,NCELLJ,SUB_BLOCKJ,XCELLJ,YCELLJ,ZCELLJ, &
                                 NXI,NYI,NZI,NCELLI,SUB_BLOCKI,XCELLI,       &
                                 YCELLI,ZCELLI,GA,NSMR,GSB2)
                           END IF
                        ELSE
!
!    IF(KSMR==0 .OR.
!   +   KSMR==1.AND.CS_TYPE.NE.1.AND.KSYMM==1.AND.
!   +   NEQ/3<800) THEN
!
! ---- Read the interaction matrices from GREEN2, GREEN4
!    or GREEN5 through GREEN8
!
                           IF (KSYMM==1.AND.CS_TYPE/=1) THEN
                              NUNIT=34+IQ
                           ELSEIF (KSYMM==0.OR.KPOL==1) THEN
                              NUNIT=32
                           ELSE
                              NUNIT=34
                           END IF
                           DO I=1,NETI
                              READ (NUNIT) (GA(J,I),J=1,NETJ)
!
                           END DO
                        END IF
!
!-- Compute the mutual interactions
!
                        DO I=1,NETI
                           DO J=1,NETJ
                              EMT(J)=EMT(J)+GA(J,I)*JST(I,IB)
                           END DO
                        END DO
                     END IF
                  END DO
!
                  DO J=1,NETJ
                     EN(J)=ENT(J,JB)+EMT(J)
                  END DO
!
!--- Read the factored matrices from GREEN1 or GREEN3
!    for MT problems,  or from GREEN1, GREEN2, GREEN3,
!    and GREEN4 for CSAMT problems with group reduction
!
!    Note that if nbody=1 and ksymm=0 ga is not stored
!
                  IF (KSYMM/=0.OR.NBODY/=1) THEN
!
                     IF (KSYMM==1.AND.CS_TYPE/=1) THEN
!
!-- Read the factored matrices for each quadrant in
!   case of group reduction
!
                        DO I=1,NETJ
                           READ (30+IQ) (GA(J,I),J=1,NETJ)
                        END DO
!
                     ELSEIF (KSYMM==0.OR.KPOL==1) THEN
                        DO I=1,NETJ
                           READ (31) (GA(J,I),J=1,NETJ)
                        END DO
                     ELSE
                        DO I=1,NETJ
                           READ (33) (GA(J,I),J=1,NETJ)
                        END DO
                     END IF
                  END IF
!
!-- Read the array ind from the files index1 though index4
!   in unit 63 through 66
!
                  IF (KSYMM==1.AND.CS_TYPE/=1) THEN
                     READ (62+IQ) (IND(J),J=1,NETJ)
                  ELSEIF (KSYMM==1.AND.KPOL==2.AND.NPOL==2) THEN
                     READ (64) (IND(J),J=1,NETJ)
                  ELSE
                     READ (63) (IND(J),J=1,NETJ)
                  END IF
!
                  IF (KCELL(JB)==1.AND.(KANIS==0.OR.KBOUND==0)) THEN
                     CALL MTRX_SLV_CSISL(GA,NMAX,NETJ,IND,EN)
                  ELSE
                     CALL MTRX_SLV_LUBKSB(GA,EN,NMAX,NETJ,IND)
                  END IF
!
! ----- Determine the accuracy of iteration and store the
!     evaluated scattering currents
!
                  DO J=1,NETJ
!
!--- The following error criterium some times yield pure
!    convergency if jst is negligible but have large
!    relative error.
!      ERR(NITER)=ERR(NITER)+((ABS(EN(J))-ABS(JST(J,JB)))/
!   +           (ABS(EN(J))+ABS(JST(J,JB))+1.E-30))**2
                     ERR(NITER)=ERR(NITER)   &
                        +(ABS(ABS(EN(J))-ABS(JST(J,JB))))**2
                     TJS=TJS+(ABS(EN(J)))**2
                     JST(J,JB)=EN(J)
                  END DO
!
               END DO
!
!    ERR(NITER)=SQRT(ERR(NITER)/NERR)
!
! --- 1.E-30 is added to TJS to avoid overflow in case TJS is zero.
!   TJS may be zero for some quadrants if a vertical dipole is
!   located on some symmetry axes.
!
               ERR(NITER)=SQRT(ERR(NITER)/(TJS+1.E-30))
!
! --- Rewind all the files regardless convergency or not because
!   there may be multi-excitations.
!
               IF (KSYMM==1.AND.CS_TYPE/=1) THEN
                  REWIND (30+IQ)
                  REWIND (34+IQ)
               ELSEIF (KSYMM==0.OR.KPOL==1) THEN
                  IF (NBODY>1) REWIND (31)
                  IF (NBODY>1) REWIND (32)
               ELSE
                  REWIND (33)
                  REWIND (34)
               END IF
               DO I=1,4
                  REWIND (62+I)
               END DO
!
               IF (ERR(NITER)<=EPS.OR.NITER>=NITM.OR.NBODY==1) THEN
!
                  IF (NBODY>1) THEN
                     IF (NTXE>1) WRITE (23,1030) IEXCI
                     IF (NTXE==1) WRITE (NW,*) ' '
                     IF (KSYMM==1.AND.CS_TYPE.NE.1) THEN
                        WRITE (23,1040) IQ,NITER
                     ELSE
                        WRITE (23,1050) NITER
                     END IF
                  END IF
                  IF (NITER>=NITM) THEN
                     IF (KSYMM==1.AND.CS_TYPE/=1) THEN
                        WRITE (NW,1010) NITER,IQ,ERR(NITER)
                     ELSE
                        WRITE (NW,1020) NITER,ERR(NITER)
                     END IF
                  END IF
!
! --- Store jst in case of multiple excitation
!   or group reduction
!   Note that kpol=1 for controlled source problems
!
                  IF (KSYMM==1.AND.CS_TYPE/=1) THEN
                     DO IB=1,NBODY
                        WRITE (44+IQ) (JST(I,IB),I=1,NET(IB))
                     END DO
                  ELSEIF (NTXE>1.OR.(CS_TYPE==1.AND.NPOL==2)) THEN
                     DO IB=1,NBODY
                        WRITE (20) (JST(I,IB),I=1,NET(IB))
                     END DO
                  END IF
               ELSE
                  NITER=NITER+1
                  IF (KSYMM==0.AND.NBODY==1) THEN
                  END IF
                  GOTO 10
               END IF
!
            END DO
         END DO
!
         IF ((KSYMM==0.AND.NTXE>1).OR.(CS_TYPE==1.AND.NPOL==2))  &
             REWIND (20)
         IF (KSYMM==1.AND.CS_TYPE/=1) REWIND (44+IQ)
!
      END DO
!
      IF (KSYMM/=0.AND.CS_TYPE/=1) THEN
!
! --- Read the transformed scattering currents from units
!   45 through 48, transform them back to real scattering
!   currents, and then store them in unit 20
!
         DO IEXCI=1,NTXE
!
            DO IQ=1,4
               NCB1=0
               DO IB=1,NBODY
                  IF (IB>1) NCB1=NCB1+NET(IB-1)
                  READ (44+IQ) (EMT(I),I=1,NET(IB))
                  DO J=1,NET(IB)
                     EJGS(J+NCB1+NEQ*(IQ-1))=EMT(J)
                  END DO
               END DO
            END DO
!
! --- Back transformation of the scattering currents by
!   the transposed unitary matrix
!
            DO LPC=1,NEQ/3
               DO LQC=1,4
                  DO JJ=1,3
                     JC=12*(LPC-1)+3*(LQC-1)+JJ
                     EJGS2(JC)=(0.,0.)
                     DO LPR=1,NEQ/3
                        DO LQR=1,4
                           DO II=1,3
!
!--- Note that the entries of the unitary matrix for
!    lpr .ne. lpc and ii .ne. jj are zero
!
                              IF (LPR==LPC.AND.II==JJ) THEN
                              CALL MTRX_UNITARY(LPR,LQR,II,LPC,LQC,JJ,U)
!-- PMAX=NEQ/3,  IROW is not computed in MTRX_UNITARY
                              IROW=NEQ*(LQR-1)+3*(LPR-1)+II
                              EJGS2(JC)=EJGS2(JC)+U*EJGS(IROW)
                              END IF
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
!
! ---  Store EJGS2 in unit 20
!
            WRITE (20) (EJGS2(I),I=1,4*NEQ)
!
         END DO
!
         REWIND (20)
      END IF
!

      RETURN
!                IF (NBODY>1) THEN
!                   WRITE (NW,*)
!   +                       'Relative differences of the soultion in ',
!   +                      'each iteration:'
!                   WRITE (NW,1060) (ERR(J),J=1,NITER)
! 1060              FORMAT (4X,5E12.3)
!                END IF
 1010 FORMAT (' Warning: Iteration did not converge in ',I4,  &
              ' iterations! for quadrant #',I2,  &
              /' Accuracy of the solution:',E10.3)
 1020 FORMAT (' Warning: Iteration did not converge in ',I4,  &
              ' iterations!',/' Accuracy of the solution:',E10.3)
 1030             FORMAT (/'Excitation (or transmitter) number',I3)
 1040             FORMAT ('Number of system iterations for quadrant #',   &
                          I2,':',I4)
 1050             FORMAT ('Number of system iterations:',I4)
      END
!
!**** End of MAIN_SOLVER
!
!
      SUBROUTINE MAIN_PRM_AT_RCV(HIGH_FRQ,CS_TYPE,KACC,MLAYER,ZBND,RMU_LYR,  &
                                 CDH,FRQ,NTXE,MD_ANGLE,NCRD,M_RX,N_SUB_RX,   &
                                 RX_TYPE_INDEX,SUB_RX_MAX,                   &
                                 SOURCE_TYPE,N_RX,RX_X,RX_Y,RX_Z,            &
                                 RX_WEIGHT,N_VRTX,                           &
                                 TX_CRDX,TX_CRDY,TX_CRDZ,E_ONLY,ENX,ENY,ENZ, &
                                 HNX,HNY,HNZ,VLT1D,NHFILM,LRYTH,HVK,KKH,     &
                                 KANIS,BLMIN,DMIN,RHOMIN,RHOMAX,NZOB,ZOBG,   &
                                 NZSR,ZSRG,NZBG,ZBG,ALMAX,GRHF,RRG,GRHO0)
!
!**** Calculate the normal fields at receiver stations
!
!     **** MT not considered yet!!!!
!
!  Input parameters
!
!
!    N_SUB_RX:
!    RX_WEIGHT(3,SUB_RX_MAX,LRX,NTXE)
!
!    E_ONLY: Integer. E_ONLY controls if components of electric field are to be computed.
!            This is useful for electric components at receiver locations for many other
!            purposes.  It is important, however, that the number of sub-receivers must
!            be 1, or at least the first elements for the sub-receiver index of all the
!            receivers must be the coordinates for the intended receiver sites, ie.,
!            RX_X(1,i,j), RX_Y(1,i,j) and RX_Z(1,i,j) are the receiver coordinates for
!            the ith receiver of the jth source.
!            =1: compute E component only;
!            =0: compute either H components (E components are also computed together with H)
!                or voltage between electrodes.
!
!
!
!  *** Note that output HNX etc for magnetic dipoles are in fact components of B.
!
!     Parameter CS_TYPE need to be passed into this routine despite the use
!     of SOURCE_TYPE.  CS_TYPE will be passed into routine ONE_D_GREEN,  particularly
!     if CS_TYPE=4 for which routine ONE_D_GREEN will take out charge terms for loops,
!     unless SOURCE_TYPE is passed into ONE_D_GREEN to replace the funciton of CS_TYPE.
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: NTXE,NZOB,NZSR,NZBG,SUB_RX_MAX,NCRD,NHFILM,        &
                             SOURCE_TYPE,E_ONLY,HIGH_FRQ,                       &
                             M_RX,N_SUB_RX(M_RX,NTXE),RX_TYPE_INDEX(M_RX,NTXE)
!
      REAL ALMAX,BLMIN,DMIN,FRQ,RHOMAX,RHOMIN
      INTEGER KACC,KANIS,KEYG,CS_TYPE,MLAYER,NRG,NCRDI
      COMPLEX EX,EY,EZ,HX,HY,HZ,VLT1D(M_RX,NTXE),                          &
              ENX(M_RX,NTXE),ENY(M_RX,NTXE),ENZ(M_RX,NTXE),           &
              HNX(M_RX,NTXE),HNY(M_RX,NTXE),HNZ(M_RX,NTXE),           &
              KKH(0:MLAYER),EHFLD(6),CDH(0:MLAYER),                         &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
!
!  Transmitter coordinates in single precision for internal computations.
!
      REAL, INTENT(IN) :: TX_CRDX(NCRD,NTXE),                       &
                          TX_CRDY(NCRD,NTXE),                       &
                          TX_CRDZ(NCRD,NTXE)
      REAL, INTENT(IN) :: LRYTH(MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER),RMU_LYR(MLAYER)
      REAL, INTENT(IN) :: ZOBG(NZOB),ZSRG(2,NZSR)
      REAL, INTENT(INOUT) :: ZBG(2,NZBG),RRG(NHFILM)
      REAL, INTENT(IN) :: RX_X(SUB_RX_MAX,M_RX,NTXE),               &
                          RX_Y(SUB_RX_MAX,M_RX,NTXE),               &
                          RX_Z(SUB_RX_MAX,M_RX,NTXE),               &
                          RX_WEIGHT(3,SUB_RX_MAX,M_RX,NTXE)
      INTEGER, INTENT(IN) :: N_RX(NTXE),N_VRTX(NTXE)
      REAL, INTENT(IN) :: MD_ANGLE(2,NTXE)
      REAL :: ANGLES(2)
!
!  Transmitter and reciever coordinates in single precision for internal computations.
!  Use of double precision Tx/Rx coordinates stop at the level of this routine.
!
      REAL, ALLOCATABLE, DIMENSION(:) :: TX_CRDXI,TX_CRDYI,TX_CRDZI
      REAL :: RECVR(3)
      EQUIVALENCE (EHFLD(1),EX),(EHFLD(2),EY),(EHFLD(3),EZ),   &
                  (EHFLD(4),HX),(EHFLD(5),HY),(EHFLD(6),HZ)
!
      REAL, PARAMETER :: AJ=1.      ! Aj is the amplitude of the current
      REAL, PARAMETER :: RADI=0.    ! Radi is the radius of a circular loop. Defunct in current version.
      INTEGER I,IEXCI,II,K,NSUB_RX1,NOB,J,I_TYPE3
      REAL :: LX,LY,LZ,C_INT,RMU
!
!  -- Set keyg=2 for both electric and magentic components
      KEYG=2
!
!  -- Allocate working array for the electrode coordinates of the loops
!
      ALLOCATE(TX_CRDXI(NCRD),TX_CRDYI(NCRD),TX_CRDZI(NCRD))
!
! --- Initialise VLT1D etc because some of their element will not be computed
!     (M_RX vs actual receivers per transmitter) but may be accessed in the
!     calling routine that run through all indexes.
!
      VLT1D=(0.,0.)
      ENX=(0.,0.)
      ENY=(0.,0.)
      ENZ=(0.,0.)
      HNX=(0.,0.)
      HNY=(0.,0.)
      HNZ=(0.,0.)
!
      CALL ONE_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,   &
                          BLMIN,CS_TYPE,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,     &
                          ZOBG,NZSR,ZSRG,NZBG,ZBG,ALMAX,GRHF,RRG,NRG,GRHO0)
!
      DO IEXCI=1,NTXE
!
!-- Determine the orientation of the magnetic dipoles
!
!   Array ANGLES is used in internal subroutines
!
       IF (SOURCE_TYPE==3) THEN
          ANGLES(1)=MD_ANGLE(1,IEXCI)
          ANGLES(2)=MD_ANGLE(2,IEXCI)
          NCRDI=1
       ELSE
          NCRDI=N_VRTX(IEXCI)
       END IF

       IF (CS_TYPE==3.AND.NCRDI>2) THEN
         DO I_TYPE3=1,NCRDI-1
            TX_CRDXI(1)=TX_CRDX(I_TYPE3,IEXCI)
            TX_CRDYI(1)=TX_CRDY(I_TYPE3,IEXCI)
            TX_CRDZI(1)=TX_CRDZ(I_TYPE3,IEXCI)
            TX_CRDXI(2)=TX_CRDX(I_TYPE3+1,IEXCI)
            TX_CRDYI(2)=TX_CRDY(I_TYPE3+1,IEXCI)
            TX_CRDZI(2)=TX_CRDZ(I_TYPE3+1,IEXCI)

!
         DO II=1,N_RX(IEXCI)
!
            IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!       --     Note that receiver bipoles have been divided into sub-sections
!
               LX=RX_X(2,II,IEXCI)-RX_X(1,II,IEXCI)
               LY=RX_Y(2,II,IEXCI)-RX_Y(1,II,IEXCI)
               LZ=RX_Z(2,II,IEXCI)-RX_Z(1,II,IEXCI)
!
            END IF
!
            IF (E_ONLY==1) THEN
               NSUB_RX1=1
            ELSE
               NSUB_RX1=N_SUB_RX(II,IEXCI)
            END IF
!
            DO K=1,NSUB_RX1
!
               RECVR(1)=REAL(RX_X(K,II,IEXCI))
               RECVR(2)=REAL(RX_Y(K,II,IEXCI))
               RECVR(3)=REAL(RX_Z(K,II,IEXCI))
!
!  *** It is advantageous to integrate receiver bipoles here and to integrate
!      transmitters in routine one_d_source so that 3D computations can use
!      one_d_source since 3D do not integrate over receivers.
!
               CALL ONE_D_SOURCE(CS_TYPE,ANGLES,RECVR,NCRDI,TX_CRDXI,TX_CRDYI, &
                                 TX_CRDZI,RADI,KEYG,KACC,FRQ,MLAYER,ZBND,AJ,   &
                                 KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,    &
                                 RRG,NRG,GRHF,GRHO0,EHFLD)

               IF (E_ONLY==1) THEN
!
!    --        Compute electric components only
                  ENX(II,IEXCI)=ENX(II,IEXCI)+EX
                  ENY(II,IEXCI)=ENY(II,IEXCI)+EY
                  ENZ(II,IEXCI)=ENZ(II,IEXCI)+EZ
!
               ELSE IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!    --  Integrations along the receiver lines are similar to routines ONE_D_SOURCE
!        and ONE_D_LINE except for vertical lines.
!
!        Trapezoidal rule is used for simplicity
!
                  IF (K==1.or.K==NSUB_RX1) THEN
                     C_INT=.5
                  ELSE
                     C_INT=1.
                  END IF
                  IF (ABS(LX)>=ABS(LY).AND.ABS(LX)>=ABS(LZ)) THEN
!          --        Integrate along X
                     VLT1D(II,IEXCI)=VLT1D(II,IEXCI)+(EX+EY*LY/LX+EZ*LZ/LX)*C_INT*LX
                  ELSE IF (ABS(LY)>=ABS(LX).AND.ABS(LY)>=ABS(LZ)) THEN
!          --        Integrate along Y.
!                    Note that integration along Z is done
!                    analytically for strictly vertical receiver lines
                     VLT1D(II,IEXCI)=VLT1D(II,IEXCI)+(EY+EX*LX/LY+EZ*LZ/LY)*C_INT*LY
                  ELSE
!          --        Integrate along Z.
!                    Note that integration along Z is done for receiver positions.
!                    This is different from routines ONE_D_SOURCE and ONE_D_LINE where
!                    strictly vertical transmitter lines are integrated analytically
!                    in the Hankel kernels.
                     VLT1D(II,IEXCI)=VLT1D(II,IEXCI)+(EZ+EX*LX/LZ+EY*LY/LZ)*C_INT*LZ
                  END IF
!
               ELSE IF (RX_TYPE_INDEX(II,IEXCI)==2) THEN
!
!          --     Integrate loop receivers that are converted to magnetic dipole receivers
!
                  HNX(II,IEXCI)=HNX(II,IEXCI)+HX*RX_WEIGHT(1,K,II,IEXCI)
                  HNY(II,IEXCI)=HNY(II,IEXCI)+HY*RX_WEIGHT(2,K,II,IEXCI)
                  HNZ(II,IEXCI)=HNZ(II,IEXCI)+HZ*RX_WEIGHT(3,K,II,IEXCI)
!
!  --- Convert H to B (single component)
!
!     -- Receiver layer
                  DO J=MLAYER-1,0,-1
                     IF (RECVR(3)>=ZBND(J)) THEN
                        NOB=J+1
                        GOTO 40
                     END IF
                  END DO
                  NOB=0
               40 CONTINUE
                  IF (NOB==0) THEN
                     RMU=1.
                  ELSE
                     RMU=RMU_LYR(NOB)
                  END IF
!
                  RMU=RMU*4.*3.1415926E-7
                  VLT1D(II,IEXCI)=(HNX(II,IEXCI)+HNY(II,IEXCI)+HNZ(II,IEXCI))*RMU
!
               ELSE
!
!          --     Magnetic dipole receivers (only one sub-receiver)
!                 Electric components are also computed thought they are not used.
!
!                 Electric field may not be used in this particular version
                  ENX(II,IEXCI)=ENX(II,IEXCI)+EX
                  ENY(II,IEXCI)=ENY(II,IEXCI)+EY
                  ENZ(II,IEXCI)=ENZ(II,IEXCI)+EZ
!
!  --- Convert H to B
!
!     -- Receiver layer
                  DO J=MLAYER-1,0,-1
                     IF (RECVR(3)>=ZBND(J)) THEN
                        NOB=J+1
                        GOTO 42
                     END IF
                  END DO
                  NOB=0
               42 CONTINUE
                  IF (NOB==0) THEN
                     RMU=1.
                  ELSE
                     RMU=RMU_LYR(NOB)
                  END IF
                  RMU=RMU*4.*3.1415926E-7
                  HNX(II,IEXCI)=HNX(II,IEXCI)+HX*RMU
                  HNY(II,IEXCI)=HNY(II,IEXCI)+HY*RMU
                  HNZ(II,IEXCI)=HNZ(II,IEXCI)+HZ*RMU
!
               END IF
!
            END DO
!
         END DO

         END DO

!*************
       ELSE
!*************

            DO I=1,NCRDI
               TX_CRDXI(I)=TX_CRDX(I,IEXCI)
               TX_CRDYI(I)=TX_CRDY(I,IEXCI)
               TX_CRDZI(I)=TX_CRDZ(I,IEXCI)
            END DO


!
         DO II=1,N_RX(IEXCI)
!
            IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!       --     Note that receiver bipoles have been divided into sub-sections
!
               LX=RX_X(2,II,IEXCI)-RX_X(1,II,IEXCI)
               LY=RX_Y(2,II,IEXCI)-RX_Y(1,II,IEXCI)
               LZ=RX_Z(2,II,IEXCI)-RX_Z(1,II,IEXCI)
!
            END IF
!
            IF (E_ONLY==1) THEN
               NSUB_RX1=1
            ELSE
               NSUB_RX1=N_SUB_RX(II,IEXCI)
            END IF
!
            DO K=1,NSUB_RX1
!
               RECVR(1)=REAL(RX_X(K,II,IEXCI))
               RECVR(2)=REAL(RX_Y(K,II,IEXCI))
               RECVR(3)=REAL(RX_Z(K,II,IEXCI))
!
!  *** It is advantageous to integrate receiver bipoles here and to integrate
!      transmitters in routine one_d_source so that 3D computations can use
!      one_d_source since 3D do not integrate over receivers.
!
               CALL ONE_D_SOURCE(CS_TYPE,ANGLES,RECVR,NCRDI,TX_CRDXI,TX_CRDYI, &
                                 TX_CRDZI,RADI,KEYG,KACC,FRQ,MLAYER,ZBND,AJ,   &
                                 KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,    &
                                 RRG,NRG,GRHF,GRHO0,EHFLD)
!
               IF (E_ONLY==1) THEN
!
!    --        Compute electric components only
                  ENX(II,IEXCI)=ENX(II,IEXCI)+EX
                  ENY(II,IEXCI)=ENY(II,IEXCI)+EY
                  ENZ(II,IEXCI)=ENZ(II,IEXCI)+EZ
!
               ELSE IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!    --  Integrations along the receiver lines are similar to routines ONE_D_SOURCE
!        and ONE_D_LINE except for vertical lines.
!
!        Trapezoidal rule is used for simplicity
!
                  IF (K==1.or.K==NSUB_RX1) THEN
                     C_INT=.5
                  ELSE
                     C_INT=1.
                  END IF
                  IF (ABS(LX)>=ABS(LY).AND.ABS(LX)>=ABS(LZ)) THEN
!          --        Integrate along X
                     VLT1D(II,IEXCI)=VLT1D(II,IEXCI)+(EX+EY*LY/LX+EZ*LZ/LX)*C_INT*LX
                  ELSE IF (ABS(LY)>=ABS(LX).AND.ABS(LY)>=ABS(LZ)) THEN
!          --        Integrate along Y.
!                    Note that integration along Z is done
!                    analytically for strictly vertical receiver lines
                     VLT1D(II,IEXCI)=VLT1D(II,IEXCI)+(EY+EX*LX/LY+EZ*LZ/LY)*C_INT*LY
                  ELSE
!          --        Integrate along Z.
!                    Note that integration along Z is done for receiver positions.
!                    This is different from routines ONE_D_SOURCE and ONE_D_LINE where
!                    strictly vertical transmitter lines are integrated analytically
!                    in the Hankel kernels.
                     VLT1D(II,IEXCI)=VLT1D(II,IEXCI)+(EZ+EX*LX/LZ+EY*LY/LZ)*C_INT*LZ
                  END IF
!
               ELSE IF (RX_TYPE_INDEX(II,IEXCI)==2) THEN
!
!          --     Integrate loop receivers that are converted to magnetic dipole receivers
!
                  HNX(II,IEXCI)=HNX(II,IEXCI)+HX*RX_WEIGHT(1,K,II,IEXCI)
                  HNY(II,IEXCI)=HNY(II,IEXCI)+HY*RX_WEIGHT(2,K,II,IEXCI)
                  HNZ(II,IEXCI)=HNZ(II,IEXCI)+HZ*RX_WEIGHT(3,K,II,IEXCI)
!
!  --- Convert H to B (single component)
!
!     -- Receiver layer
                  DO J=MLAYER-1,0,-1
                     IF (RECVR(3)>=ZBND(J)) THEN
                        NOB=J+1
                        GOTO 50
                     END IF
                  END DO
                  NOB=0
               50 CONTINUE
                  IF (NOB==0) THEN
                     RMU=1.
                  ELSE
                     RMU=RMU_LYR(NOB)
                  END IF
!
                  RMU=RMU*4.*3.1415926E-7
                  VLT1D(II,IEXCI)=(HNX(II,IEXCI)+HNY(II,IEXCI)+HNZ(II,IEXCI))*RMU
!
               ELSE
!
!          --     Magnetic dipole receivers (only one sub-receiver)
!                 Electric components are also computed thought they are not used.
!
!                 Electric field may not be used in this particular version
                  ENX(II,IEXCI)=ENX(II,IEXCI)+EX
                  ENY(II,IEXCI)=ENY(II,IEXCI)+EY
                  ENZ(II,IEXCI)=ENZ(II,IEXCI)+EZ
!
!  --- Convert H to B
!
!     -- Receiver layer
                  DO J=MLAYER-1,0,-1
                     IF (RECVR(3)>=ZBND(J)) THEN
                        NOB=J+1
                        GOTO 52
                     END IF
                  END DO
                  NOB=0
               52 CONTINUE
                  IF (NOB==0) THEN
                     RMU=1.
                  ELSE
                     RMU=RMU_LYR(NOB)
                  END IF
                  RMU=RMU*4.*3.1415926E-7
                  HNX(II,IEXCI)=HNX(II,IEXCI)+HX*RMU
                  HNY(II,IEXCI)=HNY(II,IEXCI)+HY*RMU
                  HNZ(II,IEXCI)=HNZ(II,IEXCI)+HZ*RMU
!
               END IF
!
            END DO
!

         END DO

       ENDIF
      END DO
!
      RETURN
      END
!
!**** End of MAIN_PRM_AT_RCV
!
      SUBROUTINE MAIN_SCAT_EH_CS(SUB_RX_MAX,RX_TYPE_INDEX,                        &
                                 HIGH_FRQ,KACC,KSYMM,MBODY,NBMAX,                 &
                                 NSUBCM,NBODY,SUB_BLOCK,NCELL,NET,TCDB,EMT,       &
                                 JST,EJGS,NMAX,NTXE,N_RX,N_SUB_RX,RX_WEIGHT,      &
                                 NHFILM,FRQ,MLAYER,                               &
                                 ZBND,LRYTH,HVK,KKH,RMU_LYR,                      &
                                 KANIS,BLMIN,DMIN,RHOMIN,                         &
                                 RHOMAX,NZOB,ZOBG,NZSR,ZSRG,ALMAX,RRG,RRG3,       &
                                 GRHF,GRHF3,GRHO0,GRHO03,RX_X,RX_Y,RX_Z,          &
                                 NXMAX,NYMAX,NZMAX,NEQ,NX,NY,NZ,XCELL,YCELL,      &
                                 ZCELL,BLX,BLY,BLZ,CDH,CDV,KSFT,CLMN,M_RX,        &
                                 ENX,ENY,ENZ,EAX,EAY,EAZ,HAX,HAY,HAZ,             &
                                 VLT3D,ESX,ESY,ESZ,HSX,HSY,HSZ)
!
!**** Calculate EM fields at receiver sites
!
!
!   EAX etc are for one excitation whilst ESX are for all excitations
!
!  *** Note that output HNX etc for magnetic dipoles are in fact components of B.
!
      IMPLICIT NONE
!
      REAL ALMAX,BLMIN,DMIN,FRQ,RHOMAX,RHOMIN
      INTEGER I,IB,IEXCI,J,KACC,KACC1,KANIS,HIGH_FRQ,KEYG,KSFT,   &
              KSYMM,MBODY,MLAYER,M_RX,NBMAX,NBODY,NEQ,NHFILM
      INTEGER NMAX,NRG,NRG3,NSUBCM,NTXE,NXMAX,NYMAX,NZMAX,NZOB,NZSR
      COMPLEX EMT(NMAX),JST(NMAX,MBODY),EJGS(4*NMAX*MBODY),                &
              TCDB(NSUBCM,NBMAX,MBODY),GRHF(11,NHFILM,NZSR,NZOB),          &
              GRHF3(11,NHFILM,NZSR),GRHO0(4,NZSR,NZOB),GRHO03(4,NZSR),     &
              KKH(0:MLAYER),CDH(0:MLAYER),CDV(0:MLAYER),                   &
              EAX(M_RX),EAY(M_RX),EAZ(M_RX),                               &
              HAX(M_RX),HAY(M_RX),HAZ(M_RX),                               &
              ENX(M_RX,NTXE),ENY(M_RX,NTXE),ENZ(M_RX,NTXE),          &
              ESX(M_RX,NTXE),ESY(M_RX,NTXE),ESZ(M_RX,NTXE),          &
              HSX(M_RX,NTXE),HSY(M_RX,NTXE),HSZ(M_RX,NTXE)
      COMPLEX, INTENT(OUT) :: VLT3D(M_RX,NTXE)
      REAL ZOBG(NZOB),ZSRG(2,NZSR),RRG(NHFILM),RRG3(NHFILM),               &
           LRYTH(MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER),RMU_LYR(MLAYER)
      REAL BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),             &
           XCELL(NXMAX,NBMAX,MBODY),YCELL(NYMAX,NBMAX,MBODY),              &
           ZCELL(NZMAX,NBMAX,MBODY)
      INTEGER, INTENT(IN) :: SUB_RX_MAX,RX_TYPE_INDEX(M_RX,NTXE)
      REAL, INTENT(IN) :: RX_X(SUB_RX_MAX,M_RX,NTXE),                 &
                          RX_Y(SUB_RX_MAX,M_RX,NTXE),                 &
                          RX_Z(SUB_RX_MAX,M_RX,NTXE),                 &
                          RX_WEIGHT(3,SUB_RX_MAX,M_RX,NTXE)
      INTEGER N_RX(NTXE),N_SUB_RX(M_RX,NTXE)
      INTEGER NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY),             &
              NCELL(NBMAX,MBODY),NET(MBODY),SUB_BLOCK(MBODY)
      REAL CLMN(NBODY)
      INTEGER, PARAMETER :: KCLMN=0  ! always use automatic choice of clmn
!
      COMPLEX, ALLOCATABLE :: VLT(:)
!
      ALLOCATE (VLT(M_RX))
!
! --- Initialise VLT3D etc because some of their element will not be computed
!     (M_RX vs actual receivers per transmitter) but may be accessed in the
!     calling routine that run through all indexes.
!
      VLT3D=(0.,0.)
      ESX=(0.,0.)
      ESY=(0.,0.)
      ESZ=(0.,0.)
      HSX=(0.,0.)
      HSY=(0.,0.)
      HSZ=(0.,0.)
!
! --- Reduce the accuracy level for computing scattered responses
!   to 3 if it is above 3.  High accuracy levels are necessary
!   for accurate computation of the matrix elements which are
!   also affordable if spatial symmetry reductions are used.
!
      IF (KACC>3) THEN
         KACC1=3
      ELSE
         KACC1=KACC
      END IF
!
! ---- Compute the grid values for the interpolation of the
!    Hankel transforms
!
      KEYG=2
!
      CALL THR_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,   &
                          KSFT,BLMIN,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,ZOBG,   &
                          NZSR,ZSRG,ALMAX,RRG,NRG,RRG3,NRG3,GRHF,GRHF3,   &
                          GRHO0,GRHO03)
!
!--- Read the array TCDB for use in computing the electrical
!    fields at receivers on or within a cell
!
      REWIND (62)
!
! --- Read cell conductivity from file CONDT (unit 62)
!
      DO IB=1,NBODY
         READ (62) ((TCDB(J,I,IB),J=1,NCELL(I,IB)),I=1,SUB_BLOCK(IB))
      END DO
!
      REWIND (62)
!
      DO IEXCI=1,NTXE
!
! ---- Read jst from unit 20 for multiple excitations
!    or ejgs from 20 for controlled source problems
!    with two-plane symmetries (group reduction)
!
         IF (NTXE>1.AND.KSYMM==0) THEN
            DO IB=1,NBODY
               READ (20) (EMT(I),I=1,NET(IB))
               DO J=1,NET(IB)
                  JST(J,IB)=EMT(J)
               END DO
            END DO
         END IF
!
         IF (KSYMM==1) READ (20) (EJGS(I),I=1,4*NEQ)
!
!-- For loop-loop configurations only one receiver per excitation
!
         IF (KSYMM==0) CALL SCAT_EH_CS(SUB_RX_MAX,RX_TYPE_INDEX,             &
                               N_SUB_RX,RX_WEIGHT,NBMAX,NMAX,NXMAX,NYMAX,    &
                               NZMAX,NBODY,SUB_BLOCK,N_RX,RX_X,RX_Y,RX_Z,    &
                               NX,NY,NZ,NCELL,XCELL,YCELL,ZCELL,BLX,BLY,     &
                               BLZ,JST,NSUBCM,TCDB,IEXCI,CLMN,M_RX,NTXE,     &
                               VLT,ENX,ENY,ENZ,EAX,EAY,EAZ,HAX,HAY,HAZ,      &
                               FRQ,MLAYER,ZBND,CDH,CDV,HVK,                  &
                               RMU_LYR,NZOB,ZOBG,NZSR,                       &
                               ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,    &
                               NRG3,GRHF3,GRHO0,GRHO03,KCLMN,BLMIN,KACC1)
         IF (KSYMM==1) CALL SCAT_EH_CSGS(SUB_RX_MAX,RX_TYPE_INDEX,            &
                               N_SUB_RX,RX_WEIGHT,NBMAX,NEQ,NXMAX,NYMAX,      &
                               NZMAX,NBODY,SUB_BLOCK,NET,N_RX,RX_X,RX_Y,RX_Z, &
                               NX,NY,NZ,NCELL,XCELL,YCELL,ZCELL,BLX,BLY,BLZ,  &
                               EJGS,NSUBCM,TCDB,IEXCI,CLMN,M_RX,NTXE,VLT,     &
                               ENX,ENY,ENZ,EAX,EAY,EAZ,HAX,HAY,HAZ,FRQ,       &
                               MLAYER,ZBND,CDH,CDV,HVK,RMU_LYR,               &
                               NZOB,ZOBG,NZSR,ZSRG,                           &
                               RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,NRG3,     &
                               GRHF3,GRHO0,GRHO03,KCLMN,BLMIN,KACC1)
!
         DO I=1,N_RX(IEXCI)
            VLT3D(I,IEXCI)=VLT(I)
            ESX(I,IEXCI)=EAX(I)
            ESY(I,IEXCI)=EAY(I)
            ESZ(I,IEXCI)=EAZ(I)
            HSX(I,IEXCI)=HAX(I)
            HSY(I,IEXCI)=HAY(I)
            HSZ(I,IEXCI)=HAZ(I)
         END DO
!
      END DO
!
      DEALLOCATE (VLT)
!
      RETURN
      END
!
!**** End of MAIN_SCAT_EH_CS
!
!
!
      SUBROUTINE MAIN_SCAT_EH_MT(HIGH_FRQ,KACC,KSYMM,MBODY,NBMAX,NSUBCM,  &
                                 NBODY,SUB_BLOCK,NCELL,TCDB,JST,NMAX,NHFILM, &
                                 FRQ,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,BLMIN,  &
                                 DMIN,RHOMIN,RHOMAX,NZOB,ZOBG,NZSR,ZSRG,     &
                                 ALMAX,RRG,RRG3,GRHF,GRHF3,GRHO0,GRHO03,     &
                                 MT_PROFL,MT_STATN,XRMT,YRMT,NXMAX,NYMAX,    &
                                 NZMAX,NX,NY,NZ,XCELL,YCELL,ZCELL,BLX,BLY,   &
                                 BLZ,CDH,NPOL,E0X1,E0Y1,ZMT,KSFT,CLMN,       &
                                 EXMT,EYMT,HXMT,HYMT,HZMT)
!
!**** Calculate EM fields at receiver sites
!
!
!   NPOL,E0X1,E0Y1,ZMT are to be passed into routines SCAT_EH_MT
!   and SCAT_EH_MTS
!
!
!   EAX etc are for one excitation whilst EXMT are for all excitations
!
!
      IMPLICIT NONE
!
      REAL ALMAX,BLMIN,DMIN,FRQ,RHOMAX,RHOMIN,ZMT
      INTEGER I,IB,J,KACC,KACC1,KANIS,KCLMN,HIGH_FRQ,KEYG,KSFT,KSYMM,     &
              MBODY,MLAYER,NBMAX,NBODY,NHFILM,NMAX,MT_PROFL
      INTEGER NPOL,MT_STATN,NRG,NRG3,NSUBCM,NXMAX,NYMAX,NZMAX,NZOB,NZSR
      COMPLEX JST(NMAX,MBODY),TCDB(NSUBCM,NBMAX,MBODY),E0X1,E0Y1,            &
              GRHF(11,NHFILM,NZSR,NZOB),GRHF3(11,NHFILM,NZSR),               &
              GRHO0(4,NZSR,NZOB),GRHO03(4,NZSR),                             &
              KKH(0:MLAYER),CDH(0:MLAYER),                                   &
              EXMT(MT_PROFL,MT_STATN,2),EYMT(MT_PROFL,MT_STATN,2),           &
              HXMT(MT_PROFL,MT_STATN,2),HYMT(MT_PROFL,MT_STATN,2),           &
              HZMT(MT_PROFL,MT_STATN,2)
      REAL ZOBG(NZOB),ZSRG(2,NZSR),RRG(NHFILM),RRG3(NHFILM),                 &
           LRYTH(MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER)
      REAL BLX(NBMAX,MBODY),BLY(NBMAX,MBODY),BLZ(NBMAX,MBODY),               &
           XCELL(NXMAX,NBMAX,MBODY),YCELL(NYMAX,NBMAX,MBODY),                &
           ZCELL(NZMAX,NBMAX,MBODY)
      REAL XRMT(MT_PROFL),YRMT(MT_STATN)
      INTEGER NX(NBMAX,MBODY),NY(NBMAX,MBODY),NZ(NBMAX,MBODY),               &
              NCELL(NBMAX,MBODY),SUB_BLOCK(MBODY)
      REAL CLMN(NBODY)
!
! --- Reduce the accuracy level for computing scattered responses
!   to 3 if it is above 3.  High accuracy levels are necessary
!   for accurate computation of the matrix elements which are
!   also affordable if spatial symmetry reductions are used.
!
      IF (KACC>3) THEN
         KACC1=3
      ELSE
         KACC1=KACC
      END IF
!
! ---- Compute the grid values for the interpolation of the
!    Hankel transforms
!
      KEYG=2
!
      CALL THR_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,   &
                          KSFT,BLMIN,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,ZOBG,   &
                          NZSR,ZSRG,ALMAX,RRG,NRG,RRG3,NRG3,GRHF,GRHF3,   &
                          GRHO0,GRHO03)
!
!--- Read the array TCDB for use in computing the electrical
!    fields at receivers on or within a cell
!
      REWIND (62)
!
! --- Read cell conductivity from file CONDT (unit 62)
!
      DO IB=1,NBODY
         READ (62) ((TCDB(J,I,IB),J=1,NCELL(I,IB)),I=1,SUB_BLOCK(IB))
      END DO
!
      REWIND (62)
!
! ---- Compute MT responses
!
      IF (KSYMM==0) CALL SCAT_EH_MT(NBMAX,NMAX,NXMAX,NYMAX,NZMAX,NBODY,      &
                         SUB_BLOCK,MT_PROFL,MT_STATN,XRMT,YRMT,NX,NY,NZ,     &
                         NCELL,XCELL,YCELL,ZCELL,BLX,BLY,BLZ,JST,NPOL,KSFT,  &
                         NSUBCM,TCDB,CLMN,ZMT,E0X1,E0Y1,EXMT,EYMT,HXMT,HYMT, &
                         HZMT,FRQ,MLAYER,ZBND,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,   &
                         RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,NRG3,          &
                         GRHF3,GRHO0,GRHO03,KCLMN,BLMIN,KACC1)
      IF (KSYMM==1) CALL SCAT_EH_MTS(NBMAX,NMAX,NXMAX,NYMAX,NZMAX,NBODY,     &
                         SUB_BLOCK,MT_PROFL,MT_STATN,XRMT,YRMT,NX,NY,NZ,     &
                         NCELL,XCELL,YCELL,ZCELL,BLX,BLY,BLZ,JST,NPOL,KSFT,  &
                         NSUBCM,TCDB,CLMN,ZMT,E0X1,E0Y1,EXMT,EYMT,HXMT,HYMT, &
                         HZMT,FRQ,MLAYER,ZBND,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,   &
                         RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,    &
                         GRHO0,GRHO03,KCLMN,BLMIN,KACC1)
!
      RETURN
      END
!
!**** End of MAIN_SCAT_EH_MT
!
!
      SUBROUTINE MTRX_1M(NMAX,N,NXMAX,NYMAX,NZMAX,NX,NY,NZ,NCELL,    &
                         NSUBCM,SUB_BLOCK,X,Y,Z,CLX,CLY,CLZ,CDB,G,   &
                         FRQ,MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,      &
                         NZSR,ZSRG,RHOMIN,DMIN,NHFILM,RRG,           &
                         NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,      &
                         CLMN,KCLMN,BLMIN,KACC,KUTCRP)
!
!**** SET UP THE MATRIX FOR A STRUCTURE WITH DIFFERENT CELL
!   SIZES OR A STRUCTURE EMBBEDED IN AN ANISOTROPIC LAYER
!   WITH THE BODY CROSSING A LAYER BOUNDARY
!
!   Note the matrix is not symmetrical
!
!   The difference between smtrx1 (in MT3D) and smtrx1m is
!   that the matrix elements in smtrx1 are multiplied by the
!   conductivity differences
!
!   The parameter kself controls if the computation for the
!   integration of the primary part of the Green's function
!   for self-cells should be repeated. As the dimensions of
!   the cells within a block is the same, this integration
!   need to be done only once (kself=1) for cells located in
!   the same layer.   The results are stored in a common
!   block in geprm for use for all other cells in this block
!   (kself=0)
!
!Input parameters:
!
!
!
!  All other parameters FRQ, MLAYER, ZBND,  CDH, HVK, NZOB, ZOBG,
!  NZSR, ZSRG, RHOMIN, DMIN, NHFILM, RRG, NRG, GRHF,
!  GRHF3, GRHO0, GRHO03, CLMN, KCLMN, BLMIN, KACC, and KUTCRP are to
!  be passed into routine THR_D_GREEN.  Check THR_D_GREEN for their
!  descriptions.
!
!
!Output parameters:
!
!  G:
!
!
!**** Called by: MAIN_MATRICES
!
!**** Calls:     THR_D_GREEN
!
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN
      INTEGER I,II,IOB,ISR,J,JJ,K,KACC,KCLMN,KEYG,KK,KSELF,KUTCRP,L,LL,   &
              MLAYER,N,N1,N2,SUB_BLOCK
      INTEGER NCB,NCB1,NHFILM,NMAX,NN,NN1,NN2,NOB,NOB1,NRG,NRG3,NSR,      &
              NSUBCM,NXMAX,NYMAX,NZMAX,NZOB,NZSR
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,              &
              CDH(0:MLAYER),CDV(0:MLAYER),                                &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV,                          &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),               &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),     &
            CLX(SUB_BLOCK),CLY(SUB_BLOCK),CLZ(SUB_BLOCK),                 &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),                      &
            ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (Z(K,L)>=ZBND(IOB)) THEN
                  NOB=IOB+1
                  GOTO 20
               END IF
            END DO
            NOB=0
   20       IF (L==1.AND.K==1) NOB1=NOB
            DO I=1,NX(L)
               DO J=1,NY(L)
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  DELTH=CDB(NN,L)-CDH(NOB)
                  DELTV=CDB(NN,L)-CDV(NOB)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK
                     IF (LL>1) NCB1=NCB1+NCELL(LL-1)
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           DO KK=1,NZ(LL)
                              N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)   &
                                 +KK+NCB1
                              NN2=(N2-1)*3+1
!
                              DO ISR=MLAYER-1,0,-1
                              IF (Z(KK,LL)>=ZBND(ISR)) THEN
                              NSR=ISR+1
                              GOTO 22
                              END IF
                              END DO
                              NSR=0
!
! ---- KSELF controls if the calculation for the self-cells
!    should be repeated
   22                         IF (I==1.AND.J==1.AND.K==1.OR.  &
                                 NOB1/=NOB.OR.NOB1/=NSR) THEN
                              KSELF=1
                              ELSE
                              KSELF=0
                              END IF
!
                              CLX1=CLX(LL)
                              CLY1=CLY(LL)
                              CLZ1=CLZ(LL)
!
                              PSTION(1)=X(I,L)
                              PSTION(2)=Y(J,L)
                              PSTION(3)=Z(K,L)
                              PSTION(4)=X(II,LL)
                              PSTION(5)=Y(JJ,LL)
                              PSTION(6)=Z(KK,LL)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX1,CLY1,CLZ1,     &
                                 CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                                 ECOMP,HCOMP)
!
                              IF (N1==N2) THEN
                              G(NN1,NN2)=1./DELTH-EXX
                              G(NN1+1,NN2+1)=1./DELTH-EYY
                              G(NN1+2,NN2+2)=1./DELTV-EZZ
                              ELSE
                              G(NN1,NN2)=-EXX
                              G(NN1+1,NN2+1)=-EYY
                              G(NN1+2,NN2+2)=-EZZ
                              END IF
                              G(NN1+1,NN2)=-EYX
                              G(NN1+2,NN2)=-EZX
                              G(NN1,NN2+1)=-EXY
                              G(NN1+2,NN2+1)=-EZY
                              G(NN1,NN2+2)=-EXZ
                              G(NN1+1,NN2+2)=-EYZ
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
      RETURN
      END
!
!**** End of MTRX_1M
!
!
      SUBROUTINE MTRX_1MS(NMAX,N,NXMAX,NYMAX,NZMAX,NX,NY,NZ,NCELL,    &
                          NSUBCM,SUB_BLOCK,X,Y,Z,CLX,CLY,CLZ,CDB,G,   &
                          FRQ,MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,      &
                          NZSR,ZSRG,RHOMIN,DMIN,NHFILM,               &
                          RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,  &
                          CLMN,KCLMN,BLMIN,KACC,KUTCRP)
!
!**** SET UP THE MATRIX FOR A STRUCTURE WITH EQUAL CELL
!   SIZES FOR A STRUCTURE EMBBEDED IN AN ISOPTROPIC EARTN
!   OR IN A SINGLE LAYER OF AN ANISOTROPIC EARTH
!
!   Note the matrix is symmetrical and is stored in a doubly
!   subscripted array
!
!   smtrx1ms is essentially the same as smtrx1m except
!   that smtrx1ms save a half computer time due to symmetry.
!   smtrx1ms and smtrx differ only in their way of storing
!   the matrices
!
!
!Input parameters:
!
!
!
!  All other parameters FRQ, MLAYER, ZBND,  CDH, HVK, NZOB, ZOBG,
!  NZSR, ZSRG, RHOMIN, DMIN, NHFILM, RRG, NRG, GRHF,
!  GRHF3, GRHO0, GRHO03, CLMN, KCLMN, BLMIN, KACC, and KUTCRP are to
!  be passed into routine THR_D_GREEN.  Check THR_D_GREEN for their
!  descriptions.
!
!
!Output parameters:
!
!  G:
!
!
!**** Called by: MAIN_MATRICES
!
!**** Calls:     THR_D_GREEN
!
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN
      INTEGER I,II,IOB,ISR,J,JJ,K,KACC,KCLMN,KEYG,KK,KSELF,KUTCRP,L,LL,   &
              MLAYER,N,N1,N2,SUB_BLOCK
      INTEGER NCB,NCB1,NHFILM,NMAX,NN,NN1,NN2,NOB,NOB1,NRG,NRG3,NSR,      &
              NSUBCM,NXMAX,NYMAX,NZMAX,NZOB,NZSR
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,              &
              CDH(0:MLAYER),CDV(0:MLAYER),                                &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV,                          &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),               &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),     &
            CLX(SUB_BLOCK),CLY(SUB_BLOCK),CLZ(SUB_BLOCK),                 &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),                      &
            ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (Z(K,L)>=ZBND(IOB)) THEN
                  NOB=IOB+1
                  GOTO 20
               END IF
            END DO
            NOB=0
   20       IF (L==1.AND.K==1) NOB1=NOB
            DO I=1,NX(L)
               DO J=1,NY(L)
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  DELTH=CDB(NN,L)-CDH(NOB)
                  DELTV=CDB(NN,L)-CDV(NOB)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK
                     IF (LL>1) NCB1=NCB1+NCELL(LL-1)
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           DO KK=1,NZ(LL)
                              N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)   &
                                 +KK+NCB1
                              NN2=(N2-1)*3+1
!
                              IF (N1<=N2) THEN
!
                              DO ISR=MLAYER-1,0,-1
                              IF (Z(KK,LL)>=ZBND(ISR)) THEN
                              NSR=ISR+1
                              GOTO 22
                              END IF
                              END DO
                              NSR=0
!
! ---- KSELF controls if the calculation for the self-cells
!    should be repeated
   22                         IF (I==1.AND.J==1.AND.K==1.OR.  &
                                 NOB1/=NOB.OR.NOB1/=NSR) THEN
                              KSELF=1
                              ELSE
                              KSELF=0
                              END IF
!
                              CLX1=CLX(LL)
                              CLY1=CLY(LL)
                              CLZ1=CLZ(LL)
!
                              PSTION(1)=X(I,L)
                              PSTION(2)=Y(J,L)
                              PSTION(3)=Z(K,L)
                              PSTION(4)=X(II,LL)
                              PSTION(5)=Y(JJ,LL)
                              PSTION(6)=Z(KK,LL)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX1,CLY1,CLZ1,     &
                                 CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                                 ECOMP,HCOMP)
!
                              IF (N1==N2) THEN
                              G(NN1,NN2)=1./DELTH-EXX
                              G(NN1+1,NN2+1)=1./DELTH-EYY
                              G(NN1+2,NN2+2)=1./DELTV-EZZ
                              ELSE
                              G(NN1,NN2)=-EXX
                              G(NN1+1,NN2+1)=-EYY
                              G(NN1+2,NN2+2)=-EZZ
                              END IF
                              G(NN1+1,NN2)=-EYX
                              G(NN1+2,NN2)=-EZX
                              G(NN1,NN2+1)=-EXY
                              G(NN1+2,NN2+1)=-EZY
                              G(NN1,NN2+2)=-EXZ
                              G(NN1+1,NN2+2)=-EYZ
                              END IF
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
      DO I=1,N
         DO J=1,N
            IF (I>J) G(I,J)=G(J,I)
         END DO
      END DO
      RETURN
      END
!
!**** End of MTRX_1MS
!
!
      SUBROUTINE MTRX_3M(NMAX,N,NXMAX,NYMAX,NZMAX,NX,NY,NZ,NCELL,         &
                         NSUBCM,SUB_BLOCK,X,Y,Z,CLX,CLY,CLZ,CDB,KSYM,G,   &
                         FRQ,MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,NZSR,      &
                         ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,            &
                         RRG3,NRG3,GRHF3,GRHO0,GRHO03,CLMN,KCLMN,         &
                         BLMIN,KACC,KUTCRP)
!
!     SETTING UP THE MATRIX FOR A SYMMETRIC STRUCTURE WITH
!     DIFFERENT CELL SIZES OR FOR SYMMETRIC BODY EMBBEDED IN
!     AN ANISOTROPIC LAYER WITH THE BODY CROSSING A LAYER BOUNDARY
!
!      Note the matrix is not symmetrical
!
!      The differences between smtrx3 (in MT3D) and smtrx3m
!      are like those between smtrx1 amd smtrx1m
!
!      Note that only two quarters, either quarter I and IV
!      or quarter II and III, are computed at a time, which is
!      controled by the parameter KSYM (=1 or 2). The actual
!      scattering matrix is then formed in the main routine
!      by addition or substraction of the results of KSYM=1
!      and 2 according to the polarizations.
!
!
      IMPLICIT NONE
!
      REAL BLMIN,BX,BY,CLMN,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN,SX,SY,SZ
      INTEGER I,II,IOB,ISR,J,JJ,K,KACC,KCLMN,KEYG,KK,KSELF,KSYM,KUTCRP,    &
              L,LL,LS1,LS2,LS3,LSYM
      INTEGER MLAYER,N,N1,N2,SUB_BLOCK,NCB,NCB1,NHFILM,NMAX,NN,NN1,NN2,    &
              NOB,NOB1,NRG,NRG3,NSR,NSUBCM,NXMAX,NYMAX
      INTEGER NZMAX,NZOB,NZSR
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,               &
              CDH(0:MLAYER),CDV(0:MLAYER),                                 &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV,                           &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),                &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),      &
            CLX(SUB_BLOCK),CLY(SUB_BLOCK),CLZ(SUB_BLOCK),                  &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),                       &
            ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
      IF (KSYM==1) THEN
         LS1=1
         LS2=4
         LS3=3
      ELSE
         LS1=2
         LS2=3
         LS3=1
      END IF
!
      DO I=1,N
         DO J=1,N
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (Z(K,L)>=ZBND(IOB)) THEN
                  NOB=IOB+1
                  GOTO 20
               END IF
            END DO
            NOB=0
   20       IF (L==1.AND.K==1) NOB1=NOB
            DO I=1,NX(L)
               DO J=1,NY(L)
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  DELTH=CDB(NN,L)-CDH(NOB)
                  DELTV=CDB(NN,L)-CDV(NOB)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK
                     IF (LL>1) NCB1=NCB1+NCELL(LL-1)
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           DO KK=1,NZ(LL)
                              N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)   &
                                 +KK+NCB1
                              NN2=(N2-1)*3+1
!
                              DO ISR=MLAYER-1,0,-1
                              IF (Z(KK,LL)>=ZBND(ISR)) THEN
                              NSR=ISR+1
                              GOTO 22
                              END IF
                              END DO
                              NSR=0
!
! ---- KSELF controls if the calculation for the self-cells
!    should be repeated
   22                         IF (I==1.AND.J==1.AND.K==1.OR.  &
                                 NOB1/=NOB.OR.NOB1/=NSR) THEN
                              KSELF=1
                              ELSE
                              KSELF=0
                              END IF
!
                              CLX1=CLX(LL)
                              CLY1=CLY(LL)
                              CLZ1=CLZ(LL)
!
                              DO LSYM=LS1,LS2,LS3
                              IF (LSYM==1) THEN
                              BX=1.
                              BY=1.
                              SX=1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==2) THEN
                              BX=-1.
                              BY=1.
                              SX=-1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==3) THEN
                              BX=1.
                              BY=-1.
                              SX=-1.
                              SY=1.
                              SZ=-1.
                              END IF
                              IF (LSYM==4) THEN
                              BX=-1.
                              BY=-1.
                              SX=1.
                              SY=1.
                              SZ=-1.
                              END IF
!
                              PSTION(1)=X(I,L)
                              PSTION(2)=Y(J,L)
                              PSTION(3)=Z(K,L)
                              PSTION(4)=BX*X(II,LL)
                              PSTION(5)=BY*Y(JJ,LL)
                              PSTION(6)=Z(KK,LL)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX1,CLY1,CLZ1,     &
                                 CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                                 ECOMP,HCOMP)
!
                              G(NN1,NN2)=G(NN1,NN2)-SX*EXX
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*EYX
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*EZX
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*EXY
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)-SY*EYY
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)-SY*EZY
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*EXZ
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)-SZ*EYZ
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)-SZ*EZZ
                              END DO
                              IF (KSYM==1.AND.N1==N2) THEN
                              G(NN1,NN2)=G(NN1,NN2)+1./DELTH
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)+1./DELTH
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)+1./DELTV
                              END IF

                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
      RETURN
      END
!
!**** End of MTRX_3M
!
!
      SUBROUTINE MTRX_3MS(NMAX,N,NXMAX,NYMAX,NZMAX,NX,NY,NZ,NCELL,        &
                          NSUBCM,SUB_BLOCK,X,Y,Z,CLX,CLY,CLZ,CDB,KSYM,G,  &
                          FRQ,MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,NZSR,     &
                          ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,           &
                          RRG3,NRG3,GRHF3,GRHO0,GRHO03,CLMN,KCLMN,        &
                          BLMIN,KACC,KUTCRP)
!
!**** SET UP THE MATRIX FOR A SYMMETRIC STRUCTURE WITH
!   EQUAL CELL SIZES FOR SYMMETRIC BODY EMBBEDED IN
!   AN ISOTROPIC BODY OR IN A SINGLE LAYER OF AN ANISOTROPIC
!   EARTH
!
!   Note the matrix is symmetrical and is stored in a doubly
!   subscripted array
!
!   The differences among smtrx3ms, smtrx3m and smtrx3
!   are like those among smtrx1ms, smtrx1m and smtrx1
!
!   Note that only two quarters, either quarter I and IV
!   or quarter II and III, are computed at a time, which is
!   controled by the parameter KSYM (=1 or 2). The actual
!   scattering matrix is then formed in the main routine
!   by addition or substraction of the results of KSYM=1
!   and 2 according to the polarizations.
!
!
      IMPLICIT NONE
!
      REAL BLMIN,BX,BY,CLMN,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN,SX,SY,SZ
      INTEGER I,II,IOB,ISR,J,JJ,K,KACC,KCLMN,KEYG,KK,KSELF,KSYM,KUTCRP,   &
              L,LL,LS1,LS2,LS3,LSYM
      INTEGER MLAYER,N,N1,N2,SUB_BLOCK,NCB,NCB1,NHFILM,NMAX,NN,NN1,NN2,   &
              NOB,NOB1,NRG,NRG3,NSR,NSUBCM,NXMAX,NYMAX
      INTEGER NZMAX,NZOB,NZSR
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,              &
              CDH(0:MLAYER),CDV(0:MLAYER),                                &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV,                          &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),               &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),     &
            CLX(SUB_BLOCK),CLY(SUB_BLOCK),CLZ(SUB_BLOCK),                 &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),                      &
            ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
      IF (KSYM==1) THEN
         LS1=1
         LS2=4
         LS3=3
      ELSE
         LS1=2
         LS2=3
         LS3=1
      END IF
!
      DO I=1,N
         DO J=1,N
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (Z(K,L)>=ZBND(IOB)) THEN
                  NOB=IOB+1
                  GOTO 20
               END IF
            END DO
            NOB=0
   20       IF (L==1.AND.K==1) NOB1=NOB
            DO I=1,NX(L)
               DO J=1,NY(L)
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  DELTH=CDB(NN,L)-CDH(NOB)
                  DELTV=CDB(NN,L)-CDV(NOB)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK
                     IF (LL>1) NCB1=NCB1+NCELL(LL-1)
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           DO KK=1,NZ(LL)
                              N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)   &
                                 +KK+NCB1
                              NN2=(N2-1)*3+1
                              DO ISR=MLAYER-1,0,-1
                              IF (Z(KK,LL)>=ZBND(ISR)) THEN
                              NSR=ISR+1
                              GOTO 22
                              END IF
                              END DO
                              NSR=0
!
! ---- KSELF controls if the calculation for the self-cells
!    should be repeated
   22                         IF (I==1.AND.J==1.AND.K==1.OR.  &
                                 NOB1/=NOB.OR.NOB1/=NSR) THEN
                              KSELF=1
                              ELSE
                              KSELF=0
                              END IF
!
                              IF (N1<=N2) THEN
!
                              CLX1=CLX(LL)
                              CLY1=CLY(LL)
                              CLZ1=CLZ(LL)
                              DO LSYM=LS1,LS2,LS3
                              IF (LSYM==1) THEN
                              BX=1.
                              BY=1.
                              SX=1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==2) THEN
                              BX=-1.
                              BY=1.
                              SX=-1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==3) THEN
                              BX=1.
                              BY=-1.
                              SX=-1.
                              SY=1.
                              SZ=-1.
                              END IF
                              IF (LSYM==4) THEN
                              BX=-1.
                              BY=-1.
                              SX=1.
                              SY=1.
                              SZ=-1.
                              END IF
!
                              PSTION(1)=X(I,L)
                              PSTION(2)=Y(J,L)
                              PSTION(3)=Z(K,L)
                              PSTION(4)=BX*X(II,LL)
                              PSTION(5)=BY*Y(JJ,LL)
                              PSTION(6)=Z(KK,LL)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX1,CLY1,CLZ1,     &
                                 CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                                 ECOMP,HCOMP)
!
                              G(NN1,NN2)=G(NN1,NN2)-SX*EXX
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*EYX
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*EZX
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*EXY
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)-SY*EYY
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)-SY*EZY
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*EXZ
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)-SZ*EYZ
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)-SZ*EZZ
                              END DO
                              IF (KSYM==1.AND.N1==N2) THEN
                              G(NN1,NN2)=G(NN1,NN2)+1./DELTH
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)+1./DELTH
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)+1./DELTV
                              END IF
                              END IF
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
      DO I=1,N
         DO J=1,N
            IF (I>J) G(I,J)=G(J,I)
         END DO
      END DO
      RETURN
      END
!
!**** End of MTRX_3MS
!
!
      SUBROUTINE MTRX_M(NMAX,N,NXMAX,NYMAX,NZMAX,NX1,NY1,NZ1,NCELL1,     &
                        SUB_BLOCK1,X1,Y1,Z1,NX2,NY2,NZ2,NCELL2,          &
                        SUB_BLOCK2,X2,Y2,Z2,CLX2,CLY2,CLZ2,G,FRQ,MLAYER, &
                        ZBND,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,    &
                        NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,       &
                        GRHO03,CLMN,KCLMN,BLMIN,KACC,KUTCRP)
!
!**** Form mutual-coupling matrices between substructures
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN,CLX,CLY,CLZ,DMIN,FRQ,RHOMIN
      INTEGER I,II,J,JJ,K,KACC,KCLMN,KEYG,KK,KSELF,KUTCRP,L,LL,MLAYER,N,  &
              N1,N2,SUB_BLOCK1,SUB_BLOCK2,NCB
      INTEGER NCB1,NHFILM,NMAX,NN,NN1,NN2,NRG,NRG3,NXMAX,NYMAX,NZMAX,     &
              NZOB,NZSR
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,              &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),               &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX1(SUB_BLOCK1),NY1(SUB_BLOCK1),NZ1(SUB_BLOCK1),            &
              NCELL1(SUB_BLOCK1),NX2(SUB_BLOCK2),NY2(SUB_BLOCK2),         &
              NZ2(SUB_BLOCK2),NCELL2(SUB_BLOCK2)
      REAL  X1(NXMAX,SUB_BLOCK1),Y1(NYMAX,SUB_BLOCK1),Z1(NZMAX,SUB_BLOCK1),  &
            X2(NXMAX,SUB_BLOCK2),Y2(NYMAX,SUB_BLOCK2),Z2(NZMAX,SUB_BLOCK2),  &
            CLX2(SUB_BLOCK2),CLY2(SUB_BLOCK2),CLZ2(SUB_BLOCK2),              &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),                         &
            ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX CDH(0:MLAYER),ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
      NCB=0
      DO L=1,SUB_BLOCK1
         IF (L>1) NCB=NCB+NCELL1(L-1)
! ---- Note that here k is the out-loop which may save some time in
!    array reference in the interpolation
         DO K=1,NZ1(L)
            DO I=1,NX1(L)
               DO J=1,NY1(L)
                  NN=(I-1)*NY1(L)*NZ1(L)+(J-1)*NZ1(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  NCB1=0
                  DO LL=1,SUB_BLOCK2
                     IF (LL>1) NCB1=NCB1+NCELL2(LL-1)
                     DO II=1,NX2(LL)
                        DO JJ=1,NY2(LL)
                           DO KK=1,NZ2(LL)
                              N2=(II-1)*NY2(LL)*NZ2(LL)+(JJ-1)*NZ2(LL) +   &
                                  KK+NCB1
                              NN2=(N2-1)*3+1
                              CLX=CLX2(LL)
                              CLY=CLY2(LL)
                              CLZ=CLZ2(LL)
!
                              PSTION(1)=X1(I,L)
                              PSTION(2)=Y1(J,L)
                              PSTION(3)=Z1(K,L)
                              PSTION(4)=X2(II,LL)
                              PSTION(5)=Y2(JJ,LL)
                              PSTION(6)=Z2(KK,LL)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX,CLY,CLZ,        &
                                 CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                                 ECOMP,HCOMP)
!
                              G(NN1,NN2)=EXX
                              G(NN1+1,NN2)=EYX
                              G(NN1+2,NN2)=EZX
                              G(NN1,NN2+1)=EXY
                              G(NN1+1,NN2+1)=EYY
                              G(NN1+2,NN2+1)=EZY
                              G(NN1,NN2+2)=EXZ
                              G(NN1+1,NN2+2)=EYZ
                              G(NN1+2,NN2+2)=EZZ
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
      RETURN
      END
!
!
      SUBROUTINE MTRX_MS(NMAX,N,NXMAX,NYMAX,NZMAX,NX1,NY1,NZ1,NCELL1,     &
                         SUB_BLOCK1,X1,Y1,Z1,NX2,NY2,NZ2,NCELL2,          &
                         SUB_BLOCK2,X2,Y2,Z2,CLX2,CLY2,CLZ2,KSYM,G,       &
                         FRQ,MLAYER,ZBND,CDH,HVK,NZOB,ZOBG,NZSR,          &
                         ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,                 &
                         GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,CLMN,          &
                         KCLMN,BLMIN,KACC,KUTCRP)
!
!     Setting up the mutual interaction matrix for a symmetric
!     Structure
!
!      Note that only two quarters, either quarter I and IV
!      or quarter II and III, are computed at a time, which is
!      controled by the parameter KSYM (=1 or 2). The actual
!      scattering matrix is then formed in the main routine
!      by addition or substraction of the results of KSYM=1
!      and 2 according to the polarizations.
!
      IMPLICIT NONE
!
      REAL BLMIN,BX,BY,CLMN,CLX,CLY,CLZ,DMIN,FRQ,RHOMIN,SX,SY,SZ
      INTEGER I,II,J,JJ,K,KACC,KCLMN,KEYG,KK,KSELF,KSYM,KUTCRP,L,LL,LS1,    &
              LS2,LS3,LSYM,MLAYER,N
      INTEGER N1,N2,SUB_BLOCK1,SUB_BLOCK2,NCB,NCB1,NHFILM,NMAX,NN,NN1,NN2,  &
              NRG,NRG3,NXMAX,NYMAX,NZMAX,NZOB,NZSR
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,                &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),                 &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX1(SUB_BLOCK1),NY1(SUB_BLOCK1),NZ1(SUB_BLOCK1),              &
              NCELL1(SUB_BLOCK1),NX2(SUB_BLOCK2),NY2(SUB_BLOCK2),           &
              NZ2(SUB_BLOCK2),NCELL2(SUB_BLOCK2)
      REAL  X1(NXMAX,SUB_BLOCK1),Y1(NYMAX,SUB_BLOCK1),Z1(NZMAX,SUB_BLOCK1), &
            X2(NXMAX,SUB_BLOCK2),Y2(NYMAX,SUB_BLOCK2),Z2(NZMAX,SUB_BLOCK2),  &
            CLX2(SUB_BLOCK2),CLY2(SUB_BLOCK2),CLZ2(SUB_BLOCK2),              &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),                         &
            ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX CDH(0:MLAYER),ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
      IF (KSYM==1) THEN
         LS1=1
         LS2=4
         LS3=3
      ELSE
         LS1=2
         LS2=3
         LS3=1
      END IF
!
      DO I=1,N
         DO J=1,NMAX
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      NCB=0
      DO L=1,SUB_BLOCK1
         IF (L>1) NCB=NCB+NCELL1(L-1)
! ---- Note that here k is the out-loop which may save some time in
!    array reference in the interpolation
         DO K=1,NZ1(L)
            DO I=1,NX1(L)
               DO J=1,NY1(L)
                  NN=(I-1)*NY1(L)*NZ1(L)+(J-1)*NZ1(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  NCB1=0
                  DO LL=1,SUB_BLOCK2
                     IF (LL>1) NCB1=NCB1+NCELL2(LL-1)
                     DO II=1,NX2(LL)
                        DO JJ=1,NY2(LL)
                           DO KK=1,NZ2(LL)
                              N2=(II-1)*NY2(LL)*NZ2(LL)+(JJ-1)*NZ2(LL)  &
                                 +KK+NCB1
                              NN2=(N2-1)*3+1
                              CLX=CLX2(LL)
                              CLY=CLY2(LL)
                              CLZ=CLZ2(LL)
                              DO LSYM=LS1,LS2,LS3
                              IF (LSYM==1) THEN
                              BX=1.
                              BY=1.
                              SX=1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==2) THEN
                              BX=-1.
                              BY=1.
                              SX=-1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==3) THEN
                              BX=1.
                              BY=-1.
                              SX=-1.
                              SY=1.
                              SZ=-1.
                              END IF
                              IF (LSYM==4) THEN
                              BX=-1.
                              BY=-1.
                              SX=1.
                              SY=1.
                              SZ=-1.
                              END IF
!
                              PSTION(1)=X1(I,L)
                              PSTION(2)=Y1(J,L)
                              PSTION(3)=Z1(K,L)
                              PSTION(4)=BX*X2(II,LL)
                              PSTION(5)=BY*Y2(JJ,LL)
                              PSTION(6)=Z2(KK,LL)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,    &
                                 NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,  &
                                 GRHO03,CLX,CLY,CLZ,CLMN,KCLMN,BLMIN,KACC,   &
                                 KUTCRP,KSELF,ECOMP,HCOMP)
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*EXX
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*EYX
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*EZX
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*EXY
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)+SY*EYY
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)+SY*EZY
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*EXZ
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)+SZ*EYZ
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)+SZ*EZZ
                              END DO
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
      RETURN
      END
!
!**** End of MTRX_MS
!
!
      SUBROUTINE MTRX_SPSGSB(SBX,SBY,SBZ,NXS,NYS,NZS,XSB,YSB,ZSB,NSMR,G,   &
                             FRQ,MLAYER,ZBND,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,  &
                             RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,NRG3,    &
                             GRHF3,GRHO0,GRHO03,CLMN,KCLMN,BLMIN,KACC,KUTCRP)
!
!**** Compute the non-identical elements of the scattering matrix
!   for the super block discretized into equal-size cells
!
!   Cell conductivities are not considered in this routine.
!
!   The size of the array G is determined in the main program.
!   It has the same size as the array grhf which stores the
!   grid value of the hankel transforms.
!
!   The parameter kself controls if the computation for the
!   integration of the primary part of the Green's function
!   for self-cells should be repeated. As the dimensions of
!   the cells within a block is the same, this integration
!   need to be done only once (kself=1) for cells located in
!   the same layer.
!
! Input parameters
!
!  SBX:     Real,  dimension of the super block in the x-direction.
!  SBY:     Real,  dimension of the super block in the y-direction.
!  SBZ:     Real,  dimension of the super block in the z-direction.
!  NXS:     Integer,  number of cells in the x-direction of the superblock.
!  NYS:     Integer,  number of cells in the y-direction of the superblock.
!  NZS:     Integer,  number of cells in the z-direction of the superblock.
!  XSB:     Real,  x-ccordinate of the superblock.
!  YSB:     Real,  y-ccordinate of the superblock.
!  ZSB:     Real,  z-ccordinate of the superblock.
!  NSMR:    Integer,  the maximal number of non-identical elements
!           for the scattering matrix which is determined by the
!           paramters NZSR, NZOB, and NHFILM of the code.  See the corresponding
!           paramter list in the main program for detail.
!
!  All other parameters FRQ, MLAYER, ZBND,  CDH, HVK, NZOB, ZOBG,
!  NZSR, ZSRG,  RHOMIN, DMIN, NHFILM, RRG, NRG, GRHF,
!  GRHF3, GRHO0, GRHO03, CLMN, KCLMN, BLMIN, KACC, and KUTCRP are to
!  be passed into routine THR_D_GREEN.  Check THR_D_GREEN for their
!  descriptions.
!
!
!Output parameters:
!
!  G:       Complex G(NSMR/3,3),  the non-identical matrix entries
!
!
!**** Called by:  MAIN_MATRICES
!
!**** Calls:      THR_D_GREEN
!
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN,FRQ,RHOMIN,SBX,SBY,SBZ,SCX,SCY,SCZ,X1,XI,XSB,Y1,   &
           YI,YSB,ZI,ZJ,ZSB
      INTEGER I,IOB,ISR,J,K,KACC,KCLMN,KEYG,KK,KSELF,KUTCRP,MLAYER,      &
              NHFILM,NN,NN1,NOB,NOB1,NRG,NRG3,NSMR
      INTEGER NSR,NXS,NYS,NZOB,NZS,NZSR
!
      COMPLEX G(NSMR/3,3)
!-- Parameter HCOMP is only used for consistence with routine THR_D_GREEN.
      COMPLEX ECOMP(9),HCOMP(9),EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,       &
              CDH(0:MLAYER),GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),  &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      REAL ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),           &
           RRG(NHFILM),RRG3(NRG3),PSTION(8),DMIN
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
! --- Compute the cell dimension of the super block
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
! --- Set the x- and y-coordinates of the cells at the lower left
!   corner
!
      X1=XSB-.5*SBX+.5*SCX
      Y1=YSB-.5*SBY+.5*SCY
!
      DO KK=1,NZS
         ZJ=ZSB-.5*SBZ+.5*SCZ+(KK-1)*SCZ
         DO IOB=MLAYER-1,0,-1
            IF (ZJ>=ZBND(IOB)) THEN
               NOB=IOB+1
               GOTO 50
            END IF
         END DO
         NOB=0
   50    IF (KK==1) NOB1=NOB
!
         DO K=1,NZS
!
! --- Reciprocity
!
!   Note that unlike in the routines MTRX_SPS1 etc. here the KK loop
!   is the field cell loop
!
            IF (KK<=K) THEN
!
               ZI=ZSB-.5*SBZ+.5*SCZ+(K-1)*SCZ
               DO ISR=MLAYER-1,0,-1
                  IF (ZI>=ZBND(ISR)) THEN
                     NSR=ISR+1
                     GOTO 60
                  END IF
               END DO
               NSR=0
!
! --- Note that the order of the array G in this routine is
!   different from that of the scattering matrices in other
!   routines which form the scattering matrices.  This is
!   due to the consideration of the reciprocity available for
!   different z-levels (the KK loop).  Also the loop for the
!   vertical direction (the K loop) is moved ahead of the
!   other two loops
!
   60          DO J=1,NYS
                  DO I=1,NXS
!
                     NN=(K-KK)*NXS*NYS+(J-1)*NXS+I
                     NN1=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-3*NXS*NYS*(KK-2))  &
                         *(KK-1)/2+(NN-1)*3+1
!
! ---- KSELF controls if the calculation for the self-cells
!    should be repeated
!
                     IF (I==1.AND.J==1.AND.K==1.OR.NOB1/=NOB.OR.  &
                         NOB1/=NSR) THEN
                        KSELF=1
                     ELSE
                        KSELF=0
                     END IF
!
                     XI=XSB-.5*SBX+.5*SCX+(I-1)*SCX
                     YI=YSB-.5*SBY+.5*SCY+(J-1)*SCY
!
                     PSTION(1)=X1
                     PSTION(2)=Y1
                     PSTION(3)=ZJ
                     PSTION(4)=XI
                     PSTION(5)=YI
                     PSTION(6)=ZI
                     CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,CDH,HVK,  &
                        NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,NHFILM,             &
                        RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,GRHO03,SCX,      &
                        SCY,SCZ,CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                        ECOMP,HCOMP)
!
                     G(NN1,1)=-EXX
                     G(NN1+1,1)=-EYX
                     G(NN1+2,1)=-EZX

                     G(NN1,2)=-EXY
                     G(NN1+1,2)=-EYY
                     G(NN1+2,2)=-EZY
                     G(NN1,3)=-EXZ
                     G(NN1+1,3)=-EYZ
                     G(NN1+2,3)=-EZZ
                  END DO
               END DO
            END IF
!
         END DO
      END DO
!
      RETURN
      END
!
!**** End of GSB
!
!
      SUBROUTINE MTRX_SPS(NSMR,MLAYER,ZBND,CDH,CDV,SBX,SBY,SBZ,NXS,NYS,    &
                          NZS,ZSB,NMAX,N,NXMAX,NYMAX,NZMAX,NX,NY,NZ,NCELL, &
                          NSUBCM,SUB_BLOCK,X,Y,Z,CDB,GSB2,G)
!
!****  Form the scattering matrix using spatial symmetry reduction
!    for diagonal submatrices or a general matrix of a
!    non-symmetric structure
!
!    The non-identical elements are pre-computed by the routine
!    GSB and are stored in the array gsb2.  Routine GSB must be called
!    before this routine.
!
!    Note that this routine works per substructure.  Thus,  all
!    structure parameters like NX etc. are those for one substructure.
!
!Input parameters
!
!  NSMR:    Integer,  the maximal number of non-identical elements
!           for the scattering matrix which is determined by the
!           paramters NZSR, NZOB and NHFILM of the code.  See the corresponding
!           paramter list in the main program for detail.
!  MLAYER:  Integer, the number of layers including the air.
!  ZBND:    Real ZBND(0:MLAYER), the z-coordinates of the layer
!           boundaries with the air-earth interface being always
!           0 (zbnd(0)=0).
!  CDH:     Complex CDH(0:MLAYER),  complex conductivities of
!           the layers in the lateral direction including the
!           air (layer 0).
!  CDV:     Complex CDV(0:MLAYER),  complex conductivities of
!           the layers in the vertical direction including the
!           air (layer 0).
!  SBX:     Real,  dimension of the super block in the x-direction.
!  SBY:     Real,  dimension of the super block in the y-direction.
!  SBZ:     Real,  dimension of the super block in the z-direction.
!  NXS:     Integer,  number of cells in the x-direction of the superblock.
!  NYS:     Integer,  number of cells in the y-direction of the superblock.
!  NZS:     Integer,  number of cells in the z-direction of the superblock.
!  ZSB:     Real,  z-ccordinate of the superblock.
!  NMAX:     Integer,  maximal number of unknowns in a substructure.
!            NMAX=3*NSUBCM.
!  N:       Integer,  real dimension of the scattering matrix.
!  NXMAX:   Integer,  maximal number of cells in the x-direction
!           in a block.
!  NYMAX:   Integer,  maximal number of cells in the y-direction
!           in a block.
!  NZMAX:   Integer,  maximal number of cells in the z-direction
!           in a block.
!  NX:      Integer NX(SUB_BLOCK), number of cells in the substructure
!           in the x-direction.
!  NY:      Integer NY(SUB_BLOCK), number of cells in the substructure
!           in the y-direction.
!  NZ:      Integer NZ(SUB_BLOCK), number of cells in the substructure
!           in the z-direction.
!  NCELL:   Integer NCELL(SUB_BLOCK),  number of cell in each block
!           of the substructure.
!  NSUBCM:  Integer,  maximal nuber of cells in a substructure.
!  SUB_BLOCK:  Integer,  number of blocks in the substructure.
!  X:       Real X(NXMAX,SUB_BLOCK), the x-coordinates of the cells
!           of the blocks in the substructure.
!  Y:       Real Y(NXMAX,SUB_BLOCK), the y-coordinates of the cells
!           of the blocks in the substructure.
!  Z:       Real Z(NXMAX,SUB_BLOCK), the z-coordinates of the cells
!           of the blocks in the substructure.
!  CDB:     COMPLEX CDB(NSUBCM,NBMAX),  working array for the
!           complex conductivities of the cells in a substructure.
!           Its values are all stored on the disk in unit 62.
!  GSB2:    Complex GSB2(NSMR/3,3),  the non-identical matrix entries
!
!
!Output parameters:
!
!  G:       Complex G(NMAX,N),  the scattering matrix or the
!           diagonal submatrix
!
!**** Called by:  MAIN_MATRICES
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL DX,DY,SBX,SBY,SBZ,SCX,SCY,SCZ,ZSB
      INTEGER I,II,IOB,IX,J,JJ,JY,K,KK,KKZ,KZ,L,LL,MLAYER,MM,MM2,MX,MY,N,N1
      INTEGER N2,SUB_BLOCK,NCB,NCB1,NMAX,NN,NN1,NN2,NOB,NSMR,NSUBCM,NXMAX,   &
              NXS,NYMAX,NYS,NZMAX,NZS
!
      COMPLEX G(NMAX,N),GSB2(NSMR/3,3),CDH(0:MLAYER),CDV(0:MLAYER),          &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),        &
            ZBND(0:MLAYER)
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
!
         DO I=1,NX(L)
            DO J=1,NY(L)
               DO K=1,NZ(L)
!
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
!
! --- Locate the z-level of the field cell in the super block
!
                  KZ=INT((Z(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK
                     IF (LL>1) NCB1=NCB1+NCELL(LL-1)
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           DO KK=1,NZ(LL)
!
! --- Locate the z'-level of the source cell in the super block
!
                              KKZ=INT((Z(KK,LL)+.5*SCZ-(ZSB-.5*SBZ))  &
                                 /SCZ+.2)
!
! --- Reciprocity to be considered later
!
                              IF (KZ<=KKZ) THEN
!
                              N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)  &
                                 +KK+NCB1
                              NN2=(N2-1)*3+1
!
! --- Identify the relative cell location in the super blocks
!
                              DX=(X(II,LL)-X(I,L))/SCX
! -- For stability
                              IF (DX>=0) IX=INT(DX+.2)+1
                              IF (DX<0) IX=INT(DX-.2)-1
                              IF (IX==-1) IX=1
!
                              DY=(Y(JJ,LL)-Y(J,L))/SCY
! -- For stability
                              IF (DY>=0) JY=INT(DY+.2)+1
                              IF (DY<0) JY=INT(DY-.2)-1
                              IF (JY==-1) JY=1
!
! --- Determine the values of the scattering matrix using the
!   symmetry properties of the Green's functions
!
                              IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
!
! --- Note that the order of the array GSB2 determined in the
!   routine GSB is different from that of the scattering matrix
!   formed here in this routine.  Check the routine GSB for
!   more explanations.
!
!   Note here KZ controls the field cell levels
!
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
!
                              G(NN1,NN2)=GSB2(MM2,1)
                              G(NN1+1,NN2)=GSB2(MM2+1,1)
                              G(NN1+2,NN2)=GSB2(MM2+2,1)
                              G(NN1,NN2+1)=GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=GSB2(MM2+2,1+2)
!
                              END IF
!
                              IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
!
                              G(NN1,NN2)=GSB2(MM2,1)
                              G(NN1+1,NN2)=-GSB2(MM2+1,1)
                              G(NN1+2,NN2)=-GSB2(MM2+2,1)
                              G(NN1,NN2+1)=-GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=-GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=GSB2(MM2+2,1+2)
!
                              END IF
!
                              IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
!
                              G(NN1,NN2)=GSB2(MM2,1)
                              G(NN1+1,NN2)=GSB2(MM2+1,1)
                              G(NN1+2,NN2)=-GSB2(MM2+2,1)
                              G(NN1,NN2+1)=GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=-GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=-GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=-GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=GSB2(MM2+2,1+2)
!
                              END IF
!
                              IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
!
                              G(NN1,NN2)=GSB2(MM2,1)
                              G(NN1+1,NN2)=-GSB2(MM2+1,1)
                              G(NN1+2,NN2)=GSB2(MM2+2,1)
                              G(NN1,NN2+1)=-GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=-GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=-GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=GSB2(MM2+2,1+2)
!
                              END IF
                              END IF
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
! --- Construct the entries of KKZ > KZ using the reciprocity
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
!
         DO I=1,NX(L)
            DO J=1,NY(L)
               DO K=1,NZ(L)
!
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
!
                  KZ=INT((Z(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK
                     IF (LL>1) NCB1=NCB1+NCELL(LL-1)
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           DO KK=1,NZ(LL)
!
                              KKZ=INT((Z(KK,LL)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                              IF (KZ>KKZ) THEN
!
                              N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)+KK+NCB1
                              NN2=(N2-1)*3+1
!
                              G(NN1,NN2)=G(NN2,NN1)
                              G(NN1+1,NN2)=G(NN2,NN1+1)
                              G(NN1+2,NN2)=G(NN2,NN1+2)
                              G(NN1,NN2+1)=G(NN2+1,NN1)
                              G(NN1+1,NN2+1)=G(NN2+1,NN1+1)
                              G(NN1+2,NN2+1)=G(NN2+1,NN1+2)
                              G(NN1,NN2+2)=G(NN2+2,NN1)
                              G(NN1+1,NN2+2)=G(NN2+2,NN1+1)
                              G(NN1+2,NN2+2)=G(NN2+2,NN1+2)
                              END IF
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
! --- Add the term of cell conductivity to the celf cells
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
!
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (Z(K,L)>=ZBND(IOB)) THEN
                  NOB=IOB+1
                  GOTO 20
               END IF
            END DO
            NOB=0
!
   20       DO I=1,NX(L)
               DO J=1,NY(L)
!
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
!
                  DELTH=CDB(NN,L)-CDH(NOB)
                  DELTV=CDB(NN,L)-CDV(NOB)
!
                  G(NN1,NN1)=1./DELTH+G(NN1,NN1)
                  G(NN1+1,NN1+1)=1./DELTH+G(NN1+1,NN1+1)
                  G(NN1+2,NN1+2)=1./DELTV+G(NN1+2,NN1+2)
!
               END DO
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!**** End of MTRX_SPS
!
!
      SUBROUTINE MTRX_SPSS(NSMR,MLAYER,ZBND,CDH,CDV,SBX,SBY,SBZ,NXS,NYS,    &
                           NZS,ZSB,NMAX,N,NXMAX,NYMAX,NZMAX,NX,NY,NZ,NCELL, &
                           NSUBCM,SUB_BLOCK,X,Y,Z,CDB,KSYM,G,GSB2)
!
!**** Form the scattering matrix using spatial symmetry reduction
!      for structures with two-plane symmetries under
!             plane wave excitations
!
!   For the diagonal submatrices or a general matrix of a
!   non-symmetric structure
!
!   Non-identical elements are pre-computed by the routine
!   GSB and are stored in the array gsb2.
!
!   Note the matrix is symmetrical and is stored in a doubly
!   subscripted array
!
!   Note that only two quarters, either quarter I and IV
!   or quarter II and III, are computed at a time, which is
!   controled by the parameter KSYM (=1 or 2). The actual
!   scattering matrix is then formed in the main routine
!   by addition or substraction of the results of KSYM=1
!   and 2 according to the polarizations.
!
!    Note that this routine works per substructure.  Thus,  all
!    structure parameters like NX etc. are those for one substructure.
!
!Input parameters
!
!  NSMR:    Integer,  the maximal number of non-identical elements
!           for the scattering matrix which is determined by the
!           paramters NZSR, NZOB and NHFILM of the code.  See the corresponding
!           paramter list in the main program for detail.
!  MLAYER:  Integer, the number of layers including the air.
!  ZBND:    Real ZBND(0:MLAYER), the z-coordinates of the layer
!           boundaries with the air-earth interface being always
!           0 (zbnd(0)=0).
!  CDH:     Complex CDH(0:MLAYER),  complex conductivities of
!           the layers in the lateral direction including the
!           air (layer 0).
!  CDV:     Complex CDV(0:MLAYER),  complex conductivities of
!           the layers in the vertical direction including the
!           air (layer 0).
!  SBX:     Real,  dimension of the super block in the x-direction.
!  SBY:     Real,  dimension of the super block in the y-direction.
!  SBZ:     Real,  dimension of the super block in the z-direction.
!  NXS:     Integer,  number of cells in the x-direction of the superblock.
!  NYS:     Integer,  number of cells in the y-direction of the superblock.
!  NZS:     Integer,  number of cells in the z-direction of the superblock.
!  ZSB:     Real,  z-ccordinate of the superblock.
!  NMAX:     Integer,  maximal number of unknowns in a substructure.
!            NMAX=3*NSUBCM.
!  N:       Integer,  real dimension of the scattering matrix.
!  NXMAX:   Integer,  maximal number of cells in the x-direction
!           in a block.
!  NYMAX:   Integer,  maximal number of cells in the y-direction
!           in a block.
!  NZMAX:   Integer,  maximal number of cells in the z-direction
!           in a block.
!  NX:      Integer NX(SUB_BLOCK), number of cells in the substructure
!           in the x-direction.
!  NY:      Integer NY(SUB_BLOCK), number of cells in the substructure
!           in the y-direction.
!  NZ:      Integer NZ(SUB_BLOCK), number of cells in the substructure
!           in the z-direction.
!  NCELL:   Integer NCELL(SUB_BLOCK),  number of cell in each block
!           of the substructure.
!  NSUBCM:  Integer,  maximal nuber of cells in a substructure.
!  SUB_BLOCK:  Integer,  number of blocks in the substructure.
!  X:       Real X(NXMAX,SUB_BLOCK), the x-coordinates of the cells
!           of the blocks in the substructure.
!  Y:       Real Y(NXMAX,SUB_BLOCK), the y-coordinates of the cells
!           of the blocks in the substructure.
!  Z:       Real Z(NXMAX,SUB_BLOCK), the z-coordinates of the cells
!           of the blocks in the substructure.
!  CDB:     COMPLEX CDB(NSUBCM,NBMAX),  working array for the
!           complex conductivities of the cells in a substructure.
!           Its values are all stored on the disk in unit 62.
!  GSB2:    Complex GSB2(NSMR/3,3),  the non-identical matrix entries
!
!
!Output parameters:
!
!  G:       Complex G(NMAX,N),  the scattering matrix or the
!           diagonal submatrix
!
!**** Called by:  MAIN_MATRICES
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL BX,BY,DX,DY,SBX,SBY,SBZ,SCX,SCY,SCZ,SX,SY,SZ,ZSB
      INTEGER I,II,IOB,IX,J,JJ,JY,K,KK,KKZ,KSYM,KZ,L,LL,LS1,LS2,LS3,          &
              LSYM,MLAYER,MM
      INTEGER MM2,MX,MY,N,N1,N2,SUB_BLOCK,NCB,NCB1,NMAX,NN,NN1,NN2,NOB,NSMR,  &
              NSUBCM,NXMAX,NXS,NYMAX,NYS,NZMAX,NZS
!
      COMPLEX GSB2(NSMR/3,3),G(NMAX,N),CDH(0:MLAYER),CDV(0:MLAYER),           &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),         &
            ZBND(0:MLAYER)
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
      IF (KSYM==1) THEN
         LS1=1
         LS2=4
         LS3=3
      ELSE
         LS1=2
         LS2=3
         LS3=1
      END IF
!
      DO I=1,N
         DO J=1,N
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
!
         DO I=1,NX(L)
            DO J=1,NY(L)
               DO K=1,NZ(L)
!
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
!
! --- Locate the z-level of the field cell in the super block
!
                  KZ=INT((Z(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK
                     IF (LL>1) NCB1=NCB1+NCELL(LL-1)
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           DO KK=1,NZ(LL)
!
! --- Locate the z'-level of the source cell in the super block
!
                              KKZ=INT((Z(KK,LL)+.5*SCZ-(ZSB-.5*SBZ))  &
                                 /SCZ+.2)
!
                              N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)  &
                                 +KK+NCB1
                              NN2=(N2-1)*3+1
!
! --- Compute the contributions of each quarter
!
                              DO LSYM=LS1,LS2,LS3
!
                              IF (LSYM==1) THEN
                              BX=1.
                              BY=1.
                              SX=1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==2) THEN
                              BX=-1.
                              BY=1.
                              SX=-1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==3) THEN
                              BX=1.
                              BY=-1.
                              SX=-1.
                              SY=1.
                              SZ=-1.
                              END IF
                              IF (LSYM==4) THEN
                              BX=-1.
                              BY=-1.
                              SX=1.
                              SY=1.
                              SZ=-1.
                              END IF
!
! --- Identify the relative cell location in the super blocks
!
!   Note that reciprocity is considered here
!
                              IF (KZ<=KKZ) THEN
                              DX=(BX*X(II,LL)-X(I,L))/SCX
                              ELSE
                              DX=(X(I,L)-BX*X(II,LL))/SCX
                              END IF
                              IF (DX>=0) IX=INT(DX+.2)+1
                              IF (DX<0) IX=INT(DX-.2)-1
                              IF (IX==-1) IX=1
!
                              IF (KZ<=KKZ) THEN
                              DY=(BY*Y(JJ,LL)-Y(J,L))/SCY
                              ELSE
                              DY=(Y(J,L)-BY*Y(JJ,LL))/SCY
                              END IF
                              IF (DY>=0) JY=INT(DY+.2)+1
                              IF (DY<0) JY=INT(DY-.2)-1
                              IF (JY==-1) JY=1
!
! --- Determine the values of the scattering matrix using the
!   symmetry properties of the Green's functions
!
!      IF(KZ<=KKZ) THEN
!           MZ=KKZ
!         ELSE
!           MZ=KZ
!       END IF
!
                              IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
!
! --- Note that the order of the array GSB2 determined in the
!   routine GSB is different from that of the scattering matrix
!   formed here in this routine.  Check the routine GSB for
!   more explanations.
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
!
                              END IF
!
                              END DO
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
! --- Add the term of cell conductivity to the self cells
!
!-- Only for ksym=1
!
      IF (KSYM/=1) THEN
         RETURN
      END IF
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
!
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (Z(K,L)>=ZBND(IOB)) THEN
                  NOB=IOB+1
                  GOTO 20
               END IF
            END DO
            NOB=0
!
   20       DO I=1,NX(L)
               DO J=1,NY(L)
!
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
!
                  DELTH=CDB(NN,L)-CDH(NOB)
                  DELTV=CDB(NN,L)-CDV(NOB)
!
                  G(NN1,NN1)=1./DELTH+G(NN1,NN1)
                  G(NN1+1,NN1+1)=1./DELTH+G(NN1+1,NN1+1)
                  G(NN1+2,NN1+2)=1./DELTV+G(NN1+2,NN1+2)
!
               END DO
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!**** End of MTRX_SPSS
!
!
      SUBROUTINE MTRX_SPSM(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NMAX,N,NXMAX,NYMAX,  &
                           NZMAX,NX1,NY1,NZ1,NCELL1,SUB_BLOCK1,X1,Y1,Z1,    &
                           NX2,NY2,NZ2,NCELL2,SUB_BLOCK2,X2,Y2,Z2,G,NSMR,GSB2)
!
!**** Form the mutual-coupling between substructures
!   using spatial symmetry reduction for
!   non-symmetric structures
!
!   The non-identical elements are pre-computed by the routine
!   GSB and are stored in the array gsb2
!
!
      IMPLICIT NONE
!
      REAL DX,DY,SBX,SBY,SBZ,SCX,SCY,SCZ,ZSB
      INTEGER I,II,IX,J,JJ,JY,K,KK,KKZ,KZ,L,LL,MM,MM1,MM2,MM3,MX,MY,N,N1
      INTEGER N12,N13,N2,N22,N23,SUB_BLOCK1,SUB_BLOCK2,NCB,NCB1,NMAX,NN,   &
              NN1,NN2,NSMR,NXMAX,NXS,NYMAX,NYS,NZMAX,NZS
!
      COMPLEX GSB2(NSMR/3,3),G(NMAX,N)
      INTEGER NX1(SUB_BLOCK1),NY1(SUB_BLOCK1),NZ1(SUB_BLOCK1),             &
              NCELL1(SUB_BLOCK1),NX2(SUB_BLOCK2),NY2(SUB_BLOCK2),          &
              NZ2(SUB_BLOCK2),NCELL2(SUB_BLOCK2)
      REAL  X1(NXMAX,SUB_BLOCK1),Y1(NYMAX,SUB_BLOCK1),Z1(NZMAX,SUB_BLOCK1), &
            X2(NXMAX,SUB_BLOCK2),Y2(NYMAX,SUB_BLOCK2),Z2(NZMAX,SUB_BLOCK2)
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
      NCB=0
      DO L=1,SUB_BLOCK1
         IF (L>1) NCB=NCB+NCELL1(L-1)
! ---- Note that here k is the out-loop which may save some time in
!    array reference in identifying elements from GSB2
         DO K=1,NZ1(L)
!
! --- Locate the z-level of the field cell in the super block
!
            KZ=INT((Z1(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
            DO I=1,NX1(L)
               DO J=1,NY1(L)
                  NN=((I-1)*NY1(L)+(J-1))*NZ1(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  N12=NN1+1
                  N13=NN1+2
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK2
                     IF (LL>1) NCB1=NCB1+NCELL2(LL-1)
                     DO KK=1,NZ2(LL)
!
! --- Locate the z'-level of the source cell in the super block
!
                        KKZ=INT((Z2(KK,LL)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                        DO II=1,NX2(LL)
                           DO JJ=1,NY2(LL)
                              N2=((II-1)*NY2(LL)+(JJ-1))*NZ2(LL)+KK+NCB1
                              NN2=(N2-1)*3+1
                              N22=NN2+1
                              N23=NN2+2
!
! --- Identify the relative cell location in the super blocks
!
!   Note that reciprocity is considered here
!
                              IF (KZ<=KKZ) THEN
                              DX=(X2(II,LL)-X1(I,L))/SCX
                              ELSE
                              DX=(X1(I,L)-X2(II,LL))/SCX
                              END IF
                              IF (DX>=0) IX=INT(DX+.2)+1
                              IF (DX<0) IX=INT(DX-.2)-1
                              IF (IX==-1) IX=1
!
                              IF (KZ<=KKZ) THEN
                              DY=(Y2(JJ,LL)-Y1(J,L))/SCY
                              ELSE
                              DY=(Y1(J,L)-Y2(JJ,LL))/SCY
                              END IF
                              IF (DY>=0) JY=INT(DY+.2)+1
                              IF (DY<0) JY=INT(DY-.2)-1
                              IF (JY==-1) JY=1
!
! --- Determine the values of the scattering matrix using the
!   symmetry properties of the Green's functions
!
!      IF(KZ<=KKZ) THEN
!           MZ=KKZ
!         ELSE
!           MZ=KZ
!       END IF
!
                              IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
!
! --- Note that the order of the array GSB2 determined in the
!   routine GSB is different from that of the scattering matrix
!   formed here in this routine.  Check the routine GSB for
!   more explanations.
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=-GSB2(MM1,2)
                              G(N13,NN2)=-GSB2(MM1,3)
                              G(NN1,N22)=-GSB2(MM2,1)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=-GSB2(MM2,3)
                              G(NN1,N23)=-GSB2(MM3,1)
                              G(N12,N23)=-GSB2(MM3,2)
                              G(N13,N23)=-GSB2(MM3,3)
                              ELSE
!
! ---  The sign of G is reversed as compared to those in
!      the routine MTRX_SPSS
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=-GSB2(MM2,1)
                              G(N13,NN2)=-GSB2(MM3,1)
                              G(NN1,N22)=-GSB2(MM1,2)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=-GSB2(MM3,2)
                              G(NN1,N23)=-GSB2(MM1,3)
                              G(N12,N23)=-GSB2(MM2,3)
                              G(N13,N23)=-GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=GSB2(MM1,2)
                              G(N13,NN2)=GSB2(MM1,3)
                              G(NN1,N22)=GSB2(MM2,1)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=-GSB2(MM2,3)
                              G(NN1,N23)=GSB2(MM3,1)
                              G(N12,N23)=-GSB2(MM3,2)
                              G(N13,N23)=-GSB2(MM3,3)
                              ELSE
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=GSB2(MM2,1)
                              G(N13,NN2)=GSB2(MM3,1)
                              G(NN1,N22)=GSB2(MM1,2)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=-GSB2(MM3,2)
                              G(NN1,N23)=GSB2(MM1,3)
                              G(N12,N23)=-GSB2(MM2,3)
                              G(N13,N23)=-GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=-GSB2(MM1,2)
                              G(N13,NN2)=GSB2(MM1,3)
                              G(NN1,N22)=-GSB2(MM2,1)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=GSB2(MM2,3)
                              G(NN1,N23)=GSB2(MM3,1)
                              G(N12,N23)=GSB2(MM3,2)
                              G(N13,N23)=-GSB2(MM3,3)
                              ELSE
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=-GSB2(MM2,1)
                              G(N13,NN2)=GSB2(MM3,1)
                              G(NN1,N22)=-GSB2(MM1,2)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=GSB2(MM3,2)
                              G(NN1,N23)=GSB2(MM1,3)
                              G(N12,N23)=GSB2(MM2,3)
                              G(N13,N23)=-GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=GSB2(MM1,2)
                              G(N13,NN2)=-GSB2(MM1,3)
                              G(NN1,N22)=GSB2(MM2,1)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=GSB2(MM2,3)
                              G(NN1,N23)=-GSB2(MM3,1)
                              G(N12,N23)=GSB2(MM3,2)
                              G(N13,N23)=-GSB2(MM3,3)
                              ELSE
!
                              G(NN1,NN2)=-GSB2(MM1,1)
                              G(N12,NN2)=GSB2(MM2,1)
                              G(N13,NN2)=-GSB2(MM3,1)
                              G(NN1,N22)=GSB2(MM1,2)
                              G(N12,N22)=-GSB2(MM2,2)
                              G(N13,N22)=GSB2(MM3,2)
                              G(NN1,N23)=-GSB2(MM1,3)
                              G(N12,N23)=GSB2(MM2,3)
                              G(N13,N23)=-GSB2(MM3,3)
                              END IF
!
                              END IF
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!
      SUBROUTINE MTRX_SPSSM(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,NMAX,N,NXMAX,    &
                            NYMAX,NZMAX,NX1,NY1,NZ1,NCELL1,SUB_BLOCK1,   &
                            X1,Y1,Z1,NX2,NY2,NZ2,NCELL2,SUB_BLOCK2,X2,   &
                            Y2,Z2,KSYM,G,NSMR,GSB2)
!
!**** Form the mutual-coupling between substructures
!   using spatial symmetry reduction for structures with
!   two-plane symmetries under plane wave excitations
!
!   The non-identical elements are pre-computed by the routine
!   GSB and are stored in the array gsb2 in the common block /ghf
!
!
!      Note that only two quarters, either quarter I and IV
!      or quarter II and III, are computed at a time, which is
!      controled by the parameter KSYM (=1 or 2). The actual
!      scattering matrix is then formed in the main routine
!      by addition or substraction of the results of KSYM=1
!      and 2 according to the polarizations.
!
!      The parameter nztmax controls the size of the array g
!      which shares storage with the array grhf.  The value
!      of nztmax must be consistent throughout the program.
!      check the comments on the beginning of the main program
!      if the value of nztmax is to be changed.
!
!
      IMPLICIT NONE
!
      REAL BX,BY,DX,DY,SBX,SBY,SBZ,SCX,SCY,SCZ,SX,SY,SZ,ZSB
      INTEGER I,II,IX,J,JJ,JY,K,KK,KKZ,KSYM,KZ,L,LL,LS1,LS2,LS3,LSYM,MM,    &
              MM2,MX,MY,N,N1,N2,SUB_BLOCK1,SUB_BLOCK2,NCB,NCB1,NMAX,NN,NN1, &
              NN2,NSMR,NXMAX,NXS,NYMAX,NYS,NZMAX,NZS
!
      COMPLEX GSB2(NSMR/3,3),G(NMAX,N)
      INTEGER NX1(SUB_BLOCK1),NY1(SUB_BLOCK1),NZ1(SUB_BLOCK1),              &
              NCELL1(SUB_BLOCK1),NX2(SUB_BLOCK2),NY2(SUB_BLOCK2),           &
              NZ2(SUB_BLOCK2),NCELL2(SUB_BLOCK2)
      REAL  X1(NXMAX,SUB_BLOCK1),Y1(NYMAX,SUB_BLOCK1),Z1(NZMAX,SUB_BLOCK1), &
            X2(NXMAX,SUB_BLOCK2),Y2(NYMAX,SUB_BLOCK2),Z2(NZMAX,SUB_BLOCK2)
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
      IF (KSYM==1) THEN
         LS1=1
         LS2=4
         LS3=3
      ELSE
         LS1=2
         LS2=3
         LS3=1
      END IF
!
      DO I=1,N
         DO J=1,NMAX
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      NCB=0
      DO L=1,SUB_BLOCK1
         IF (L>1) NCB=NCB+NCELL1(L-1)
! ---- Note that here k is the out-loop which may save some time in
!    array reference in identifying elements from GSB2
         DO K=1,NZ1(L)
            DO I=1,NX1(L)
               DO J=1,NY1(L)
                  NN=(I-1)*NY1(L)*NZ1(L)+(J-1)*NZ1(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
!
! --- Locate the z-level of the field cell in the super block
!
                  KZ=INT((Z1(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK2
                     IF (LL>1) NCB1=NCB1+NCELL2(LL-1)
                     DO KK=1,NZ2(LL)
                        DO II=1,NX2(LL)
                           DO JJ=1,NY2(LL)
                              N2=(II-1)*NY2(LL)*NZ2(LL)+(JJ-1)*NZ2(LL)+KK+NCB1
                              NN2=(N2-1)*3+1
!
! --- Locate the z'-level of the source cell in the super block
!
                              KKZ=INT((Z2(KK,LL)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
! --- Compute the contributions of each quarter
!
                              DO LSYM=LS1,LS2,LS3
!
                              IF (LSYM==1) THEN
                              BX=1.
                              BY=1.
                              SX=1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==2) THEN
                              BX=-1.
                              BY=1.
                              SX=-1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (LSYM==3) THEN
                              BX=1.
                              BY=-1.
                              SX=-1.
                              SY=1.
                              SZ=-1.
                              END IF
                              IF (LSYM==4) THEN
                              BX=-1.
                              BY=-1.
                              SX=1.
                              SY=1.
                              SZ=-1.
                              END IF
!
! --- Identify the relative cell location in the super blocks
!
!   Note that reciprocity is considered here
!
                              IF (KZ<=KKZ) THEN
                              DX=(BX*X2(II,LL)-X1(I,L))/SCX
                              ELSE
                              DX=(X1(I,L)-BX*X2(II,LL))/SCX
                              END IF
                              IF (DX>=0) IX=INT(DX+.2)+1
                              IF (DX<0) IX=INT(DX-.2)-1
                              IF (IX==-1) IX=1
!
                              IF (KZ<=KKZ) THEN
                              DY=(BY*Y2(JJ,LL)-Y1(J,L))/SCY
                              ELSE
                              DY=(Y1(J,L)-BY*Y2(JJ,LL))/SCY
                              END IF
                              IF (DY>=0) JY=INT(DY+.2)+1
                              IF (DY<0) JY=INT(DY-.2)-1
                              IF (JY==-1) JY=1
!
! --- Determine the values of the scattering matrix using the
!   symmetry properties of the Green's functions
!
!      IF(KZ<=KKZ) THEN
!           MZ=KKZ
!         ELSE
!           MZ=KZ
!       END IF
!
                              IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
!
! --- Note that the order of the array GSB2 determined in the
!   routine GSB is different from that of the scattering matrix
!   formed here in this routine.  Check the routine GSB for
!   more explanations.
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
! ---  The sign of G will be reversed later on.  The following
!      lines are designed to identical as in the routine MTRX_SPSS
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 +SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 +SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)+SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)-SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)+SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)-SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=(KKZ-KZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KZ-2))*(KZ-1)/2+(MM-1)*3+1
                              ELSE
                              MM=(KZ-KKZ)*NXS*NYS+(MY-1)*NXS+MX
                              MM2=(3*NXS*NYS*NZS+3*NXS*NYS*NZS-  &
                                 3*NXS*NYS*(KKZ-2))*(KKZ-1)/2+(MM-1)*3+1
                              END IF
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2,1+1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2,1+2)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2+1,1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+1,1+2)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2+2,1)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+2,1+1)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              ELSE
!
                              G(NN1,NN2)=G(NN1,NN2)+SX*GSB2(MM2,1)
                              G(NN1+1,NN2)=G(NN1+1,NN2)-SX*GSB2(MM2+1,1)
                              G(NN1+2,NN2)=G(NN1+2,NN2)+SX*GSB2(MM2+2,1)
                              G(NN1,NN2+1)=G(NN1,NN2+1)-SY*GSB2(MM2,1+1)
                              G(NN1+1,NN2+1)=G(NN1+1,NN2+1)  &
                                 +SY*GSB2(MM2+1,1+1)
                              G(NN1+2,NN2+1)=G(NN1+2,NN2+1)  &
                                 -SY*GSB2(MM2+2,1+1)
                              G(NN1,NN2+2)=G(NN1,NN2+2)+SZ*GSB2(MM2,1+2)
                              G(NN1+1,NN2+2)=G(NN1+1,NN2+2)  &
                                 -SZ*GSB2(MM2+1,1+2)
                              G(NN1+2,NN2+2)=G(NN1+2,NN2+2)  &
                                 +SZ*GSB2(MM2+2,1+2)
                              END IF
!
                              END IF
!
                              END DO
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
! --- Reverse the sign of G
!
      DO I=1,N
         DO J=1,NMAX
            G(J,I)=-G(J,I)
         END DO
      END DO
!
      RETURN
      END
!
!
      SUBROUTINE MTRX_SPSSM2(SBX,SBY,SBZ,NXS,NYS,NZS,ZSB,              &
                             NMAX,NJ,N,NXMAX,NYMAX,NZMAX,              &
                             NX1,NY1,NZ1,NCELL1,SUB_BLOCK1,X1,Y1,Z1,   &
                             NX2,NY2,NZ2,NCELL2,SUB_BLOCK2,X2,Y2,Z2,   &
                             KPOL,G,NSMR,GSB2)
!
!**** Form the mutual-coupling between substructures
!   using spatial symmetry reduction for structures with
!   two-plane symmetries under plane wave excitations
!
!   The non-identical elements are pre-computed by the routine
!   GSB and are stored in the array gsb2 in the common block /ghf
!
!   This routine form the interaction matrices for both
!   E-polarization and B-polarization.   Unlike in the
!   routine smrdsm,  all four quarters are computed here.
!   The parameter kpol controls the polarizations.
!   Note that one more parameter, nj, is used here.
!
!      The parameter nztmax controls the size of the array g
!      which shares storage with the array grhf.  The value
!      of nztmax must be consistent throughout the program.
!      check the comments on the beginning of the main program
!      if the value of nztmax is to be changed.
!
!
      IMPLICIT NONE
!
      REAL BX,BY,DX,DY,SBX,SBY,SBZ,SCX,SCY,SCZ,SX,SY,SZ,ZSB
      INTEGER I,II,IX,J,JJ,JY,K,KK,KKZ,KPOL,KZ,L,LL,LSYM,MM,MM1,MM2,MM3,   &
              MX,MY,N,N1,N12,N13,N2,N22,N23,SUB_BLOCK1,SUB_BLOCK2,NCB,     &
              NCB1,NJ,NMAX,NN,NN1,NN2,NSMR,NXMAX,NXS,NYMAX,NYS,NZMAX,NZS
!
      COMPLEX GSB2(NSMR/3,3)
      COMPLEX G(NMAX,N)
      INTEGER NX1(SUB_BLOCK1),NY1(SUB_BLOCK1),NZ1(SUB_BLOCK1),             &
              NCELL1(SUB_BLOCK1),NX2(SUB_BLOCK2),NY2(SUB_BLOCK2),          &
              NZ2(SUB_BLOCK2),NCELL2(SUB_BLOCK2)
      REAL  X1(NXMAX,SUB_BLOCK1),Y1(NYMAX,SUB_BLOCK1),Z1(NZMAX,SUB_BLOCK1), &
            X2(NXMAX,SUB_BLOCK2),Y2(NYMAX,SUB_BLOCK2),Z2(NZMAX,SUB_BLOCK2)
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
      DO I=1,N
         DO J=1,NJ
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      NCB=0
      DO L=1,SUB_BLOCK1
         IF (L>1) NCB=NCB+NCELL1(L-1)
! ---- Note that here k is the out-loop which may save some time in
!    array reference in identifying elements from GSB2
         DO K=1,NZ1(L)
!
! --- Locate the z-level of the field cell in the super block
!
            KZ=INT((Z1(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
            DO I=1,NX1(L)
               DO J=1,NY1(L)
                  NN=((I-1)*NY1(L)+(J-1))*NZ1(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3+1
                  N12=NN1+1
                  N13=NN1+2
!
                  NCB1=0
                  DO LL=1,SUB_BLOCK2
                     IF (LL>1) NCB1=NCB1+NCELL2(LL-1)
                     DO KK=1,NZ2(LL)
!
! --- Locate the z'-level of the source cell in the super block
!
                        KKZ=INT((Z2(KK,LL)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                        DO II=1,NX2(LL)
                           DO JJ=1,NY2(LL)
                              N2=((II-1)*NY2(LL)+(JJ-1))*NZ2(LL)+KK+NCB1
                              NN2=(N2-1)*3+1
                              N22=NN2+1
                              N23=NN2+2
!
! --- Compute the contributions of each quarter
!
                              DO LSYM=1,4
!
                              IF (LSYM==1) THEN
                                 BX=1.
                                 BY=1.
                                 SX=1.
                                 SY=1.
                                 SZ=1.
                              END IF
                              IF (LSYM==2) THEN
                                 BX=-1.
                                 BY=1.
                              IF (KPOL==1) THEN
                                 SX=-1.
                                 SY=1.
                                 SZ=1.
                              ELSE
                                 SX=1.
                                 SY=-1.
                                 SZ=-1.
                              END IF
                              END IF
                              IF (LSYM==3) THEN
                                 BX=1.
                                 BY=-1.
                              IF (KPOL==1) THEN
                                 SX=-1.
                                 SY=1.
                                 SZ=-1.
                              ELSE
                                 SX=1.
                                 SY=-1.
                                 SZ=1.
                              END IF
                              END IF
                              IF (LSYM==4) THEN
                                 BX=-1.
                                 BY=-1.
                                 SX=1.
                                 SY=1.
                                 SZ=-1.
                              END IF
!
! --- Identify the relative cell location in the super blocks
!
!   Note that reciprocity is considered here
!
                              IF (KZ<=KKZ) THEN
                                 DX=(BX*X2(II,LL)-X1(I,L))/SCX
                              ELSE
                                 DX=(X1(I,L)-BX*X2(II,LL))/SCX
                              END IF
                              IF (DX>=0) IX=INT(DX+.2)+1
                              IF (DX<0) IX=INT(DX-.2)-1
                              IF (IX==-1) IX=1
!
                              IF (KZ<=KKZ) THEN
                                 DY=(BY*Y2(JJ,LL)-Y1(J,L))/SCY
                              ELSE
                                 DY=(Y1(J,L)-BY*Y2(JJ,LL))/SCY
                              END IF
                              IF (DY>=0) JY=INT(DY+.2)+1
                              IF (DY<0) JY=INT(DY-.2)-1
                              IF (JY==-1) JY=1
!
! --- Determine the values of the scattering matrix using the
!   symmetry properties of the Green's functions
!
!      IF(KZ<=KKZ) THEN
!           MZ=KKZ
!         ELSE
!           MZ=KZ
!       END IF
!
                              IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
!
! --- Note that the order of the array GSB2 determined in the
!   routine GSB is different from that of the scattering matrix
!   formed here in this routine.  Check the routine GSB for
!   more explanations.
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM1,3)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM1,3)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM2,3)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM2,3)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)-GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)-GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)+GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)+GSB2(MM3,3)
                              END IF
                              ELSE
!
! ---  The sign of G is reversed as compared to those in
!      the routine MTRX_SPSS
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM3,1)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM3,1)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM3,2)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM3,2)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)-GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)-GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)+GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)+GSB2(MM3,3)
                              END IF
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM1,3)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM1,3)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM2,3)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM2,3)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)-GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)-GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)+GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)+GSB2(MM3,3)
                              END IF
                              ELSE
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM3,1)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM3,1)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM3,2)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM3,2)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)-GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)-GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)+GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)+GSB2(MM3,3)
                              END IF
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM1,3)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM1,3)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM2,3)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM2,3)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)+GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)+GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              END IF
                              ELSE
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM3,1)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM3,1)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM3,2)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM3,2)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)+GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)-GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)-GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)+GSB2(MM3,3)
                              END IF
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM1,3)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM1,2)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM1,3)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM2,3)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM2,1)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM2,3)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)-GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)+GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM3,1)
                              G(N12,N23)=G(N12,N23)-GSB2(MM3,2)
                              G(N13,N23)=G(N13,N23)+GSB2(MM3,3)
                              END IF
                              ELSE
!
                              IF (SX>0.) THEN
                              G(NN1,NN2)=G(NN1,NN2)-GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)+GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)-GSB2(MM3,1)
                              ELSE
                              G(NN1,NN2)=G(NN1,NN2)+GSB2(MM1,1)
                              G(N12,NN2)=G(N12,NN2)-GSB2(MM2,1)
                              G(N13,NN2)=G(N13,NN2)+GSB2(MM3,1)
                              END IF
                              IF (SY>0.) THEN
                              G(NN1,N22)=G(NN1,N22)+GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)-GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)+GSB2(MM3,2)
                              ELSE
                              G(NN1,N22)=G(NN1,N22)-GSB2(MM1,2)
                              G(N12,N22)=G(N12,N22)+GSB2(MM2,2)
                              G(N13,N22)=G(N13,N22)-GSB2(MM3,2)
                              END IF
                              IF (SZ>0.) THEN
                              G(NN1,N23)=G(NN1,N23)-GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)+GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)-GSB2(MM3,3)
                              ELSE
                              G(NN1,N23)=G(NN1,N23)+GSB2(MM1,3)
                              G(N12,N23)=G(N12,N23)-GSB2(MM2,3)
                              G(N13,N23)=G(N13,N23)+GSB2(MM3,3)
                              END IF
                              END IF
!
                              END IF
!
                              END DO
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!
      SUBROUTINE MTRX_SPS1B(NMAX,N,NXMAX,NYMAX,NZMAX,NX,NY,NZ,           &
                            NSUBCM,SUB_BLOCK,X,Y,Z,CLX,CLY,CLZ,CDB,G,    &
                            FRQ,MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,NZSR,  &
                            ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,        &
                            RRG3,NRG3,GRHF3,GRHO0,GRHO03,CLMN,KCLMN,     &
                            BLMIN,KACC,KUTCRP)
!
!**** Form the scattering matrix of a single block structure using
!   spatial symmetry reductions
!
!   This routine is for one single block only.  This may be
!   useful if the whole structure is not divided into equal-
!   size cells but there is a substructure or more that
!   consists of only one block.  Note that the design of this
!   routine is completely different from the design of other
!   routines like MTRX_SPS and MTRX_SPSS.  Here no extra memory is
!   required.
!
!   The parameter kself controls if the computation for the
!   integration of the primary part of the Green's function
!   for self-cells should be repeated. As the dimensions of
!   the cells within a block is the same, this integration
!   need to be done only once (kself=1) for cells located in
!   the same layer.   The results are stored in a common
!   block in geprm for use for all other cells in this block
!   (kself=0)
!
!Input parameters:
!
!
!
!  All other parameters FRQ, MLAYER, ZBND,  CDH, HVK, NZOB, ZOBG,
!  NZSR, ZSRG, RHOMIN, DMIN, NHFILM, RRG, NRG, GRHF,
!  GRHF3, GRHO0, GRHO03, CLMN, KCLMN, BLMIN, KACC, and KUTCRP are to
!  be passed into routine THR_D_GREEN.  Check THR_D_GREEN for their
!  descriptions.
!
!
!Output parameters:
!
!  G:
!
!
!**** Called by: MAIN_MATRICES
!
!**** Calls:     THR_D_GREEN
!
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN,CLX1,CLY1,CLZ1,DMIN,DX,DY,FRQ,RHOMIN
      INTEGER I,II,IOB,ISR,IX,J,JJ,JY,K,KACC,KCLMN,KEYG,KK,KSELF,KUTCRP,   &
              L,LL,MLAYER,MM,MM1
      INTEGER MM2,MX,MY,MZ,N,N1,N2,SUB_BLOCK,NCB,NCB1,NHFILM,NMAX,NN,NN1,  &
              NN2,NOB,NOB1,NRG,NRG3,NSR
      INTEGER NSUBCM,NXMAX,NYMAX,NZMAX,NZOB,NZSR
!
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,               &
              CDH(0:MLAYER),CDV(0:MLAYER),                                 &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV,                           &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),                &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),      &
            CLX(SUB_BLOCK),CLY(SUB_BLOCK),CLZ(SUB_BLOCK),                  &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),                       &
            ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      KEYG=1
!
! ******  SUB_BLOCK=1 FOR THE TIME BEING!!
      IF (SUB_BLOCK>1) THEN
         STOP 'SUB_BLOCK>1 !!'
      END IF
!
      L=1
      NCB=0
      DO K=1,NZ(L)
         DO IOB=MLAYER-1,0,-1
            IF (Z(K,L)>=ZBND(IOB)) THEN
               NOB=IOB+1
               GOTO 50
            END IF
         END DO
         NOB=0
   50    IF (L==1.AND.K==1) NOB1=NOB
!
         LL=1
         NCB1=0
         DO KK=1,NZ(LL)
!
! --- RECIPROCITY CONSIDERATIONS
!
            IF (KK<=K) THEN
!
               DO ISR=MLAYER-1,0,-1
                  IF (Z(KK,LL)>=ZBND(ISR)) THEN
                     NSR=ISR+1
                     GOTO 60
                  END IF
               END DO
               NSR=0
!
   60          DO I=1,NX(L)
                  DO J=1,NY(L)
                     NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                     N1=NN+NCB
                     NN1=(N1-1)*3+1
!
! ---- KSELF CONTROLS IF THE CALCULATION FOR THE SELF-CELLS
!    SHOULD BE REPEATED
!
! THIS PART MAY BE DISABLED FOR TEST PUPPOSE IN ORDER TO MATCH
! THE THEORETICAL REDUCTION MTRX_SLV_FACTOR
!
! ---- KSELF controls if the calculation for the self-cells
!    should be repeated
                     IF (I==1.AND.J==1.AND.K==1.OR.NOB1/=NOB.OR.  &
                         NOB1/=NSR) THEN
                        KSELF=1
                     ELSE
                        KSELF=0
                     END IF
!
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
!
                           N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)+KK+NCB1
                           NN2=(N2-1)*3+1
                           CLX1=CLX(LL)
                           CLY1=CLY(LL)
                           CLZ1=CLZ(LL)
!
                           IF (I==1.AND.J==1) THEN
!
                              IF (II==1.AND.JJ==1) MM1=NN1
!
                              PSTION(1)=X(I,L)
                              PSTION(2)=Y(J,L)
                              PSTION(3)=Z(K,L)
                              PSTION(4)=X(II,LL)
                              PSTION(5)=Y(JJ,LL)
                              PSTION(6)=Z(KK,LL)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX1,CLY1,CLZ1,     &
                                 CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                                 ECOMP,HCOMP)
!
                              G(NN1,NN2)=-EXX
                              G(NN1+1,NN2+1)=-EYY
                              G(NN1+2,NN2+2)=-EZZ
                              G(NN1+1,NN2)=-EYX
                              G(NN1+2,NN2)=-EZX
                              G(NN1,NN2+1)=-EXY
                              G(NN1+2,NN2+1)=-EZY
                              G(NN1,NN2+2)=-EXZ
                              G(NN1+1,NN2+2)=-EYZ
!
                              CYCLE
!
                           END IF
!
                           DX=(X(II,LL)-X(I,L))/CLX1
!     FOR STABILITY
                           IF (DX>=0) IX=INT(DX+.2)+1
                           IF (DX<0) IX=INT(DX-.2)-1
                           IF (IX==-1) IX=1
!
                           DY=(Y(JJ,LL)-Y(J,L))/CLY1
!     FOR STABILITY
                           IF (DY>=0) JY=INT(DY+.2)+1
                           IF (DY<0) JY=INT(DY-.2)-1
                           IF (JY==-1) JY=1
!
                           IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
                              MZ=KK
!
                              MM=(MX-1)*NY(L)*NZ(L)+(MY-1)*NZ(L)+MZ
                              MM2=(MM-1)*3+1
!
                              G(NN1,NN2)=G(MM1,MM2)
                              G(NN1+1,NN2)=G(MM1+1,MM2)
                              G(NN1+2,NN2)=G(MM1+2,MM2)
                              G(NN1,NN2+1)=G(MM1,MM2+1)
                              G(NN1+1,NN2+1)=G(MM1+1,MM2+1)
                              G(NN1+2,NN2+1)=G(MM1+2,MM2+1)
                              G(NN1,NN2+2)=G(MM1,MM2+2)
                              G(NN1+1,NN2+2)=G(MM1+1,MM2+2)
                              G(NN1+2,NN2+2)=G(MM1+2,MM2+2)
!
                           END IF
!
                           IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!              NOT K !!
                              MZ=KK
!
                              MM=(MX-1)*NY(L)*NZ(L)+(MY-1)*NZ(L)+MZ
                              MM2=(MM-1)*3+1
!
                              G(NN1,NN2)=G(MM1,MM2)
                              G(NN1+1,NN2)=-G(MM1+1,MM2)
                              G(NN1+2,NN2)=-G(MM1+2,MM2)
                              G(NN1,NN2+1)=-G(MM1,MM2+1)
                              G(NN1+1,NN2+1)=G(MM1+1,MM2+1)
                              G(NN1+2,NN2+1)=G(MM1+2,MM2+1)
                              G(NN1,NN2+2)=-G(MM1,MM2+2)
                              G(NN1+1,NN2+2)=G(MM1+1,MM2+2)
                              G(NN1+2,NN2+2)=G(MM1+2,MM2+2)
!
                           END IF
!
                           IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!              NOT K !!
                              MZ=KK
!
                              MM=(MX-1)*NY(L)*NZ(L)+(MY-1)*NZ(L)+MZ
                              MM2=(MM-1)*3+1
!
                              G(NN1,NN2)=G(MM1,MM2)
                              G(NN1+1,NN2)=G(MM1+1,MM2)
                              G(NN1+2,NN2)=-G(MM1+2,MM2)
                              G(NN1,NN2+1)=G(MM1,MM2+1)
                              G(NN1+1,NN2+1)=G(MM1+1,MM2+1)
                              G(NN1+2,NN2+1)=-G(MM1+2,MM2+1)
                              G(NN1,NN2+2)=-G(MM1,MM2+2)
                              G(NN1+1,NN2+2)=-G(MM1+1,MM2+2)
                              G(NN1+2,NN2+2)=G(MM1+2,MM2+2)
!
                           END IF
!
                           IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!              NOT K !!
                              MZ=KK
!
                              MM=(MX-1)*NY(L)*NZ(L)+(MY-1)*NZ(L)+MZ
                              MM2=(MM-1)*3+1

                              G(NN1,NN2)=G(MM1,MM2)
                              G(NN1+1,NN2)=-G(MM1+1,MM2)
                              G(NN1+2,NN2)=G(MM1+2,MM2)
                              G(NN1,NN2+1)=-G(MM1,MM2+1)
                              G(NN1+1,NN2+1)=G(MM1+1,MM2+1)
                              G(NN1+2,NN2+1)=-G(MM1+2,MM2+1)
                              G(NN1,NN2+2)=G(MM1,MM2+2)
                              G(NN1+1,NN2+2)=-G(MM1+1,MM2+2)
                              G(NN1+2,NN2+2)=G(MM1+2,MM2+2)
!
                           END IF
!
                        END DO
                     END DO
                  END DO
               END DO
            END IF
!
         END DO
      END DO
!
! ---  RECIPROCITY
!
      L=1
      LL=1
      NCB=0
      NCB1=0
!
      DO K=1,NZ(L)
!
         DO KK=1,NZ(LL)
!
            IF (KK>K) THEN
!
               DO I=1,NX(L)
                  DO J=1,NY(L)
                     NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                     N1=NN+NCB
                     NN1=(N1-1)*3+1
!
                     DO II=1,NX(LL)
                        DO JJ=1,NY(LL)
                           N2=(II-1)*NY(LL)*NZ(LL)+(JJ-1)*NZ(LL)+KK+NCB1
                           NN2=(N2-1)*3+1
!
                           G(NN1,NN2)=G(NN2,NN1)
                           G(NN1+1,NN2)=G(NN2,NN1+1)
                           G(NN1+2,NN2)=G(NN2,NN1+2)
                           G(NN1,NN2+1)=G(NN2+1,NN1)
                           G(NN1+1,NN2+1)=G(NN2+1,NN1+1)
                           G(NN1+2,NN2+1)=G(NN2+1,NN1+2)
                           G(NN1,NN2+2)=G(NN2+2,NN1)
                           G(NN1+1,NN2+2)=G(NN2+2,NN1+1)
                           G(NN1+2,NN2+2)=G(NN2+2,NN1+2)
!
                        END DO
                     END DO
                  END DO
               END DO
            END IF
!
         END DO
      END DO

! --- Add the term of cell conductivity to the celf cells
!
      NCB=0
      L=1
!
      DO K=1,NZ(L)
         DO IOB=MLAYER-1,0,-1
            IF (Z(K,L)>=ZBND(IOB)) THEN
               NOB=IOB+1
               GOTO 100
            END IF
         END DO
         NOB=0
!
  100    DO I=1,NX(L)
            DO J=1,NY(L)
!
               NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
               N1=NN+NCB
               NN1=(N1-1)*3+1
!
               DELTH=CDB(NN,L)-CDH(NOB)
               DELTV=CDB(NN,L)-CDV(NOB)
!
               G(NN1,NN1)=1./DELTH+G(NN1,NN1)
               G(NN1+1,NN1+1)=1./DELTH+G(NN1+1,NN1+1)
               G(NN1+2,NN1+2)=1./DELTV+G(NN1+2,NN1+2)
!
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!**** End of MTRX_SPS1B
!
!
      SUBROUTINE MTRX_GS(KSMR,NSMR,NXS,NYS,NZS,SBX,SBY,SBZ,ZSB,          &
                         KS,KDIAG,N,N2,CLX,CLY,CLZ,XSR,YSR,ZSR,          &
                         NMAX,NXMAX,NYMAX,NZMAX,NX,NY,NZ,NCELL,          &
                         NSUBCM,SUB_BLOCK,X,Y,Z,CDB,G,GSB2,              &
                         FRQ,MLAYER,ZBND,CDH,CDV,HVK,NZOB,ZOBG,NZSR,     &
                         ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,           &
                         RRG3,NRG3,GRHF3,GRHO0,GRHO03,CLMN,KCLMN,        &
                         BLMIN,KACC,KUTCRP)
!
!****  Compute the column matrices of the submatrices of the four
!  block matrices obtained by group theoretical reduction
!
!  Three columns for each field cell in the four block matrices
!  are computed at a time
!
!  The parameter KDIAG controls whether the diagonal or off-
!  diagonal submatrices are computed. KDIAG=1: diagonal;
!  =0, off-diagonal.
!
!  The parameter KS controls if the matrices are symmetric.
!  If so, only half of the elements will be computed.  The rests
!  will be determined in the main program.  In case that system
!  iteration is applied, however, the symmetry of the block
!  matrices will not used in forming the matrices except for
!  the diagonal submatrices.  The use of symmetry will save
!  some computer time for the block diagonalization.  The
!  use of symmetry in the actual computation of the Green's
!  functions has been considered in the spatial symmetry
!  reduction already.  The use of symmetry here will save
!  the total computation time by about 10 percent.
!
!  The parameter kself controling the computation for the
!  integration of the primary part of the Green's function
!  for self-cells as in other routines like smtrx1m is dropped
!  since one loop is move to the main program.
!
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN,CLX,CLY,CLZ,DMIN,DX,DY,FRQ,RHOMIN,SBX,SBY,SBZ,SCX,  &
           SCY,SCZ,XOB1,XSR,XSR1,YOB1
      REAL YSR,YSR1,ZSB,ZSR
      INTEGER I,II,II1,II2,II3,IOB,IX,J,JJ,JJ1,JJ2,JJ3,JY,K,KACC,KCLMN,   &
              KDIAG,KEYG,KKZ,KS
      INTEGER KSELF,KSMR,KUTCRP,KZ,L,LQ,LQC,LQR,MLAYER,MM,MM1,MM2,MM3,    &
              MX,MY,N,N1,N2,SUB_BLOCK,NCB
      INTEGER NHFILM,NMAX,NN,NN1,NOB,NQ,NQC,NQR,NRG,NRG3,NSMR,NSUBCM,     &
              NXMAX,NXS,NYMAX,NYS,NZMAX,NZOB,NZS,NZSR
!
      COMPLEX GSB2(NSMR/3,3)
!
!  -- Note that G in this routine is defined differently from other routines.
!     It is the columns for 4 symmetric cells.
      COMPLEX G(NMAX,N),EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,              &
              CDH(0:MLAYER),CDV(0:MLAYER),                                &
              CDB(NSUBCM,SUB_BLOCK),DELTH,DELTV,                          &
              GE(12,12),AA(3,3),                                          &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),               &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),     &
            BX(4),BY(4),ZBND(0:MLAYER),HVK(0:MLAYER),UR(3),UC(3,4),       &
            ZOBG(NZOB),ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(8)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ)
!
      DATA BX /-1., 1.,1.,-1./
      DATA BY /-1.,-1.,1., 1./
!
      KEYG=1
!
! --- Compute the cell dimension of the super block
!
      IF (KSMR==1) THEN
         SCX=SBX/NXS
         SCY=SBY/NYS
         SCZ=SBZ/NZS
      END IF
!
! --- KSELF set to be 1
!
      KSELF=1
!
      DO I=1,N
         DO J=1,NMAX
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      IF (KSMR==1) THEN
!
! --- Locate the z'-level of the source cell in the super block
!
!   Note that the source cells are the out loop here.  Thus
!   the design of the program is slightly different from
!   the designs in routines MTRX_SPSS etc.
!
         KKZ=INT((ZSR+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
      END IF
!
      NCB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NCB=NCB+NCELL(L-1)
         DO K=1,NZ(L)
!
            IF (KSMR==1) THEN
!
! --- Locate the z-level of the field cell in the super block
!
!   Note that the source cells are the out loop here.  Thus
!   the design of the program is slightly different from
!   the designs in routines MTRX_SPSS etc.
!
               KZ=INT((Z(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
            END IF
!
            IF (KDIAG==1) THEN
               DO IOB=MLAYER-1,0,-1
                  IF (Z(K,L)>=ZBND(IOB)) THEN
                     NOB=IOB+1
                     GOTO 20
                  END IF
               END DO
               NOB=0
            END IF
!
   20       DO I=1,NX(L)
               DO J=1,NY(L)
                  NN=((I-1)*NY(L)+(J-1))*NZ(L)+K
                  N1=NN+NCB
                  NN1=(N1-1)*3
!
! --- For symmetric matrices only the upper triangles need to
!   be computed
!
                  IF (KS/=1.OR.N1>=N2) THEN
!
                     IF (KDIAG==1.AND.N1==N2) THEN
                        DELTH=CDB(NN,L)-CDH(NOB)
                        DELTV=CDB(NN,L)-CDV(NOB)
                     END IF
!
! --- Compute the elements for the 4 quarters
!
                     DO LQC=1,4
                        JJ=3*(LQC-1)
                        JJ1=JJ+1
                        JJ2=JJ+2
                        JJ3=JJ+3
                        IF (BX(LQC)>0.) THEN
                           XSR1=XSR
                        ELSE
                           XSR1=-XSR
                        END IF
                        IF (BY(LQC)>0.) THEN
                           YSR1=YSR
                        ELSE
                           YSR1=-YSR
                        END IF
!
                        DO LQR=1,4
                           II=3*(LQR-1)
                           II1=II+1
                           II2=II+2
                           II3=II+3
                           IF (BX(LQR)>0.) THEN
                              XOB1=X(I,L)
                           ELSE
                              XOB1=-X(I,L)
                           END IF
                           IF (BY(LQR)>0.) THEN
                              YOB1=Y(J,L)
                           ELSE
                              YOB1=-Y(J,L)
                           END IF
!
                           IF (LQC==1) THEN
!
                              IF (KSMR==0) THEN
!
                              PSTION(1)=XOB1
                              PSTION(2)=YOB1
                              PSTION(3)=Z(K,L)
                              PSTION(4)=XSR1
                              PSTION(5)=YSR1
                              PSTION(6)=ZSR
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX,CLY,CLZ,        &
                                 CLMN,KCLMN,BLMIN,KACC,KUTCRP,KSELF,         &
                                 ECOMP,HCOMP)
!
                              GE(II1,JJ1)=-EXX
                              GE(II2,JJ1)=-EYX
                              GE(II3,JJ1)=-EZX
                              GE(II1,JJ2)=-EXY
                              GE(II2,JJ2)=-EYY
                              GE(II3,JJ2)=-EZY
                              GE(II1,JJ3)=-EXZ
                              GE(II2,JJ3)=-EYZ
                              GE(II3,JJ3)=-EZZ
!
                              CYCLE
!
                              END IF
!
! --- Evaluate the Green's functions by means of spatial symmetry
!   using pre-computed results
!
! --- Identify the relative cell location in the super blocks
!
!   Note that reciprocity is considered here
!
                              IF (KZ<=KKZ) THEN
                              DX=(XSR1-XOB1)/SCX
                              ELSE
                              DX=(XOB1-XSR1)/SCX
                              END IF
                              IF (DX>=0) IX=INT(DX+.2)+1
                              IF (DX<0) IX=INT(DX-.2)-1
                              IF (IX==-1) IX=1
!
                              IF (KZ<=KKZ) THEN
                              DY=(YSR1-YOB1)/SCY
                              ELSE
                              DY=(YOB1-YSR1)/SCY
                              END IF
                              IF (DY>=0) JY=INT(DY+.2)+1
                              IF (DY<0) JY=INT(DY-.2)-1
                              IF (JY==-1) JY=1
!
! --- Determine the values of the scattering matrix using the
!   symmetry properties of the Green's functions
!
!      IF(KZ<=KKZ) THEN
!           MZ=KKZ
!         ELSE
!           MZ=KZ
!       END IF
!
                              IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
!
! --- Note that the order of the array GSB2 determined in the
!   routine GSB is different from that of the scattering matrix
!   formed here in this routine.  Check the routine GSB for
!   more explanations.
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM1,2)
                              GE(II3,JJ1)=GSB2(MM1,3)
                              GE(II1,JJ2)=GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM2,3)
                              GE(II1,JJ3)=GSB2(MM3,1)
                              GE(II2,JJ3)=GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM2,1)
                              GE(II3,JJ1)=GSB2(MM3,1)
                              GE(II1,JJ2)=GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM3,2)
                              GE(II1,JJ3)=GSB2(MM1,3)
                              GE(II2,JJ3)=GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM1,2)
                              GE(II3,JJ1)=-GSB2(MM1,3)
                              GE(II1,JJ2)=-GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM2,3)
                              GE(II1,JJ3)=-GSB2(MM3,1)
                              GE(II2,JJ3)=GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM2,1)
                              GE(II3,JJ1)=-GSB2(MM3,1)
                              GE(II1,JJ2)=-GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM3,2)
                              GE(II1,JJ3)=-GSB2(MM1,3)
                              GE(II2,JJ3)=GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM1,2)
                              GE(II3,JJ1)=-GSB2(MM1,3)
                              GE(II1,JJ2)=GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM2,3)
                              GE(II1,JJ3)=-GSB2(MM3,1)
                              GE(II2,JJ3)=-GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM2,1)
                              GE(II3,JJ1)=-GSB2(MM3,1)
                              GE(II1,JJ2)=GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM3,2)
                              GE(II1,JJ3)=-GSB2(MM1,3)
                              GE(II2,JJ3)=-GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM1,2)
                              GE(II3,JJ1)=GSB2(MM1,3)
                              GE(II1,JJ2)=-GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM2,3)
                              GE(II1,JJ3)=GSB2(MM3,1)
                              GE(II2,JJ3)=-GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM2,1)
                              GE(II3,JJ1)=GSB2(MM3,1)
                              GE(II1,JJ2)=-GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM3,2)
                              GE(II1,JJ3)=GSB2(MM1,3)
                              GE(II2,JJ3)=-GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
                           END IF
!
! --- Compute the elements of GE for LQC.NE.1 by
!   symmetry relations of the Green's functions.
!   In the following the spatial symmetry is used to
!   determine the Green's functions.  In some cases
!   the reciprocity thereom may also be used.  Note
!   that the reciprocity thereom is not always true
!   here unless the media are isotropic or the four
!   field cells and the four source cells locate in
!   a single anisotropic layer. For this reason the
!   use of the reciprocity thereom is avoid here.
!
!   The following parameters r(-i)(-j) etc. refer to
!   thos in Table 1 of Xiong and Tripp (1992)
!   (spatial symmetry reduction).
!
                           IF (LQC==1) THEN
                           ELSEIF (LQC==3) THEN
!
                              IF (LQR==2) THEN
!
! --- Equivalent to the results of r(-i)(-j).
!
!   May also use reciprocity.
!   II=3, JJ=6
                              GE(II1,JJ1)=GE(10,1)
                              GE(II2,JJ1)=GE(11,1)
                              GE(II3,JJ1)=-GE(12,1)
                              GE(II1,JJ2)=GE(10,2)
                              GE(II2,JJ2)=GE(11,2)
                              GE(II3,JJ2)=-GE(12,2)
                              GE(II1,JJ3)=-GE(10,3)
                              GE(II2,JJ3)=-GE(11,3)
!
                              GE(II3,JJ3)=GE(12,3)
                              ELSEIF (LQR==3) THEN
!
! --- Equivalent to the results of r(-i)(-j).
!
!   Note this is not a self-cell unless N1=N2.
!
!   II=JJ=6
                              GE(II1,JJ1)=GE(1,1)
                              GE(II2,JJ1)=GE(2,1)
                              GE(II3,JJ1)=-GE(3,1)
                              GE(II1,JJ2)=GE(1,2)
                              GE(II2,JJ2)=GE(2,2)
                              GE(II3,JJ2)=-GE(3,2)
                              GE(II1,JJ3)=-GE(1,3)
                              GE(II2,JJ3)=-GE(2,3)
!
                              GE(II3,JJ3)=GE(3,3)
                              ELSEIF (LQR==4) THEN
!
! --- Equivalent to the results of r(-i)(-j).
!
!   II=9, JJ=6.
                              GE(II1,JJ1)=GE(4,1)
                              GE(II2,JJ1)=GE(5,1)
                              GE(II3,JJ1)=-GE(6,1)
                              GE(II1,JJ2)=GE(4,2)
                              GE(II2,JJ2)=GE(5,2)
                              GE(II3,JJ2)=-GE(6,2)
                              GE(II1,JJ3)=-GE(4,3)
                              GE(II2,JJ3)=-GE(5,3)
!
                              GE(II3,JJ3)=GE(6,3)
                              ELSE
!
! --- Equivalent to the results of r(-i)(-j).
!   II=0, JJ=6
                              GE(II1,JJ1)=GE(7,1)
                              GE(II2,JJ1)=GE(8,1)
                              GE(II3,JJ1)=-GE(9,1)
                              GE(II1,JJ2)=GE(7,2)
                              GE(II2,JJ2)=GE(8,2)
                              GE(II3,JJ2)=-GE(9,2)
                              GE(II1,JJ3)=-GE(7,3)
                              GE(II2,JJ3)=-GE(8,3)
!
                              GE(II3,JJ3)=GE(9,3)
                              END IF
                           ELSEIF (LQC==4) THEN
!
                              IF (LQR==2) THEN
!
! --- Equivalent to  ri(-j) or the combination of
!   r(-i)j and r(-i)(-j).
!
!   II=3, JJ=9
                              GE(II1,JJ1)=GE(7,1)
                              GE(II2,JJ1)=-GE(8,1)
                              GE(II3,JJ1)=GE(9,1)
                              GE(II1,JJ2)=-GE(7,2)
                              GE(II2,JJ2)=GE(8,2)
                              GE(II3,JJ2)=-GE(9,2)
                              GE(II1,JJ3)=GE(7,3)
                              GE(II2,JJ3)=-GE(8,3)
!
                              GE(II3,JJ3)=GE(9,3)
                              ELSEIF (LQR==3) THEN
!
! --- Equivalent to the results of ri(-j).
!
!   II=6, JJ=9
                              GE(II1,JJ1)=GE(4,1)
                              GE(II2,JJ1)=-GE(5,1)
                              GE(II3,JJ1)=GE(6,1)
                              GE(II1,JJ2)=-GE(4,2)
                              GE(II2,JJ2)=GE(5,2)
                              GE(II3,JJ2)=-GE(6,2)
                              GE(II1,JJ3)=GE(4,3)
                              GE(II2,JJ3)=-GE(5,3)
!
                              GE(II3,JJ3)=GE(6,3)
                              ELSEIF (LQR==4) THEN
!
! --- Equivalent to the results of ri(-j).
!
!   Note this is not a self-cell unless N1=N2.
!
!   II=JJ=9
                              GE(II1,JJ1)=GE(1,1)
                              GE(II2,JJ1)=-GE(2,1)
                              GE(II3,JJ1)=GE(3,1)
                              GE(II1,JJ2)=-GE(1,2)
                              GE(II2,JJ2)=GE(2,2)
                              GE(II3,JJ2)=-GE(3,2)
                              GE(II1,JJ3)=GE(1,3)
                              GE(II2,JJ3)=-GE(2,3)
                              GE(II3,JJ3)=GE(3,3)
                              ELSE
!
! --- Equivalent to the results of ri(-j).
!
!   II=0, JJ=9.
                              GE(II1,JJ1)=GE(10,1)
                              GE(II2,JJ1)=-GE(11,1)
                              GE(II3,JJ1)=GE(12,1)
                              GE(II1,JJ2)=-GE(10,2)
                              GE(II2,JJ2)=GE(11,2)
                              GE(II3,JJ2)=-GE(12,2)
                              GE(II1,JJ3)=GE(10,3)
                              GE(II2,JJ3)=-GE(11,3)
!
                              GE(II3,JJ3)=GE(12,3)
                              END IF
!
                           ELSEIF (LQR==2) THEN
!
! --- Equivalent to the results of r(-i)j.
!
!   Note this is not a self-cell unless N1=N2.
!
!   II=JJ=3
                              GE(II1,JJ1)=GE(1,1)
                              GE(II2,JJ1)=-GE(2,1)
                              GE(II3,JJ1)=-GE(3,1)
                              GE(II1,JJ2)=-GE(1,2)
                              GE(II2,JJ2)=GE(2,2)
                              GE(II3,JJ2)=GE(3,2)
                              GE(II1,JJ3)=-GE(1,3)
                              GE(II2,JJ3)=GE(2,3)
!
                              GE(II3,JJ3)=GE(3,3)
                           ELSEIF (LQR==3) THEN
!
! --- Equivalent to the results of r(-i)j.
!
!   II=6, JJ=3
                              GE(II1,JJ1)=GE(10,1)
                              GE(II2,JJ1)=-GE(11,1)
                              GE(II3,JJ1)=-GE(12,1)
                              GE(II1,JJ2)=-GE(10,2)
                              GE(II2,JJ2)=GE(11,2)
                              GE(II3,JJ2)=GE(12,2)
                              GE(II1,JJ3)=-GE(10,3)
                              GE(II2,JJ3)=GE(11,3)
!
                              GE(II3,JJ3)=GE(12,3)
                           ELSEIF (LQR==4) THEN
!
! --- Equivalent to r(-i)j or the combination of
!   ri(-j) and r(-i)(-j).
!   II=9, JJ=3
                              GE(II1,JJ1)=GE(7,1)
                              GE(II2,JJ1)=-GE(8,1)
                              GE(II3,JJ1)=-GE(9,1)
                              GE(II1,JJ2)=-GE(7,2)
                              GE(II2,JJ2)=GE(8,2)
                              GE(II3,JJ2)=GE(9,2)
                              GE(II1,JJ3)=-GE(7,3)
                              GE(II2,JJ3)=GE(8,3)
!
                              GE(II3,JJ3)=GE(9,3)
                           ELSE
!
! --- Equivalent to the results of r(-i)j.
!
!   In the following 9 lines II=0, JJ=3
                              GE(II1,JJ1)=GE(4,1)
                              GE(II2,JJ1)=-GE(5,1)
                              GE(II3,JJ1)=-GE(6,1)
                              GE(II1,JJ2)=-GE(4,2)
                              GE(II2,JJ2)=GE(5,2)
                              GE(II3,JJ2)=GE(6,2)
                              GE(II1,JJ3)=-GE(4,3)
                              GE(II2,JJ3)=GE(5,3)
!
                              GE(II3,JJ3)=GE(6,3)
                           END IF
!
                        END DO
                     END DO
!
! --- Add the conductivity term
!
                     IF (N1==N2.AND.KDIAG==1) THEN
                        DO LQR=1,4
                           II=3*(LQR-1)
                           GE(II1,II1)=1./DELTH+GE(II1,II1)
                           GE(II2,II2)=1./DELTH+GE(II2,II2)
                           GE(II3,II3)=1./DELTV+GE(II3,II3)
                        END DO
                     END IF
!
! --- Transform the above elements of the scattering matrix
!   by the unitary matrix, U*Z*UT
!
!   Note that the total number of cells in one quarter and
!   the cell number as required by the parameters PMAX, PR
!   and PC in the routine unitary are not important here
!   as long as PR=PC, since the parameters IROW and JCOL
!   are of no use in the routine
!
!-- The loop LQ controls the contributions to the four
!   block matrices.  To test the validity of the block
!   diagonalization as well as the code, i.e., the off
!   diagonal matrices are zero, just change the loop LQ
!   into two loops, as
!     DO 28 LQ1=1,4
!     DO 28 LQ2=1,4  ,
!   call MTRX_UNITARY in the loop LQR like
!     CALL MTRX_UNITARY (1,LQ1,II,1,LQR,II,UR(II)) ,
!   and call MTRX_UNITARY in the loop LQC like
!     CALL MTRX_UNITARY (1,LQ2,JJ,1,LQR,JJ,UC(JJ)) ,
!   then the following sum should be zero for LQ1.NE.LQ2
!
                     DO LQ=1,4
                        NQ=3*(LQ-1)
!
                        DO II=1,3
                           DO JJ=1,3
                              AA(JJ,II)=(0.,0.)
                           END DO
                        END DO
!
                        DO LQR=1,4
                           NQR=3*(LQR-1)
                           DO II=1,3
! --               PMAX=1
                              CALL MTRX_UNITARY(1,LQ,II,1,LQR,II,UR(II))
                           END DO
                           DO LQC=1,4
                              NQC=3*(LQC-1)
                              IF (LQR==1) THEN
                              DO JJ=1,3
! --                 PMAX=1
                              CALL MTRX_UNITARY(1,LQ,JJ,1,LQC,JJ,UC(JJ,LQC))
                              END DO
                              END IF
!
                              DO JJ=1,3
                              DO II=1,3
!
! --- The following may be simply designed as
!
!      G(NN1+II,NQ+JJ)=G(NN1+II,NQ+JJ)+
!   +                  UR(II)*GE(NQR+II,NQC+JJ)*UC(JJ,LQC)
!
!   The following designed is intended to reduce computation
!   time by avoiding multipications.  Not that the values of
!   UR and UC are either +.5 or -.5
!
                              IF (UR(II)<0) THEN
                              IF (UC(JJ,LQC)>=0) THEN
                              GOTO 22
                              END IF
                              ELSEIF (UC(JJ,LQC)<=0) THEN
                              GOTO 22
                              END IF
!
                              AA(II,JJ)=AA(II,JJ)+GE(NQR+II,NQC+JJ)
                              CYCLE
   22                         AA(II,JJ)=AA(II,JJ)-GE(NQR+II,NQC+JJ)
!
                              END DO
                              END DO
                           END DO
                        END DO
!
                        DO JJ=1,3
                           DO II=1,3
                              G(NN1+II,NQ+JJ)=.25*AA(II,JJ)
                           END DO
                        END DO
!
                     END DO
                  END IF
!
               END DO
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!**** End of MTRX_GS
!
!
      SUBROUTINE MTRX_SMRGS(NXS,NYS,NZS,SBX,SBY,SBZ,ZSB,NMAX,NXMAX,     &
                            NYMAX,NZMAX,NETI,SUB_BLOCKI,NCELLI,XCELLI,  &
                            YCELLI,ZCELLI,NXI,NYI,NZI,NET,SUB_BLOCK,    &
                            NCELL,NX,NY,NZ,X,Y,Z,LQ,G,NSMR,GSB2)
!
!**** Compute the submatrices of one of the four block matrices
!   obtained by group theoretical reduction using spatial
!   symmetry relations
!
!   This routine differs from smtrxgs in that the full matrix
!   is computed for one quadrant.   And the signs of the matrix
!   elements are reversed here in this routine,  instead of in
!   the main program
!
      IMPLICIT NONE
!
      REAL DX,DY,SBX,SBY,SBZ,SCX,SCY,SCZ,XOB1,XSR1,YOB1,YSR1,ZSB
      INTEGER I,II,II1,II2,II3,IL,IX,J,JJ,JJ1,JJ2,JJ3,JL,JY,K,KK,KKZ,KZ,   &
              L,LL,LQ,LQC,LQR,MM,MM1,MM2,MM3,MX,MY,N1,N2,SUB_BLOCK,        &
              SUB_BLOCKI,NCB,NCBI,NET,NETI,NMAX,NN,NN1
      INTEGER NN2,NQC,NQR,NSMR,NXMAX,NXS,NYMAX,NYS,NZMAX,NZS
!
      COMPLEX GSB2(NSMR/3,3)
      COMPLEX G(NMAX,NETI),GE(12,12),AA(3,3)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK),   &
              NXI(SUB_BLOCKI),NYI(SUB_BLOCKI),NZI(SUB_BLOCKI),              &
              NCELLI(SUB_BLOCKI)
      REAL  X(NXMAX,SUB_BLOCK),Y(NYMAX,SUB_BLOCK),Z(NZMAX,SUB_BLOCK),       &
            XCELLI(NXMAX,SUB_BLOCKI),YCELLI(NYMAX,SUB_BLOCKI),              &
            ZCELLI(NZMAX,SUB_BLOCKI),                                       &
            BX(4),BY(4),UR(3),UC(3,4)
!
      DATA BX /-1., 1.,1.,-1./
      DATA BY /-1.,-1.,1., 1./
!
! --- Compute the cell dimension of the super block
!
      SCX=SBX/NXS
      SCY=SBY/NYS
      SCZ=SBZ/NZS
!
      DO I=1,NETI
         DO J=1,NET
            G(J,I)=(0.,0.)
         END DO
      END DO
!
      NCBI=0
      DO LL=1,SUB_BLOCKI
         IF (LL>1) NCBI=NCBI+NCELLI(LL-1)
         DO IL=1,NXI(LL)
            DO JL=1,NYI(LL)
               DO KK=1,NZI(LL)
!
                  N2=((IL-1)*NYI(LL)+(JL-1))*NZI(LL)+KK+NCBI
                  NN2=(N2-1)*3
!
! --- Locate the z'-level of the source cell in the super block
!

!   Note that the source cells are the out loop here.  Thus
!   the design of the program is slightly different from
!   the designs in routines MTRX_SPSS etc.
!
                  KKZ=INT((ZCELLI(KK,LL)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                  NCB=0
                  DO L=1,SUB_BLOCK
                     IF (L>1) NCB=NCB+NCELL(L-1)
                     DO K=1,NZ(L)
!
! --- Locate the z-level of the field cell in the super block
!
!   Note that the source cells are the out loop here.  Thus
!   the design of the program is slightly different from
!   the designs in routines MTRX_SPSS etc.
!
                        KZ=INT((Z(K,L)+.5*SCZ-(ZSB-.5*SBZ))/SCZ+.2)
!
                        DO I=1,NX(L)
                           DO J=1,NY(L)
                              NN=((I-1)*NY(L)+(J-1))*NZ(L)+K
                              N1=NN+NCB
                              NN1=(N1-1)*3
!
! --- Compute the elements for the 4 quarters
!
                              DO LQC=1,4
                              JJ=3*(LQC-1)
                              JJ1=JJ+1
                              JJ2=JJ+2
                              JJ3=JJ+3
                              IF (BX(LQC)>0.) THEN
                              XSR1=XCELLI(IL,LL)
                              ELSE
                              XSR1=-XCELLI(IL,LL)
                              END IF
                              IF (BY(LQC)>0.) THEN
                              YSR1=YCELLI(JL,LL)
                              ELSE
                              YSR1=-YCELLI(JL,LL)
                              END IF
!
                              DO LQR=1,4
                              II=3*(LQR-1)
                              II1=II+1
                              II2=II+2
                              II3=II+3
                              IF (BX(LQR)>0.) THEN
                              XOB1=X(I,L)
                              ELSE
                              XOB1=-X(I,L)
                              END IF
                              IF (BY(LQR)>0.) THEN
                              YOB1=Y(J,L)
                              ELSE
                              YOB1=-Y(J,L)
                              END IF
!
                              IF (LQC==1) THEN
!
! --- Evaluate the Green's functions by means of spatial symmetry
!   using pre-computed results
!
! --- Identify the relative cell location in the super blocks
!
!   Note that reciprocity is considered here
!
                              IF (KZ<=KKZ) THEN
                              DX=(XSR1-XOB1)/SCX
                              ELSE
                              DX=(XOB1-XSR1)/SCX
                              END IF
                              IF (DX>=0) IX=INT(DX+.2)+1
                              IF (DX<0) IX=INT(DX-.2)-1
                              IF (IX==-1) IX=1
!
                              IF (KZ<=KKZ) THEN
                              DY=(YSR1-YOB1)/SCY
                              ELSE
                              DY=(YOB1-YSR1)/SCY
                              END IF
                              IF (DY>=0) JY=INT(DY+.2)+1
                              IF (DY<0) JY=INT(DY-.2)-1
                              IF (JY==-1) JY=1
!
! --- Determine the values of the scattering matrix using the
!   symmetry properties of the Green's functions
!
!      IF(KZ<=KKZ) THEN
!           MZ=KKZ
!         ELSE
!           MZ=KZ
!       END IF
!
                              IF (IX>0.AND.JY>0) THEN
!
                              MX=IX
                              MY=JY
!
! --- Note that the order of the array GSB2 determined in the
!   routine GSB is different from that of the scattering matrix
!   formed here in this routine.  Check the routine GSB for
!   more explanations.
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM1,2)
                              GE(II3,JJ1)=GSB2(MM1,3)
                              GE(II1,JJ2)=GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM2,3)
                              GE(II1,JJ3)=GSB2(MM3,1)
                              GE(II2,JJ3)=GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM2,1)
                              GE(II3,JJ1)=GSB2(MM3,1)
                              GE(II1,JJ2)=GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM3,2)
                              GE(II1,JJ3)=GSB2(MM1,3)
                              GE(II2,JJ3)=GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY>0) THEN
!
                              MX=-IX
                              MY=JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM1,2)
                              GE(II3,JJ1)=-GSB2(MM1,3)
                              GE(II1,JJ2)=-GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM2,3)
                              GE(II1,JJ3)=-GSB2(MM3,1)
                              GE(II2,JJ3)=GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM2,1)
                              GE(II3,JJ1)=-GSB2(MM3,1)
                              GE(II1,JJ2)=-GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=GSB2(MM3,2)
                              GE(II1,JJ3)=-GSB2(MM1,3)
                              GE(II2,JJ3)=GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX<0.AND.JY<0) THEN
!
                              MX=-IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM1,2)
                              GE(II3,JJ1)=-GSB2(MM1,3)
                              GE(II1,JJ2)=GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM2,3)
                              GE(II1,JJ3)=-GSB2(MM3,1)
                              GE(II2,JJ3)=-GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=GSB2(MM2,1)
                              GE(II3,JJ1)=-GSB2(MM3,1)
                              GE(II1,JJ2)=GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM3,2)
                              GE(II1,JJ3)=-GSB2(MM1,3)
                              GE(II2,JJ3)=-GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
!
                              IF (IX>0.AND.JY<0) THEN
!
                              MX=IX
                              MY=-JY
!
!   Note that if KZ<=KKZ then KZ controls the field cell levels.
!   otherwise KZZ controls the field cell levels..
!
                              IF (KZ<=KKZ) THEN
                              MM=((KKZ-KZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KZ-2)))*(KZ-1)  &
                                 /2+(MM-1)*3+1
                              ELSE
                              MM=((KZ-KKZ)*NYS+(MY-1))*NXS+MX
                              MM1=(3*NXS*NYS*(2*NZS-(KKZ-2)))*(KKZ-1)  &
                                 /2+(MM-1)*3+1
                              END IF
                              MM2=MM1+1
                              MM3=MM1+2
!
                              IF (KZ>KKZ) THEN
!
!--- Use the reciprocity theorem
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM1,2)
                              GE(II3,JJ1)=GSB2(MM1,3)
                              GE(II1,JJ2)=-GSB2(MM2,1)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM2,3)
                              GE(II1,JJ3)=GSB2(MM3,1)
                              GE(II2,JJ3)=-GSB2(MM3,2)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              ELSE
!
                              GE(II1,JJ1)=GSB2(MM1,1)
                              GE(II2,JJ1)=-GSB2(MM2,1)
                              GE(II3,JJ1)=GSB2(MM3,1)
                              GE(II1,JJ2)=-GSB2(MM1,2)
                              GE(II2,JJ2)=GSB2(MM2,2)
                              GE(II3,JJ2)=-GSB2(MM3,2)
                              GE(II1,JJ3)=GSB2(MM1,3)
                              GE(II2,JJ3)=-GSB2(MM2,3)
                              GE(II3,JJ3)=GSB2(MM3,3)
                              END IF
                              CYCLE
!
                              END IF
                              END IF
!
! --- Compute the elements of GE for LQC.NE.1 by
!   symmetry relations of the Green's functions.
!   In the following the spatial symmetry is used to
!   determine the Green's functions.  In some cases
!   the reciprocity thereom may also be used.  Note
!   that the reciprocity thereom is not always true
!   here unless the media are isotropic or the four
!   field cells and the four source cells locate in
!   a single anisotropic layer. For this reason the
!   use of the reciprocity thereom is avoid here.
!
!   The following parameters r(-i)(-j) etc. refer to
!   thos in Table 1 of Xiong and Tripp (1992)
!   (spatial symmetry reduction).
!
                              IF (LQC==1) THEN
                              ELSEIF (LQC==3) THEN
!
                              IF (LQR==2) THEN
!
! --- Equivalent to the results of r(-i)(-j).
!
!   May also use reciprocity.
!   II=3, JJ=6
                              GE(II1,JJ1)=GE(10,1)
                              GE(II2,JJ1)=GE(11,1)
                              GE(II3,JJ1)=-GE(12,1)
                              GE(II1,JJ2)=GE(10,2)
                              GE(II2,JJ2)=GE(11,2)
                              GE(II3,JJ2)=-GE(12,2)
                              GE(II1,JJ3)=-GE(10,3)
                              GE(II2,JJ3)=-GE(11,3)
!
                              GE(II3,JJ3)=GE(12,3)
                              ELSEIF (LQR==3) THEN
!
! --- Equivalent to the results of r(-i)(-j).
!
!   Note this is not a self-cell unless N1=N2.
!
!   II=JJ=6
                              GE(II1,JJ1)=GE(1,1)
                              GE(II2,JJ1)=GE(2,1)
                              GE(II3,JJ1)=-GE(3,1)
                              GE(II1,JJ2)=GE(1,2)
                              GE(II2,JJ2)=GE(2,2)
                              GE(II3,JJ2)=-GE(3,2)
                              GE(II1,JJ3)=-GE(1,3)
                              GE(II2,JJ3)=-GE(2,3)
!
                              GE(II3,JJ3)=GE(3,3)
                              ELSEIF (LQR==4) THEN
!
! --- Equivalent to the results of r(-i)(-j).
!
!   II=9, JJ=6.
                              GE(II1,JJ1)=GE(4,1)
                              GE(II2,JJ1)=GE(5,1)
                              GE(II3,JJ1)=-GE(6,1)
                              GE(II1,JJ2)=GE(4,2)
                              GE(II2,JJ2)=GE(5,2)
                              GE(II3,JJ2)=-GE(6,2)
                              GE(II1,JJ3)=-GE(4,3)
                              GE(II2,JJ3)=-GE(5,3)
!
                              GE(II3,JJ3)=GE(6,3)
                              ELSE
!
! --- Equivalent to the results of r(-i)(-j).
!   II=0, JJ=6
                              GE(II1,JJ1)=GE(7,1)
                              GE(II2,JJ1)=GE(8,1)
                              GE(II3,JJ1)=-GE(9,1)
                              GE(II1,JJ2)=GE(7,2)
                              GE(II2,JJ2)=GE(8,2)
                              GE(II3,JJ2)=-GE(9,2)
                              GE(II1,JJ3)=-GE(7,3)
                              GE(II2,JJ3)=-GE(8,3)
!
                              GE(II3,JJ3)=GE(9,3)
                              END IF
                              ELSEIF (LQC==4) THEN
!
                              IF (LQR==2) THEN
!
! --- Equivalent to  ri(-j) or the combination of
!   r(-i)j and r(-i)(-j).
!
!   II=3, JJ=9
                              GE(II1,JJ1)=GE(7,1)
                              GE(II2,JJ1)=-GE(8,1)
                              GE(II3,JJ1)=GE(9,1)
                              GE(II1,JJ2)=-GE(7,2)
                              GE(II2,JJ2)=GE(8,2)
                              GE(II3,JJ2)=-GE(9,2)
                              GE(II1,JJ3)=GE(7,3)
                              GE(II2,JJ3)=-GE(8,3)
!
                              GE(II3,JJ3)=GE(9,3)
                              ELSEIF (LQR==3) THEN
!
! --- Equivalent to the results of ri(-j).
!
!   II=6, JJ=9
                              GE(II1,JJ1)=GE(4,1)
                              GE(II2,JJ1)=-GE(5,1)
                              GE(II3,JJ1)=GE(6,1)
                              GE(II1,JJ2)=-GE(4,2)
                              GE(II2,JJ2)=GE(5,2)
                              GE(II3,JJ2)=-GE(6,2)
                              GE(II1,JJ3)=GE(4,3)
                              GE(II2,JJ3)=-GE(5,3)
!
                              GE(II3,JJ3)=GE(6,3)
                              ELSEIF (LQR==4) THEN
!
! --- Equivalent to the results of ri(-j).
!
!   Note this is not a self-cell unless N1=N2.
!
!   II=JJ=9
                              GE(II1,JJ1)=GE(1,1)
                              GE(II2,JJ1)=-GE(2,1)
                              GE(II3,JJ1)=GE(3,1)
                              GE(II1,JJ2)=-GE(1,2)
                              GE(II2,JJ2)=GE(2,2)
                              GE(II3,JJ2)=-GE(3,2)
                              GE(II1,JJ3)=GE(1,3)
                              GE(II2,JJ3)=-GE(2,3)
                              GE(II3,JJ3)=GE(3,3)
                              ELSE
!
! --- Equivalent to the results of ri(-j).
!
!   II=0, JJ=9.
                              GE(II1,JJ1)=GE(10,1)
                              GE(II2,JJ1)=-GE(11,1)
                              GE(II3,JJ1)=GE(12,1)
                              GE(II1,JJ2)=-GE(10,2)
                              GE(II2,JJ2)=GE(11,2)
                              GE(II3,JJ2)=-GE(12,2)
                              GE(II1,JJ3)=GE(10,3)
                              GE(II2,JJ3)=-GE(11,3)
!
                              GE(II3,JJ3)=GE(12,3)
                              END IF
!
                              ELSEIF (LQR==2) THEN
!
! --- Equivalent to the results of r(-i)j.
!
!   Note this is not a self-cell unless N1=N2.
!
!   II=JJ=3
                              GE(II1,JJ1)=GE(1,1)
                              GE(II2,JJ1)=-GE(2,1)
                              GE(II3,JJ1)=-GE(3,1)
                              GE(II1,JJ2)=-GE(1,2)
                              GE(II2,JJ2)=GE(2,2)
                              GE(II3,JJ2)=GE(3,2)
                              GE(II1,JJ3)=-GE(1,3)
                              GE(II2,JJ3)=GE(2,3)
!
                              GE(II3,JJ3)=GE(3,3)
                              ELSEIF (LQR==3) THEN
!
! --- Equivalent to the results of r(-i)j.
!
!   II=6, JJ=3
                              GE(II1,JJ1)=GE(10,1)
                              GE(II2,JJ1)=-GE(11,1)
                              GE(II3,JJ1)=-GE(12,1)
                              GE(II1,JJ2)=-GE(10,2)
                              GE(II2,JJ2)=GE(11,2)
                              GE(II3,JJ2)=GE(12,2)
                              GE(II1,JJ3)=-GE(10,3)
                              GE(II2,JJ3)=GE(11,3)
!
                              GE(II3,JJ3)=GE(12,3)
                              ELSEIF (LQR==4) THEN
!
! --- Equivalent to r(-i)j or the combination of
!   ri(-j) and r(-i)(-j).
!   II=9, JJ=3
                              GE(II1,JJ1)=GE(7,1)
                              GE(II2,JJ1)=-GE(8,1)
                              GE(II3,JJ1)=-GE(9,1)
                              GE(II1,JJ2)=-GE(7,2)
                              GE(II2,JJ2)=GE(8,2)
                              GE(II3,JJ2)=GE(9,2)
                              GE(II1,JJ3)=-GE(7,3)
                              GE(II2,JJ3)=GE(8,3)
!
                              GE(II3,JJ3)=GE(9,3)
                              ELSE
!
! --- Equivalent to the results of r(-i)j.
!
!   In the following 9 lines II=0, JJ=3
                              GE(II1,JJ1)=GE(4,1)
                              GE(II2,JJ1)=-GE(5,1)
                              GE(II3,JJ1)=-GE(6,1)
                              GE(II1,JJ2)=-GE(4,2)
                              GE(II2,JJ2)=GE(5,2)
                              GE(II3,JJ2)=GE(6,2)
                              GE(II1,JJ3)=-GE(4,3)
                              GE(II2,JJ3)=GE(5,3)
!
                              GE(II3,JJ3)=GE(6,3)
                              END IF
!
                              END DO
                              END DO
!
! --- Transform the above elements of the scattering matrix
!   by the unitary matrix, U*Z*UT
!
!   Note that the total number of cells in one quarter and
!   the cell number as required by the parameters PMAX, PR
!   and PC in the routine unitary are not important here
!   as long as PR=PC, since the parameters IROW and JCOL
!   are of no use in the routine
!
!-- The parameter LQ controls the contributions to the four
!   block matrices.  LQ need be passed into this routine.
!
                              DO II=1,3
                              DO JJ=1,3
                              AA(JJ,II)=(0.,0.)
                              END DO
                              END DO
!
                              DO LQR=1,4
                              NQR=3*(LQR-1)
                              DO II=1,3
! --               PMAX=1
                              CALL MTRX_UNITARY(1,LQ,II,1,LQR,II,UR(II))
                              END DO
                              DO LQC=1,4
                              NQC=3*(LQC-1)
                              IF (LQR==1) THEN
                              DO JJ=1,3
! --                 PMAX=1
                              CALL MTRX_UNITARY(1,LQ,JJ,1,LQC,JJ,UC(JJ,LQC))
                              END DO
                              END IF
!
                              DO JJ=1,3
                              DO II=1,3
!
! --- Not that the values of UR and UC are either +.5 or -.5
!
                              IF (UR(II)<0) THEN
                              IF (UC(JJ,LQC)>=0) THEN
                              GOTO 2
                              END IF
                              ELSEIF (UC(JJ,LQC)<=0) THEN
                              GOTO 2
                              END IF
!
                              AA(II,JJ)=AA(II,JJ)+GE(NQR+II,NQC+JJ)
                              CYCLE
    2                         AA(II,JJ)=AA(II,JJ)-GE(NQR+II,NQC+JJ)
!
                              END DO
                              END DO
                              END DO
                              END DO
!
! ---  The sign of G is reversed
!
                              DO JJ=1,3
                              DO II=1,3
                              G(NN1+II,NN2+JJ)=-.25*AA(II,JJ)
                              END DO
                              END DO
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!
! This routine factors a square matrix by either LU or UDUT
! decomposition. The condition numbers of the matrix calculated
! by the maxmal column norm and maximal row norm will be
! returned if kcond=1. KSYM controls if whether the matrix is
! symmetric or not. This routine also returns the maxmal column
! and maximal row norms of the original matrix, anorm1 and
! anorm3, which would be useful for analysing the accuracy of
! the oringinal matrix (A) computed with different accuracy
! levels. The condition numbers may serve the same
! purpose better since they are functions of the matrix norms
! as well as the condition numbers themselves.  The routine
! also returns the maximal diagonal element of the matrix which
! should also be the maximal element of the matrix
!
      SUBROUTINE MTRX_SLV_FACTOR(NW,A,NMAX,N,IND,V,C1,AI,KSYM,         &
                                 KCOND,ANORM1,ANORM3,COND1,COND3,AEM)
!
      IMPLICIT NONE
!
      INTEGER NW
      REAL AEM,AINRM1,AINRM3,ANORM1,ANORM3,COND1,COND3,DD
      INTEGER I,INFO,J,JJ,KCOND,KSYM,N,NMAX
      COMPLEX A(NMAX,N),C1(N)
      INTEGER IND(N)
      REAL  V(N),AI(N)
      DOUBLE PRECISION AM
!
! --- Compute the norms of A
!
      IF (KCOND==1) THEN
!
! --- Maximal column norm (l_1 norm):
         ANORM1=0.
         AEM=0.
         DO J=1,N
!
! ---   Compute the maximal diagonal element
!
            AEM=AMAX1(AEM,ABS(A(J,J)))
!
            AM=0.D0
            DO I=1,N
               AM=AM+ABS(A(I,J))
            END DO
            ANORM1=AMAX1(ANORM1,SNGL(AM))
         END DO
!
! --- Maximal row norm (l_infinity norm):
         ANORM3=0.
         DO I=1,N
            AM=0.D0
            DO J=1,N
               AM=AM+ABS(A(I,J))
            END DO
            ANORM3=AMAX1(ANORM3,SNGL(AM))
         END DO
      END IF
!
! ---- Performing UDUT or LU decompistion
!
      IF (KSYM==1) THEN
         CALL MTRX_SLV_CSIFA(A,NMAX,N,IND,INFO)
      ELSE
         CALL MTRX_SLV_LUDCMP(NW,A,NMAX,N,IND,V,DD)
      END IF
!
! ----  Compute the norm of inverse A
!
      IF (KCOND/=0) THEN
         AINRM1=0.
         DO I=1,N
            AI(I)=0.
         END DO
!
         DO J=1,N
!
            DO JJ=1,N
               C1(JJ)=(0.,0.)
            END DO
            C1(J)=(1.,0.)
!
! --- Compute the column of the inverse of A
            IF (KSYM==1) THEN
               CALL MTRX_SLV_CSISL(A,NMAX,N,IND,C1)
            ELSE
               CALL MTRX_SLV_LUBKSB(A,C1,NMAX,N,IND)
            END IF
!
! ---- Calculate the maximal column norm
            AM=0.D0
            DO I=1,N
               AM=AM+ABS(C1(I))
            END DO
            AINRM1=AMAX1(AINRM1,SNGL(AM))
!
! ---- Calculate the row norms
            DO I=1,N
               AI(I)=AI(I)+ABS(C1(I))
            END DO
         END DO
!
! --- Compute the maximal row norm of inverse A
         AINRM3=0.
         DO I=1,N
            AINRM3=AMAX1(AINRM3,AI(I))
         END DO
!
! Determine the condition number
!
         COND1=ANORM1*AINRM1
         COND3=ANORM3*AINRM3
      END IF
      RETURN
      END
!
!
!           LU matrix decomposition
!  (Source: Press et al., Numerical recipes)
!
      SUBROUTINE MTRX_SLV_LUDCMP(NW,A,NP,N,INDEX,VV,D)
!
      IMPLICIT NONE
!
      INTEGER NW
      REAL AAMAX,D,DUM,TINY
      INTEGER I,IMAX,J,K,N,NP
      COMPLEX A(NP,NP),SUM,T
      REAL VV(N)
      INTEGER INDEX(N)
      PARAMETER (TINY=1.E-30)
      D=1.
      DO I=1,N
         AAMAX=0.
         DO J=1,N
            IF (ABS(A(I,J))>AAMAX) AAMAX=ABS(A(I,J))
         END DO
         IF (ABS(AAMAX)<TINY) THEN
            WRITE (NW,'(A)') 'Singular matrix'
            STOP 'Singular matrix'
         END IF
         VV(I)=1./AAMAX
      END DO
      DO J=1,N
         DO I=1,J-1
            SUM=A(I,J)
            DO K=1,I-1
               SUM=SUM-A(I,K)*A(K,J)
            END DO
            A(I,J)=SUM
         END DO
         AAMAX=0.
         DO I=J,N
            SUM=A(I,J)
            DO K=1,J-1
               SUM=SUM-A(I,K)*A(K,J)
            END DO
            A(I,J)=SUM
            DUM=VV(I)*ABS(SUM)
            IF (DUM>=AAMAX) THEN
               IMAX=I
               AAMAX=DUM
            END IF
         END DO
         IF (J/=IMAX) THEN
            DO K=1,N
               T=A(IMAX,K)
               A(IMAX,K)=A(J,K)
               A(J,K)=T
            END DO
            D=-D
            VV(IMAX)=VV(J)
         END IF
         INDEX(J)=IMAX
         IF (ABS(A(J,J))<TINY) A(J,J)=cmplx(TINY,0.)
         IF (J/=N) THEN
            T=1./A(J,J)
            DO I=J+1,N
               A(I,J)=A(I,J)*T
            END DO
         END IF
      END DO
      RETURN
      END
!
!
!  Solving linear equations by LU decomposition: backsubstitution
!  (Source: Press et al., Numerical recipes)
!
      SUBROUTINE MTRX_SLV_LUBKSB(A,B,NP,N,INDEX)
!
      IMPLICIT NONE
!
      INTEGER I,II,J,LL,N,NP
      REAL TINY
      COMPLEX A(NP,NP),B(N),SUM
      INTEGER INDEX(N)
      PARAMETER (TINY=1.E-30)
      II=0
      DO I=1,N
         LL=INDEX(I)
         SUM=B(LL)
         B(LL)=B(I)
         IF (II/=0) THEN
            DO J=II,I-1
               SUM=SUM-A(I,J)*B(J)
            END DO
         ELSEIF (ABS(SUM)>TINY) THEN
            II=I
         END IF
         B(I)=SUM
      END DO
      DO I=N,1,-1
         SUM=B(I)
         IF (I<N) THEN
            DO J=I+1,N
               SUM=SUM-A(I,J)*B(J)
            END DO
         END IF
         B(I)=SUM/A(I,I)
      END DO
      RETURN
      END
!
!
!   UDUT DECOMPSTION OF A SYMMETRICAL INDEFINITE COMPLEX MATRIX
!
!  (Source: Dongarra et al., Linpack user' guide)
!
      SUBROUTINE MTRX_SLV_CSIFA(A,LDA,N,KPVT,INFO)
!
      IMPLICIT NONE
!
      REAL ABSAKK,ALPHA,COLMAX,ROWMAX,TINY
      INTEGER IMAX,IMAXP1,INFO,ISAMAX,J,JJ,JMAX,K,KM1,KM2,KSTEP,LDA,N
      COMPLEX  A(LDA,N),T,MULK,MULKM1,AK,AKM1,DENOM,BK,BKM1
      INTEGER KPVT(N)
      LOGICAL SWAP
      PARAMETER (TINY=1.E-30)
!
      ALPHA=(1.+SQRT(17.))/8.
      INFO=0
!
      K=N
!
  100 IF (K/=0) THEN
         IF (K>1) THEN
!
            KM1=K-1
            ABSAKK=ABS(A(K,K))
!
            IMAX=ISAMAX(K-1,A(1,K),1)
            COLMAX=ABS(A(IMAX,K))
            IF (ABSAKK<ALPHA*COLMAX) THEN
!
               ROWMAX=0.
               IMAXP1=IMAX+1
               DO J=IMAXP1,K
                  ROWMAX=AMAX1(ROWMAX,ABS(A(IMAX,J)))
               END DO
               IF (IMAX/=1) THEN
                  JMAX=ISAMAX(IMAX-1,A(1,IMAX),1)
                  ROWMAX=AMAX1(ROWMAX,ABS(A(JMAX,IMAX)))
               END IF
               IF (ABS(A(IMAX,IMAX))>=ALPHA*ROWMAX) THEN
                  KSTEP=1
                  SWAP=.TRUE.
               ELSEIF (ABSAKK<ALPHA*COLMAX*(COLMAX/ROWMAX)) THEN
                  KSTEP=2
                  SWAP=IMAX/=KM1
               ELSE
                  KSTEP=1
                  SWAP=.FALSE.
               END IF
            ELSE
               KSTEP=1
               SWAP=.FALSE.
            END IF
            IF (ABS(AMAX1(ABSAKK,COLMAX))<=TINY) THEN
!
               KPVT(K)=K
               INFO=K
            ELSEIF (KSTEP==2) THEN
!
               IF (SWAP) THEN
!
                  CALL MTRX_SLV_SSWAP(IMAX,A(1,IMAX),1,A(1,K-1),1)
                  DO JJ=IMAX,KM1
                     J=KM1+IMAX-JJ
                     T=A(J,K-1)
                     A(J,K-1)=A(IMAX,J)
                     A(IMAX,J)=T
                  END DO
                  T=A(K-1,K)
                  A(K-1,K)=A(IMAX,K)
                  A(IMAX,K)=T
               END IF
!
               KM2=K-2
               IF (KM2/=0) THEN
                  AK=A(K,K)/A(K-1,K)
                  AKM1=A(K-1,K-1)/A(K-1,K)
                  DENOM=(1.,0.)-AK*AKM1
                  DO JJ=1,KM2
                     J=KM1-JJ
                     BK=A(J,K)/A(K-1,K)
                     BKM1=A(J,K-1)/A(K-1,K)
                     MULK=(AKM1*BK-BKM1)/DENOM
                     MULKM1=(AK*BKM1-BK)/DENOM
                     T=MULK
                     CALL MTRX_SLV_SAXPY(J,T,A(1,K),1,A(1,J),1)
                     T=MULKM1
                     CALL MTRX_SLV_SAXPY(J,T,A(1,K-1),1,A(1,J),1)
                     A(J,K)=MULK
                     A(J,K-1)=MULKM1
                  END DO
               END IF
!
               KPVT(K)=1-K
               IF (SWAP) KPVT(K)=-IMAX
               KPVT(K-1)=KPVT(K)
            ELSE
!
               IF (SWAP) THEN
!
                  CALL MTRX_SLV_SSWAP(IMAX,A(1,IMAX),1,A(1,K),1)
                  DO JJ=IMAX,K
                     J=K+IMAX-JJ
                     T=A(J,K)
                     A(J,K)=A(IMAX,J)
                     A(IMAX,J)=T
                  END DO
               END IF
!
               DO JJ=1,KM1
                  J=K-JJ
                  MULK=-A(J,K)/A(K,K)
                  T=MULK
                  CALL MTRX_SLV_SAXPY(J,T,A(1,K),1,A(1,J),1)
                  A(J,K)=MULK
               END DO
!
               KPVT(K)=K
               IF (SWAP) KPVT(K)=IMAX
            END IF
            K=K-KSTEP
            GOTO 100
         ELSE
            KPVT(1)=1
!
            IF (ABS(A(1,1))<TINY) INFO=1
         END IF
      END IF
      RETURN
      END
!
!
! SOLVING LINEAR EQUATION BY BACKSUBSTITUTE USING UDUT DECOMPSTION
!
      SUBROUTINE MTRX_SLV_CSISL(A,LDA,N,KPVT,B)
!
      IMPLICIT NONE
!
      INTEGER K,KP,LDA,N
      COMPLEX A(LDA,N),B(N),TEMP,AK,AKM1,BK,BKM1,DENOM,SDOT
      INTEGER KPVT(N)
!
      K=N
  100 IF (K==0) THEN
!
         K=1
  150    IF (K<=N) THEN
            IF (KPVT(K)<0) THEN
!
               IF (K/=1) THEN
!
                  B(K)=B(K)+SDOT(K-1,A(1,K),1,B(1),1)
                  B(K+1)=B(K+1)+SDOT(K-1,A(1,K+1),1,B(1),1)
                  KP=IABS(KPVT(K))
                  IF (KP/=K) THEN
!
                     TEMP=B(K)
                     B(K)=B(KP)
                     B(KP)=TEMP
                  END IF
               END IF
               K=K+2
            ELSE
!
               IF (K/=1) THEN
!
                  B(K)=B(K)+SDOT(K-1,A(1,K),1,B(1),1)
                  KP=KPVT(K)
                  IF (KP/=K) THEN
!
                     TEMP=B(K)
                     B(K)=B(KP)
                     B(KP)=TEMP
                  END IF
               END IF
               K=K+1
            END IF
            GOTO 150
         END IF
      ELSE
         IF (KPVT(K)<0) THEN
!
            IF (K/=2) THEN
               KP=IABS(KPVT(K))
               IF (KP/=K-1) THEN
!
                  TEMP=B(K-1)
                  B(K-1)=B(KP)
                  B(KP)=TEMP
               END IF
!
               CALL MTRX_SLV_SAXPY(K-2,B(K),A(1,K),1,B(1),1)
               CALL MTRX_SLV_SAXPY(K-2,B(K-1),A(1,K-1),1,B(1),1)
            END IF
!
            AK=A(K,K)/A(K-1,K)
            AKM1=A(K-1,K-1)/A(K-1,K)
            BK=B(K)/A(K-1,K)
            BKM1=B(K-1)/A(K-1,K)
            DENOM=AK*AKM1-(1.,0.)
            B(K)=(AKM1*BK-BKM1)/DENOM
            B(K-1)=(AK*BKM1-BK)/DENOM
            K=K-2
         ELSE
!
            IF (K/=1) THEN
               KP=KPVT(K)
               IF (KP/=K) THEN
!
                  TEMP=B(K)
                  B(K)=B(KP)
                  B(KP)=TEMP
               END IF
!
               CALL MTRX_SLV_SAXPY(K-1,B(K),A(1,K),1,B(1),1)
            END IF
!
            B(K)=B(K)/A(K,K)
            K=K-1
         END IF
         GOTO 100
      END IF
      RETURN
      END
!
!
!    BLA LISTINGS OF LINPACK
!
!
! ISAMAX
!
      INTEGER FUNCTION ISAMAX(N,SX,INCX)
      INTEGER I,INCX,IX,N
      REAL SMAX
      COMPLEX SX(N)
!
      ISAMAX=0
      IF (N<1) THEN
         RETURN
      END IF
      ISAMAX=1
      IF (N==1) THEN
         RETURN
      END IF
      IF (INCX/=1) THEN
!
         IX=1
         SMAX=ABS(SX(1))
         IX=IX+INCX
         DO I=2,N
            IF (ABS(SX(IX))>SMAX) THEN
               ISAMAX=I
               SMAX=ABS(SX(IX))
            END IF
            IX=IX+INCX
         END DO
         RETURN
      END IF
!
      SMAX=ABS(SX(1))
      DO I=2,N
         IF (ABS(SX(I))>SMAX) THEN
            ISAMAX=I
            SMAX=ABS(SX(I))
         END IF
      END DO
      RETURN
      END
!
!
      SUBROUTINE MTRX_SLV_SAXPY(N,SA,SX,INCX,SY,INCY)
!
!**** SAXPY
!
      IMPLICIT NONE
!
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
      REAL TINY
       COMPLEX SX(N),SY(N),SA
       PARAMETER (TINY=1.E-30)
!
      IF (N<=0) THEN
         RETURN
      END IF
      IF (ABS(SA)<TINY) THEN
         RETURN
      END IF
      IF (INCX==1.AND.INCY==1) THEN
!
         M=MOD(N,4)
         IF (M/=0) THEN
            DO I=1,M
               SY(I)=SY(I)+SA*SX(I)
            END DO
            IF (N<4) THEN
               RETURN
            END IF
         END IF
      ELSE
!
         IX=1
         IY=1
         IF (INCX<0) IX=(-N+1)*INCX+1
         IF (INCY<0) IY=(-N+1)*INCY+1
         DO I=1,N
            SY(IY)=SY(IY)+SA*SX(IX)
            IX=IX+INCX
            IY=IY+INCY
         END DO
         RETURN
      END IF
      MP1=M+1
      DO I=MP1,N,4
         SY(I)=SY(I)+SA*SX(I)
         SY(I+1)=SY(I+1)+SA*SX(I+1)
         SY(I+2)=SY(I+2)+SA*SX(I+2)
         SY(I+3)=SY(I+3)+SA*SX(I+3)
      END DO
      RETURN
      END
!
! SDOT
!
      COMPLEX FUNCTION SDOT(N,SX,INCX,SY,INCY)
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
      COMPLEX SX(N),SY(N),STEMP
!
      STEMP=(0.,0.)
      SDOT=(0.,0.)
      IF (N==0) THEN
         RETURN
      END IF
      IF (INCX==1.AND.INCY==1) THEN
!
         M=MOD(N,5)
         IF (M/=0) THEN
            DO I=1,M
               STEMP=STEMP+SX(I)*SY(I)
            END DO
            IF (N<5) THEN
               GOTO 100
            END IF
         END IF
         MP1=M+1
         DO I=MP1,N,5
            STEMP=STEMP+SX(I)*SY(I)+SX(I+1)*SY(I+1)+SX(I+2)*SY(I+2)  &
                  +SX(I+3)*SY(I+3)+SX(I+4)*SY(I+4)
         END DO
      ELSE
!
         IX=1
         IY=1
         IF (INCX<0) IX=(-N+1)*INCX+1
         IF (INCY<0) IY=(-N+1)*INCY+1
         DO I=1,N
            STEMP=STEMP+SX(IX)*SY(IY)
            IX=IX+INCX
            IY=IY+INCY
         END DO
         SDOT=STEMP
         RETURN
      END IF
  100 SDOT=STEMP
      RETURN
      END
!
! MTRX_SLV_SSWAP
!
      SUBROUTINE MTRX_SLV_SSWAP(N,SX,INCX,SY,INCY)
!
      IMPLICIT NONE
!
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
      COMPLEX SX(N),SY(N),STEMP
!
      IF (N<=0) THEN
         RETURN
      END IF
      IF (INCX==1.AND.INCY==1) THEN
!
         M=MOD(N,3)
         IF (M/=0) THEN
            DO I=1,M
               STEMP=SX(I)
               SX(I)=SY(I)
               SY(I)=STEMP
            END DO
            IF (N<3) THEN
               RETURN
            END IF
         END IF
      ELSE
!
         IX=1
         IY=1
         IF (INCX<0) IX=(-N+1)*INCX+1
         IF (INCY<0) IY=(-N+1)*INCY+1
         DO I=1,N
            STEMP=SX(IX)
            SX(IX)=SY(IY)
            SY(IY)=STEMP
            IX=IX+INCX
            IY=IY+INCY
         END DO
         RETURN
      END IF
      MP1=M+1
      DO I=MP1,N,3
         STEMP=SX(I)
         SX(I)=SY(I)
         SY(I)=STEMP
         STEMP=SX(I+1)
         SX(I+1)=SY(I+1)
         SY(I+1)=STEMP
         STEMP=SX(I+2)
         SX(I+2)=SY(I+2)
         SY(I+2)=STEMP
      END DO
      RETURN
      END
!
!
      SUBROUTINE MTRX_UNITARY (PR,QR,I,PC,QC,J,U)
!
!****  Unitary matrix that block diagonalize the scattering matrix
!
!   The routine compute the values of the unitary matrix according
!   to the position of the cell PR (for rows) and PC (for columns)
!   in sequential order in the first quadrant, the quadrant numbers
!   QR (for the rows) and QC (for the columns), and the component
!   numbers I (for the rows) and J (for the columns).  It returns
!   value of the matrix element U corresponding to the matrix row
!   number IROW and matrix column number JCOL (not computed for
!   efficience.  They are determined in the calling routines)
!   The total number of the cells in a quadrant, PMAX will be needed
!   to compute IROW and JCOL.
!
      IMPLICIT NONE
!
      INTEGER PR,PC,QR,QC,I,J
      REAL U
!
!    IF ( QR>4 .OR.
!   +     QC>4 .OR.
!   +      I>3 .OR.
!   +      J>3 )    STOP 'Error: parameters out of bound!'
!
! --- IROW and JCOL are computed where needed.  Therefore, in order
!   to save computation time, they are not computed here.
!
!    IROW=3*PMAX*(QR-1)+3*(PR-1)+I
!    JCOL=12*(PC-1)+3*(QC-1)+J
!
      IF (I/=J.OR.PR/=PC) THEN
         U=0.
         RETURN
      END IF
!
! --- Form I, I1, I2, and I3 according to QC.
!   Note that I=J
!
      IF (QC==2) THEN
         IF (I==2.OR.I==3) THEN
            U=.5
         ELSE
            U=-.5
         END IF
      ELSEIF (QC==3) THEN
!
         IF (I==3) THEN
            U=.5
         ELSE
            U=-.5
         END IF
      ELSEIF (QC==4) THEN
!
         IF (I==2) THEN
            U=-.5
         ELSE
            U=.5
         END IF
      ELSE
!
         U=.5
      END IF
!
      IF (QR==2) THEN
!
         IF (QC==2) THEN
            U=-U
            RETURN
         ELSEIF (QC==3) THEN
            RETURN
         ELSEIF (QC==4) THEN
            U=-U
            RETURN
         ELSE
            RETURN
         END IF
      ELSEIF (QR==3) THEN
!
         IF (QC==2) THEN
            RETURN
         ELSEIF (QC==3) THEN
            U=-U
            RETURN
         ELSEIF (QC==4) THEN

            U=-U
            RETURN
         ELSE
            RETURN
         END IF
      ELSEIF (QR==4) THEN
!
         IF (QC==2) THEN
            U=-U
            RETURN
         ELSEIF (QC==3) THEN
            U=-U
            RETURN
         ELSEIF (QC/=4) THEN
            RETURN
         END IF
      ELSE
!
         RETURN
      END IF
      RETURN
!
      END
!
!
!===== Subroutines for the right hand side of the matrix equation
!
      SUBROUTINE EN_PRM(FRQ,MLAYER,ZBND,LRYTH,KKH,CDH,         &
                        NET,SUB_BLOCK,NSUBCM,NZMAX,NX,NY,NZ,   &
                        NCELL,ZCELL,CDB,KPOL,EN,ECD)
!
!*****   Form the exciting right hand side term
!
      IMPLICIT NONE
!
      REAL FRQ
      INTEGER I,IOB,J,K,KPOL,L,MLAYER,SUB_BLOCK,NEB,NET,NN,NN1,NOBSV,   &
              NSUBCM,NZMAX
!
!**** Form the right hand side of the matrix equation,  or the
!   incident fields at cell centers.
!
      COMPLEX EN(NET),ECD(NET),EX,EY,HX,HY,DELTCD,                     &
              CDH(0:MLAYER),KKH(0:MLAYER),CDB(NSUBCM,SUB_BLOCK)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  ZCELL(NZMAX,SUB_BLOCK),ZBND(0:MLAYER),LRYTH(MLAYER)
!
      NEB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NEB=NEB+3*NCELL(L-1)
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (ZCELL(K,L)>=ZBND(IOB)) THEN
                  NOBSV=IOB+1
                  GOTO 20
               END IF
            END DO
            NOBSV=0
   20       CALL EN_PRM_MT(FRQ,MLAYER,ZBND,LRYTH,KKH,NOBSV,ZCELL(K,L),   &
                           EX,EY,HX,HY)
            DO I=1,NX(L)
               DO J=1,NY(L)
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  NN1=(NN-1)*3+1+NEB
                  IF (KPOL==1) THEN
                     EX=(0.,0.)
                  ELSE
                     EY=(0.,0.)
                  END IF
                  EN(NN1)=EX
                  EN(NN1+1)=EY
                  EN(NN1+2)=(0.,0.)
                  DELTCD=CDB(NN,L)-CDH(NOBSV)
                  ECD(NN1)=EX*DELTCD
                  ECD(NN1+1)=EY*DELTCD
                  ECD(NN1+2)=(.0,.0)
               END DO
            END DO
         END DO
      END DO
      RETURN
      END
!
!**** End of EN_PRM
!
!
!    EM FIELDS IN STRATIFIED MEDIA INCITED BY A PLANE WAVE
!
      SUBROUTINE EN_PRM_MT(FRQ,MLAYER,ZBND,LRYTH,KKH,NOBSV,ZOB,EX,EY,HX,HY)
!
      IMPLICIT NONE
!
      INTEGER MLAYER,NOBSV
      INTEGER J,LAYERM
!
      REAL  FRQ,ZOB,LRYTH(MLAYER),ZBND(0:MLAYER)
!
!-- Parameter LAYERM must have a value greater than or equal to
!   that in the main program
!
      PARAMETER (LAYERM=200)

      COMPLEX NU(0:LAYERM),Z(LAYERM),A(0:LAYERM),   &
                 B(0:LAYERM),C1,C2,C3,C4
      COMPLEX EX,EY,HX,HY,KKH(0:MLAYER),W,K(0:LAYERM)
!
      W=CMPLX(0.,78.9568352E-7*FRQ)
      DO J=0,MLAYER
         K(J)=CSQRT(KKH(J))
         NU(J)=W/K(J)
      END DO
!
! ----  A(0) so chosen that the normal incident h-filed has a
!     magnitude of  1 (a/m) in the case of h-polarisation
!
      A(0)=-NU(0)
      Z(MLAYER)=NU(MLAYER)
      IF (MLAYER>1) THEN
         DO J=MLAYER-1,1,-1
            C1=EXP(-2.*K(J)*LRYTH(J))
            C1=((1.,0.)-C1)/((1.,0.)+C1)
            Z(J)=NU(J)*(Z(J+1)+NU(J)*C1)/(NU(J)+Z(J+1)*C1)
         END DO
      END IF
      B(0)=(Z(1)+NU(0))/(Z(1)-NU(0))*A(0)
      IF (NOBSV<=0) THEN
         EX=A(0)+B(0)
         HY=(B(0)-A(0))/NU(0)
!
! Note that EY and HX are so chosen that hy is positive
!
         EY=-EX
         HX=HY
      ELSE
         C1=(1.0,0.0)
         C2=(1.0,0.0)
         C3=(0.0,0.0)
         DO J=1,NOBSV

            IF (ABS(NU(MLAYER)-NU(MLAYER-1))>=1.E-30.OR.J==MLAYER) THEN
               C1=C1*(Z(J)-NU(J))/(Z(J)-NU(J-1))
               C2=C2*(Z(J)+NU(J))/(Z(J)+NU(J-1))
               C3=C3+(K(J-1)-K(J))*ZBND(J-1)
            END IF
         END DO
         IF (NOBSV==MLAYER) THEN

            C4=(0.,0.)
         ELSE

            C4=EXP(C3+K(NOBSV)*ZOB)
         END IF

         C3=EXP(-C3-K(NOBSV)*ZOB)
         EX=A(0)*C1*C4+B(0)*C2*C3
         HY=-(A(0)*C1*C4-B(0)*C2*C3)/NU(NOBSV)
         EY=-EX
         HX=HY
      END IF
!
      RETURN
      END
!
!**** End of EN_PRM_MT
!
!
      SUBROUTINE EN_PRM_CS(NET,SUB_BLOCK,NSUBCM,NXMAX,NYMAX,            &
                           NZMAX,NX,NY,NZ,NCELL,XCELL,YCELL,ZCELL,      &
                           CDB,CS_TYPE,NCRD,TX_CRDX,TX_CRDY,TX_CRDZ,    &
                           RAD,EN,ECD,FRQ,MLAYER,ZBND,KKH,CDH,ANGLES,   &
                           KEYG,KACC,AJ,NZOB,ZOBG,NZSR,ZSRG,            &
                           RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
!**** Form the right hand side of the matrix equation,  or the
!   incident fields at cell centers for controlled source problems.
!
!   Note that this routine computes the incident fields in
!   one substructure only,  and thus all the parameters like
!   NX,  XCELL,  etc are defined for one substructure only.
!   (They are represented by NXI,  XCELLI etc. in the main program)
!
!   Parameters  KEYG, KACC, AJ, NZOB, ZOBG, NZSR, ZSRG,
!   RHOMIN, NHFILM, RRG, NRG, GRHF, and GRHO0 are to be
!   passed into routine ONE_D_SOURCE.
!
!
      IMPLICIT NONE
!
      REAL AJ,FRQ,RAD,RHOMIN
      INTEGER I,IOB,J,K,KACC,KEYG,CS_TYPE,L,MLAYER,SUB_BLOCK,NEB,NET,   &
              NHFILM,NN,NN1,NOBSV,NRG,NSUBCM,NXMAX,NCRD
      INTEGER NYMAX,NZMAX,NZOB,NZSR
!
      COMPLEX EN(NET),ECD(NET),EX,EY,EZ,HX,HY,HZ,DELTCD,                 &
              CDH(0:MLAYER),KKH(0:MLAYER),CDB(NSUBCM,SUB_BLOCK)
      COMPLEX EHFLD(6)
      INTEGER NX(SUB_BLOCK),NY(SUB_BLOCK),NZ(SUB_BLOCK),NCELL(SUB_BLOCK)
      REAL  XCELL(NXMAX,SUB_BLOCK),YCELL(NYMAX,SUB_BLOCK),               &
            ZCELL(NZMAX,SUB_BLOCK),ZBND(0:MLAYER),                       &
            TX_CRDX(NCRD),TX_CRDY(NCRD),TX_CRDZ(NCRD),RECVR(3)
      REAL  ZOBG(NZOB),ZSRG(2,NZSR),RRG(NRG)
      REAL :: ANGLES(2)
      COMPLEX GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      EQUIVALENCE (EHFLD(1),EX),(EHFLD(2),EY),(EHFLD(3),EZ),   &
                  (EHFLD(4),HX),(EHFLD(5),HY),(EHFLD(6),HZ)
!
      NEB=0
      DO L=1,SUB_BLOCK
         IF (L>1) NEB=NEB+3*NCELL(L-1)
         DO K=1,NZ(L)
            DO IOB=MLAYER-1,0,-1
               IF (ZCELL(K,L)>=ZBND(IOB)) THEN
                  NOBSV=IOB+1
                  GOTO 20
               END IF
            END DO
            NOBSV=0
   20       DO I=1,NX(L)
               DO J=1,NY(L)
                  NN=(I-1)*NY(L)*NZ(L)+(J-1)*NZ(L)+K
                  NN1=(NN-1)*3+1+NEB
!
                  RECVR(1)=XCELL(I,L)
                  RECVR(2)=YCELL(J,L)
                  RECVR(3)=ZCELL(K,L)
!
                  CALL ONE_D_SOURCE(CS_TYPE,ANGLES,RECVR,NCRD,TX_CRDX,    &
                                    TX_CRDY,TX_CRDZ,RAD,KEYG,KACC,FRQ,    &
                                    MLAYER,ZBND,AJ,KKH,CDH,NZOB,ZOBG,     &
                                    NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF, &
                                    GRHO0,EHFLD)
!
                  EN(NN1)=EX
                  EN(NN1+1)=EY
                  EN(NN1+2)=EZ
                  DELTCD=CDB(NN,L)-CDH(NOBSV)
                  ECD(NN1)=EX*DELTCD
                  ECD(NN1+1)=EY*DELTCD
                  ECD(NN1+2)=EZ*DELTCD
!
               END DO
            END DO
         END DO
      END DO
      RETURN
      END
!
!**** End of EN_PRM_CS
!
!
      SUBROUTINE EN_PRM_GS(NEQ,NBODY,SUB_BLOCK,NBMAX,NXMAX,NYMAX,NZMAX,   &
                           NET,NX,NY,NZ,NCELL,XCELL,YCELL,ZCELL,          &
                           CS_TYPE,NCRD,TX_CRDX,TX_CRDY,TX_CRDZ,RAD,EN,   &
                           FRQ,MLAYER,ZBND,KKH,CDH,ANGLES,KEYG,           &
                           KACC,AJ,NZOB,ZOBG,NZSR,ZSRG,                   &
                           RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
!**** Form the right hand side of the matrix equation,  or the
!   incident fields at cell centers for controlled source problems.
!
!   Note that this routine computes the incident fields in
!   the whole structure (unlike routine EN_PRM_CS!),  and thus all the
!   parameters like NX,  XCELL,  etc are defined for the whole
!   structure as in the main program.
!
!   Note that the array EN is arranged in an order as described
!   by Tripp and Tripp & Hohmann, i.e., the elements go first
!   by quarters
!
!   Parameters  KEYG, KACC, AJ, NZOB, ZOBG, NZSR, ZSRG,
!   RHOMIN, NHFILM, RRG, NRG, GRHF, and GRHO0 are to be
!   passed into routine ONE_D_SOURCE.
!
!
      IMPLICIT NONE
!
      REAL AJ,BX,BY,FRQ,RAD,RHOMIN
      INTEGER I,IB,IQ,J,K,KACC,KEYG,CS_TYPE,L,MLAYER,NBMAX,NBODY,NCB,NEQ,  &
              NHFILM,NN,NN1,NP,NRG,NCRD,NSUB,NXMAX,NYMAX,NZMAX,NZOB,NZSR
!
      INTEGER NX(NBMAX,NBODY),NY(NBMAX,NBODY),NZ(NBMAX,NBODY),             &
              NCELL(NBMAX,NBODY),NET(NBODY),SUB_BLOCK(NBODY)
      REAL  XCELL(NXMAX,NBMAX,NBODY),YCELL(NYMAX,NBMAX,NBODY),             &
            ZCELL(NZMAX,NBMAX,NBODY),ZBND(0:MLAYER),                       &
            TX_CRDX(NCRD),TX_CRDY(NCRD),TX_CRDZ(NCRD),RECVR(3)
      REAL :: ANGLES(2),ZOBG(NZOB),ZSRG(2,NZSR),RRG(NRG)
      COMPLEX EN(NEQ*4),EX,EY,EZ,HX,HY,HZ,CDH(0:MLAYER),KKH(0:MLAYER)
      COMPLEX EHFLD(6),GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      EQUIVALENCE (EHFLD(1),EX),(EHFLD(2),EY),(EHFLD(3),EZ),               &
                  (EHFLD(4),HX),(EHFLD(5),HY),(EHFLD(6),HZ)
!
      NSUB=0
      DO IB=1,NBODY
         IF (IB>1) NSUB=NSUB+NET(IB-1)/3
!
         NCB=0
         DO L=1,SUB_BLOCK(IB)
            IF (L>1) NCB=NCB+NCELL(L-1,IB)
            DO K=1,NZ(L,IB)
               DO I=1,NX(L,IB)
                  DO J=1,NY(L,IB)
                     NN=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)+K
!
                     NP=NSUB+NCB+NN
!
! --- Loop for the four quarters
                     DO IQ=1,4
!
! --- See the formula for jcol in routine unitary
                        NN1=12*(NP-1)+3*(IQ-1)+1
!
                        IF (IQ==1) THEN
                           BX=-1.
                           BY=-1.
                        END IF
                        IF (IQ==2) THEN
                           BX=1.
                           BY=-1.
                        END IF
                        IF (IQ==3) THEN
                           BX=1.
                           BY=1.
                        END IF
                        IF (IQ==4) THEN
                           BX=-1.
                           BY=1.
                        END IF
!
                        RECVR(1)=BX*XCELL(I,L,IB)
                        RECVR(2)=BY*YCELL(J,L,IB)
                        RECVR(3)=ZCELL(K,L,IB)
!
                        CALL ONE_D_SOURCE(CS_TYPE,ANGLES,RECVR,NCRD,TX_CRDX,  &
                                          TX_CRDY, TX_CRDZ,RAD,KEYG,KACC,FRQ, &
                                          MLAYER,ZBND,AJ,KKH,CDH,NZOB,ZOBG,   &
                                          NZSR,ZSRG,RHOMIN,NHFILM,RRG,        &
                                          NRG,GRHF,GRHO0,EHFLD)
!
                        EN(NN1)=EX
                        EN(NN1+1)=EY
                        EN(NN1+2)=EZ
!
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!**** End of EN_PRM_GS
!
!
   SUBROUTINE ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,     &
                           KANIS,KPRM,KRHO,KITG,KCHRG,NOB,NSR,      &
                           ZOB,ZSR,ZSRH,ZSRL,LUMBDA,FKNS)
!
!****  KERNELS  OF  THE  HANKEL  TRANSFORMS  IN  THE  GREEN'S  FUNCTIONS
!      FOR ELECTROMAGNETIC FIELDS IN A STRATIFIED ANISOTROPIC EARTH
!      (INTEGRATED ANALYTICALLY IN THE VERTICAL DIRECTION IF KITG=1)
!
!    NOTE THAT THE PRIMARY CONTRIBUTION IS INCLUDED IF KPRM=1 AND
!    IS EXCLUDED IF KPRM=0. THE FIGURE AND EQUATION NUMBERS REFERED
!    HERE ARE THOSE IN XIONG, 1989, GEOPHYSICS, 1643-1646
!
!
!    This routine is identical to routine ONE_D_KERNEL of Marco except that
!    anisotropy has been taken out from this routine.  In order to minimise
!    changes,  parameter KANIS is still passed into this routine although it
!    is not used.
!
! --- The input parameters:
!
!      KEYG:    Interger(*4), parameter controlling the output kernels
!               for electric dipoles.
!               KEYG=1:  compute the kernels for electric Green's
!                        tensors as required by the scattering matrix.
!                        Only the first six elements in the output array
!                        FKNS are used which are for the general electric
!                        Green's tensor when the current and charge
!                        termss are computed together as required by old
!                        versions of the 3D code SYSEM et al.
!                    =2: kernels for electric and magnetic field without
!                        separating the current and charge terms;
!                    =3: compute the kernels for current and charge terms
!                        of electric Green's tensors as required by the
!                        scattering matrix; and
!                    =4: compute the scattered fields due to cells with
!                        the current and the charge terms separated for the
!                        electric field.
!      KEMD:    Interger, controls if electric or magnetic
!               dipoles are to be computed.
!               KEMD=1:  electric dipoles;  and
!                   =2:  magnetic dipoles.
!      MLAYER:  Integer(*4), the number of layers including the air.
!      ZBND:    Real ZBND(0:MLAYER), the z-coordinates of the layer
!               boundaries with the air-earth interface being always
!               0 (zbnd(0)=0).
!      LRYTH:   Real LRYTH(MLAYER), the thickness of the layers.
!      HVK:     Real HVK(0:MLAYER), the anisotropy coefficients of
!               the layer conductivities as defined by the square
!               root of the ratio of horizontal conductivity to
!               vertical conductivity.
!      KKH:     Complex KKH(0:MLAYER), the wave numbers of the layers
!               (the air as layer 0) defined as
!                 i*w*mu*(horizontal complex conductivity)
!               where the horizontal complex conductivity includes
!               i*epsilon*w in its imaginary part.
!      KANIS:   Integer, flag for the anisotropy of the media.
!               This parameter is however not used in this routine.
!      KPRM:    Integer, controls whether the primary parts due to
!               the whole space should be included or excluded.
!               KPRM=1:  include the primary terms so the kernels
!                        are complete for all contributions; and
!               KPRM=0:  exclude the primary terms so the kernels
!                        are secondary that are due to the layers.
!      KRHO:    Integer, flag for the value of rho
!               (=sqrt(x-x')**2+(y-y')**2).
!               KRHO=0:  rho=0;  and
!               KRHO=1:  rho>0
!               The kernels are different for rho=0 where the Hankel
!               transforms reduce to plaine infinite integrals.
!      KITG:    Integer, controls whether the kernels should be
!               integrated analytically in the z'-direction.
!               KITG=1:  integrate the kernels from ZSRL to ZSRH; and
!               KITG=0:  ordinary kernels (EM fields from sources to
!               receivers due to dipoles).
!      KCHRG: Integer,  controls whether the charge terms need be
!               removed from the kernels.  For loop sources, the charge
!               terms in the electric fields do not exist but cannot be
!               canceled exactly in the numerical procedures.  Thus
!               they need to removed directly from the kernels.
!               If KCHRG=1,  the charge terms in the electric field
!               will be removed from the kernels.  The parameter
!               KCHRG is controlled in the routine gridhf and gridcs.
!      NOB:     Integer,  the layer number for ZOB.
!      NSR:     Integer,  the layer number of ZSR, ZSRH and ZSRL (they
!               must be in the same layer).
!      ZOB:     Real(*4), the receiver z-coordinate.
!      ZSR:     Real, the source z-coordinate.  Also the mid-point
!               of ZSRH and ZSRL.
!      ZSRL,ZSRH: Real,  the lower the upper limits of the integration.
!               Note that ZSRL and ZSRH both should be either less than
!               or equal to, or greater than or equal to ZOB.
!               ZSR, ZSRH and ZSR must be in the same layer.
!      LUMBDA:   Real, the integration variable, lumbda,  in the Hankel
!               transforms.  The A in LUMBDA is used to make the
!               parameter an implicit real one.
!
! --- The output is the array FKNS
!
!      FKNS:   Defined as complex FKNS(11).  The contents of the
!              11 values are the kernels of the Hankel transforms
!              for the Green's tensors which are strictly related
!              to those in the routine ONE_D_GREEN and THR_D_GREEN.  The actual
!              kernels are determined by the input parameter KEYG.
!              Check comments on KEYG for more details.
!
! --- Further remarks:
!
!    The parameter EMAX represents the maximal argument of the exponential
!    functions. The exponential functions in some cases tend to infinity as
!    z and z' goes far away from each other, but their contributions to the
!    field values are less and less.   Therefore, for the sake of numerical
!    accuracy these exponential functions are set to zero if their arguments
!    exceed EMAX.  The value of EMAX depends on the accuracy of the numerical
!    Hankel tranforms as well as on the computer system used.  EMAX can be
!    chosen using reciprocity tests.
!
!    The numerical Hankel transforms used in this program yield an ac-
!    curacy of about 10**(-7).   With an EMAX ranging from 5 to 25
!    identical results (up to at least 5 figures) were observed for some
!    tests on an IBM-3090. However, the numerical integration for rho=0
!    (routine simpinf and simpsn) sometimes would not converge for
!    EMAX=20 or so.  Further tests show that EMAX must be at least greater
!    than 5 in order to reach a reasonable accuracy.  Discrepancies may still
!    be visible for EMAX < 20.
!
!    While the use of the control parameter EMAX is adequate for double
!    precision computations,  it fails to yield reasonable accuracy for
!    single precision operations.  This turns out to be caused be the
!    wave penetration factors,  which are computed as FCTA, FCTB, etc.
!    Thus they are set to be zero if penetration is weak.   Parameter
!    PENETRATION controls this threshold.
!
!    There are two recurrence formula for the computation of EM fields
!    in layered earths.  One is the Wait recursion equation and the
!    other is the Knight-Raiche recursion equation.  They both are
!    built in this routine.  Choose proper values for the parameter
!    KWAIT in the parameter list to switch between them.  The Knight-Raiche
!    recursion can be found in Geophysics, Vol. 47,  p 47-50,  1982.
!    See also Schmucker and Weidelt,  Lecture notes on electromagnetic
!    induction in the earth,  Aarhus,  1975.
!
!****    CALLED by:  hfill, hfilh, simpsn
!
!****    CALLS    :  none
!
!
!  -- Use module to pass RMU into this routine directly from the
!     main program.  RMU is allocated as RMU(NLYR) where NLYR=MLAYER.
!     RMU:     relateive permeabilities of the layers.
!              Note that the current version of this kernel routine does not
!              allow sources in layers with mu/=1.  Only one recurrence
!              relation is modified to take into account mu/=1.  Further
!              verifications may be necessary.
!     A new array RMU0 is introduced below to extend the dimenion of RMU
!     to 0:MLAYER
!
      USE MG_Input_routines, ONLY: RMU
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) ::  KANIS,KCHRG,KEMD,KITG,KPRM,KRHO,          &
                              MLAYER,NOB,NSR,KEYG
      REAL, INTENT(IN) :: LUMBDA,ZOB,ZSR,ZSRH,ZSRL,                     &
                          LRYTH(MLAYER),HVK(0:MLAYER),ZBND(0:MLAYER)
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER)
      COMPLEX, INTENT(OUT) :: FKNS(11)
!
!  -- FKNS is single precision output of the kernels FKN
      COMPLEX (KIND=8) :: FKN(11)
!
! --- Note the parameter LAYERM must have a value greater than or
!     equal to that in the main program
!
      INTEGER, PARAMETER :: LAYERM=200
!
!  -- Arrays RMU0, RMUMN, and RMUPL are the only parameters in this routine
!     that take into account of magentic permeabilities. ARRAY KKH is assigned
!     with permeability info in computing the complex conductivities in routine
!     CMPLX_CD_1D.
!
      REAL :: RMU0(0:LAYERM)
      REAL (KIND=8) :: RMUMN(0:LAYERM),RMUPL(0:LAYERM)
!
      COMPLEX (KIND=8) :: ZMN(LAYERM),ZPL(LAYERM),YMN(LAYERM),                &
                          YPL(LAYERM),NUMN(0:LAYERM),NUPL(0:LAYERM),          &
                          GMMN(0:LAYERM),GMPL(0:LAYERM),UMN(0:LAYERM),        &
                          UPL(0:LAYERM),VMN(0:LAYERM),VPL(0:LAYERM),          &
                          TANH1,TANH2,RMN,RPL,XMN,XPL,U0,V0,NU0,GM0,UI,VI,    &
                          A1,B1,C1,D1,P1,Q1,A2,B2,C2,D2,P2,Q2,                &
                          AE1,BE1,CE1,DE1,PE1,QE1,                            &
                          AE2,BE2,CE2,DE2,PE2,QE2,                            &
                          FCTA,FCTB,FCTC,FCTD,FCTP,FCTQ,                      &
                          EXPA,EXPB,EXPC,EXPD,EXPP,EXPQ,                      &
                          CAB,CCD,CPQ,CAB1,CCD1,CPQ1,DG,                      &
                          PAB,PCD,PPQ,PAB1,PCD1,PPQ1,DCAB,DCAB1,DCCD,DCCD1,   &
                          EA1,EA2,EB1,EB2,EC1,EC2,ED1,ED2,EP1,EP2,EQ1,EQ2,    &
!
!  --- The following three lines are for the computation of the
!      fields in the source layer using Knight and Raiche's recurrrence
!      formula.
!
                 KMN(0:LAYERM),KPL(0:LAYERM),RRU,RRUPL0,RRUMN0,      &
                 SMN0,SPL0,FMN(0:LAYERM),FPL(0:LAYERM)
!
! --- Parameter KWAIT determines whether Wait's recurssion or
!     Knight and Raiche's recursion formula are to be used to compute the
!     kernel coefficients in the source layer.
!       KWAIT=1:  Wait recursion; =0:  Knight-Raiche recursion.
!
      INTEGER, PARAMETER :: KWAIT=0
!
      INTEGER ::  L,LMN,LPL,MPLUS,NMINUS,NOB1
!
! --- For double precision computations PENETRATION should be at least 1.E-12
!
      REAL, PARAMETER :: EMAX=10.,PENETRATION=1.E-12
!      REAL (KIND=8), PARAMETER :: PENETRATION=1.D-12
!
! --- Use KANIS so that no warning message may be issued by the complier
!
      INTEGER :: WASTE
      WASTE=KANIS
      WASTE=WASTE*1

      FKN = (0.D0, 0.D0)  !^^^^^^^^^^^^^^^^^^  APR initisialisation 28 June, 2001

! --- No analytical integration of the kernels if the primary
!     contributions need to be abstracted with source and receiver
!     being in different layers.
!
      IF (KITG==1.AND.KPRM==0.AND.NSR/=NOB) THEN
         WRITE (*,*) 'Routine kernel not ready for kitg=1 and ',   &
                   'kprm=0 and nsr.ne.nob!'
         STOP 'Program aborted.'
      END IF
!
!     Extend the dimesion of RMU from 1:MLAYER to 0:MLAYER using another array RMU0.
!
      RMU0(0)=1.
      RMU0(1:MLAYER)=RMU(1:MLAYER)
!
! --- Transform the actual layer sequence into the sequence numbered
!     downwards and upperwards with source in layer number 0 as shown
!     in Fig. 1 (of Xiong, GEOPHYSICS); and calculate the impedances
!     ZMN and ZPL.
!
!     It is assumed that there is at least one layer boundary in the
!     space.
!
!  -- MMINUS:  number of the -layers
!     MPLUS:   number of the +layers
!
      NMINUS=NSR
      MPLUS=MLAYER-NSR
!
!  -- Layer parameters
!
      DO L=0,NMINUS
         LMN=NSR-L
         KMN(L)=CSQRT(KKH(LMN))
         RMUMN(L)=RMU0(LMN)
         UMN(L)=CSQRT(CMPLX(LUMBDA**2,0.)+KKH(LMN))
         IF (ABS(HVK(LMN)-1.)>=.00001) THEN
            VMN(L)=CSQRT(CMPLX((LUMBDA*HVK(LMN))**2,0.)+KKH(LMN))
         ELSE
            VMN(L)=UMN(L)
         END IF
         NUMN(L)=1.D0/UMN(L)
         GMMN(L)=KKH(LMN)/VMN(L)
      END DO
!
      IF (MPLUS>0) THEN
         KPL(0)=KMN(0)
         UPL(0)=UMN(0)
         VPL(0)=VMN(0)
         NUPL(0)=NUMN(0)
         GMPL(0)=GMMN(0)
      END IF
!
      DO L=1,MPLUS
         LPL=NSR+L
         KPL(L)=CSQRT(KKH(LPL))
         RMUPL(L)=RMU0(LPL)
         UPL(L)=CSQRT(CMPLX(LUMBDA**2,0.)+KKH(LPL))
         IF (ABS(HVK(LPL)-1.)>=.00001) THEN
            VPL(L)=CSQRT(CMPLX((LUMBDA*HVK(LPL))**2,0.)+KKH(LPL))
         ELSE
            VPL(L)=UPL(L)
         END IF
         NUPL(L)=1.D0/UPL(L)
         GMPL(L)=KKH(LPL)/VPL(L)
      END DO
!
!  -- Recursion
!
      IF (NMINUS/=0) THEN
!
         ZMN(NMINUS)=-NUMN(NMINUS)
         YMN(NMINUS)=-GMMN(NMINUS)
         IF (KWAIT==0) THEN
            FMN(NMINUS)=(0.D0,0.D0)
         END IF
!
         DO L=NMINUS-1,1,-1
            LMN=NSR-L
            CAB=-2.*UMN(L)*LRYTH(LMN)
            IF (REAL(CAB)>-200.) THEN
               EA1=EXP(CAB)
            ELSE
               EA1=(0.D0,0.D0)
            END IF
            IF (ABS(HVK(LMN)-1.)>=.00001) THEN
               CAB=-2.*VMN(L)*LRYTH(LMN)
               IF (REAL(CAB)>-200.) THEN
                  EA2=EXP(CAB)
               ELSE
                  EA2=(0.D0,0.D0)
               END IF
            END IF
            TANH1=((1.D0,0.D0)-EA1)/((1.D0,0.D0)+EA1)
            IF (ABS(HVK(LMN)-1.)>=.00001) THEN
               TANH2=((1.D0,0.D0)-EA2)/((1.D0,0.D0)+EA2)
            ELSE
               TANH2=TANH1
            END IF
!
!  --- Note that the impedances Z and Y must be computed for
!      propagation of fields in other layers even if KWAIT=0.
!
            ZMN(L)=NUMN(L)*(ZMN(L+1)-NUMN(L)*TANH1)   &
                 /(NUMN(L)-ZMN(L+1)*TANH1)
            YMN(L)=GMMN(L)*(YMN(L+1)-GMMN(L)*TANH2)   &
                 /(GMMN(L)-YMN(L+1)*TANH2)
!
            IF (KWAIT==0) THEN
!   --- RRU is the Knight-Raiche R with both the numerator and the
!       denominator being multiplied by (u_i+u_{i+1)) for better accuracy
!               RRU=(KMN(L)**2-KMN(L+1)**2)/(UMN(L)+UMN(L+1))**2
!               RRU=(KMN(L)-KMN(L+1))*(KMN(L)+KMN(L+1))/(UMN(L)+UMN(L+1))**2
!    ** Relative mu is added to the recurrence relation (computing RRU is the ONLY parameter
!       mu is taken into account in this version)
               RRU=(RMUMN(L+1)*UMN(L)-RMUMN(L)*UMN(L+1))/(RMUMN(L+1)*UMN(L)+RMUMN(L)*UMN(L+1))
               FMN(L)=EA1*(RRU+FMN(L+1))/((1.D0,0.D0)+RRU*FMN(L+1))
            END IF
!
         END DO
!
      END IF
!
      IF (MPLUS/=0) THEN
!
         ZPL(MPLUS)=NUPL(MPLUS)
         YPL(MPLUS)=GMPL(MPLUS)
         IF (KWAIT==0) THEN
            FPL(MPLUS)=(0.D0,0.D0)
         END IF
!
         DO L=MPLUS-1,1,-1
            LPL=NSR+L
            CAB=-2.*UPL(L)*LRYTH(LPL)
            IF(REAL(CAB)>-200.) THEN
               EA1=EXP(CAB)
            ELSE
               EA1=(0.D0,0.D0)
            END IF
            IF (ABS(HVK(LPL)-1.)>=.00001) THEN
               CAB=-2.*VPL(L)*LRYTH(LPL)
               IF(REAL(CAB)>-200.) THEN
                  EA2=EXP(CAB)
               ELSE
                  EA2=(0.D0,0.D0)
               END IF
            END IF
            TANH1=((1.D0,0.D0)-EA1)/((1.D0,0.D0)+EA1)
            IF (ABS(HVK(LPL)-1.)>=.00001) THEN
               TANH2=((1.D0,0.D0)-EA2)/((1.D0,0.D0)+EA2)
            ELSE
               TANH2=TANH1
            END IF
            ZPL(L)=NUPL(L)*(ZPL(L+1)+NUPL(L)*TANH1)   &
                 /(NUPL(L)+ZPL(L+1)*TANH1)
            YPL(L)=GMPL(L)*(YPL(L+1)+GMPL(L)*TANH2)   &
                 /(GMPL(L)+YPL(L+1)*TANH2)
!
            IF (KWAIT==0) THEN
!   --- RRU is the Knight-Raiche R with both the numerator and the
!       denominator being multiplied by (u_i+u_{i+1)) for better accuracy
!               RRU=(KPL(L)**2-KPL(L+1)**2)/(UPL(L)+UPL(L+1))**2
!               RRU=(KPL(L)-KPL(L+1))*(KPL(L)+KPL(L+1))/(UPL(L)+UPL(L+1))**2
!    ** Relative mu is added to the recurrence relation (computing RRU is the ONLY parameter
!       mu is taken into account in this version)
               RRU=(RMUPL(L+1)*UPL(L)-RMUPL(L)*UPL(L+1))/(RMUPL(L+1)*UPL(L)+RMUPL(L)*UPL(L+1))
               FPL(L)=EA1*(RRU+FPL(L+1))/((1.D0,0.D0)+RRU*FPL(L+1))
            END IF
!
         END DO
!
      END IF
!
! --- The coefficients A0,B0,C0.,P0, and Q0 in the source layer
!     are separated into A1*EXP(AE1)+A2*EXP(AE2),... +Q2*EXP(QE2),
!     respectively, in which "1" represents the terms with EXP(+U0 Z')
!     and "2" represents those with EXP(-U0 Z). But the two exponetial
!     functions (EXP(+U0 Z') etc.) are not included here.
!
!     Note: the radiation conditions are automatically considered here
!           and the calculation is kept to the minimum for every special
!           case possible.
!
      U0=UMN(0)
      V0=VMN(0)
      NU0=NUMN(0)
      GM0=GMMN(0)
!
!  -- If the source is located neither in the upper-most nor in the
!     lower-most layer
!
      IF (NMINUS/=0.AND.MPLUS/=0) THEN
!
         IF (KWAIT==1) THEN
            RMN=(ZMN(1)+NU0)/(ZMN(1)-NU0)
            RPL=(ZPL(1)+NU0)/(ZPL(1)-NU0)
         ELSE
!            RRUMN0=(KMN(0)**2-KMN(1)**2)/(UMN(0)+UMN(1))**2
            RRUMN0=(KMN(0)-KMN(1))*(KMN(0)+KMN(1))/(UMN(0)+UMN(1))**2
            SMN0=(RRUMN0+FMN(1))/((1.D0,0.D0)+RRUMN0*FMN(1))
            RMN=SMN0
!            RRUPL0=(KPL(0)**2-KPL(1)**2)/(UPL(0)+UPL(1))**2
            RRUPL0=(KPL(0)-KPL(1))*(KPL(0)+KPL(1))/(UPL(0)+UPL(1))**2
            SPL0=(RRUPL0+FPL(1))/((1.D0,0.D0)+RRUPL0*FPL(1))
            RPL=(1.D0,0.D0)/SPL0
         END IF
         XMN=(YMN(1)+GM0)/(YMN(1)-GM0)
         XPL=(YPL(1)+GM0)/(YPL(1)-GM0)
         CAB=-2.*U0*LRYTH(NSR)
         IF (REAL(CAB)>-200.) THEN
            EA1=EXP(CAB)
         ELSE
            EA1=(0.D0,0.D0)
         END IF
         EA2=RPL-RMN*EA1
         A1=LUMBDA/U0/EA2
         A2=A1*RMN
         B1=A2
         B2=B1*RPL
         IF (ABS(HVK(NSR)-1.)>=.00001) THEN
            CAB=-2.*V0*LRYTH(NSR)
            IF (REAL(CAB)>-200.) THEN
               EA1=EXP(CAB)
            ELSE
               EA1=(0.D0,0.D0)
            END IF
         END IF
         EA2=XPL-XMN*EA1
         C1=-1./LUMBDA/EA2
         C2=-C1*XMN
         D1=-C2
         D2=-D1*XPL
         P1=LUMBDA/V0/EA2
         P2=P1*XMN
         Q1=P2
         Q2=Q1*XPL
         AE1=-2.*U0*ZBND(NSR)
         AE2=-2.*U0*LRYTH(NSR)
         BE1=AE2
         BE2=2.*U0*ZBND(NSR-1)
         IF (ABS(HVK(NSR)-1.)>=.00001) THEN
            CE1=-2.*V0*ZBND(NSR)
            CE2=-2.*V0*LRYTH(NSR)
            DE2=2.*V0*ZBND(NSR-1)
         ELSE
            CE1=AE1
            CE2=AE2
            DE2=BE2
         END IF
         DE1=CE2
         PE1=CE1
         PE2=CE2
         QE1=PE2
         QE2=DE2
!
      END IF
!
!  -- If the source sits in the upper-most layer and the receiver
!     everywhere but the lower-most layer
!
!     Note that the other components that are not calculated here
!     are zero and are ignored accordingly in the other parts of
!     this routine.
!
      IF (NMINUS==0.AND.NOB/=MLAYER) THEN
         IF (KWAIT==1) THEN
            RPL=(ZPL(1)+NU0)/(ZPL(1)-NU0)
         ELSE
!            RRUPL0=(KPL(0)**2-KPL(1)**2)/(UPL(0)+UPL(1))**2
            RRUPL0=(KPL(0)-KPL(1))*(KPL(0)+KPL(1))/(UPL(0)+UPL(1))**2
            SPL0=(RRUPL0+FPL(1))/((1.D0,0.D0)+RRUPL0*FPL(1))
            RPL=(1.D0,0.D0)/SPL0
         END IF
         XPL=(YPL(1)+GM0)/(YPL(1)-GM0)
         A1=LUMBDA/U0/RPL
         C1=-1./LUMBDA/XPL
         P1=LUMBDA/V0/XPL
         AE1=-2.*U0*ZBND(NSR)
         CE1=-2.*V0*ZBND(NSR)
         PE1=CE1
      END IF
!
!  -- If the source sits in the lower-most layer and the receiver
!     everywhere but the upper-most layer
!
      IF (MPLUS==0.AND.NOB/=0) THEN
         IF (KWAIT==1) THEN
            RMN=(ZMN(1)+NU0)/(ZMN(1)-NU0)
         ELSE
!            RRUMN0=(KMN(0)**2-KMN(1)**2)/(UMN(0)+UMN(1))**2
            RRUMN0=(KMN(0)-KMN(1))*(KMN(0)+KMN(1))/(UMN(0)+UMN(1))**2
            SMN0=(RRUMN0+FMN(1))/((1.D0,0.D0)+RRUMN0*FMN(1))
            RMN=SMN0
         END IF
         XMN=(YMN(1)+GM0)/(YMN(1)-GM0)
         B2=LUMBDA/U0*RMN
         D2=XMN/LUMBDA
         Q2=LUMBDA/V0*XMN
         BE2=2.*U0*ZBND(NSR-1)
         DE2=2.*V0*ZBND(NSR-1)
         QE2=DE2
      END IF
!
! --- Separate the primary contributions according to the plus
!     and minus region after equations (20) to (27).
!
!  -- Here also the cases when the receiver is in the upper-most and
!     source is in the lower-most layer and vice versa are considered.
!
      IF (ZOB>=ZSR) THEN
!
         IF (KPRM==0.AND.NSR==NOB) THEN
!
!--- Note that the primary contributions can be omitted only if ZOB
!    and ZSR are in the same layer. Otherwise, they must be subs-
!    tracted from the final results calculated later (eq. (34) and
!    (35) etc.).
!
            B1=(0.D0,0.D0)
            D1=(0.D0,0.D0)
            Q1=(0.D0,0.D0)
         ELSEIF (NMINUS==0.OR.MPLUS==0) THEN
            B1=LUMBDA/U0
            D1=-(1.D0,0.D0)/LUMBDA
            Q1=LUMBDA/V0
         ELSEIF (ABS(HVK(NSR)-1.)>=.00001) THEN
            IF (REAL(DE1)>-200.) THEN
               CAB=EXP(DE1)
            ELSE
               CAB=(0.D0,0.D0)
            END IF
            IF (REAL(QE1)>-200.) THEN
               CCD=EXP(QE1)
            ELSE
               CCD=(0.D0,0.D0)
            END IF
            D1=D1*CAB-(1.D0,0.D0)/LUMBDA
            Q1=Q1*CCD+LUMBDA/V0
            Q1=Q1*CCD+LUMBDA/V0
         ELSE
            IF (REAL(BE1)>-200.) THEN
               EA1=EXP(BE1)
            ELSE
               EA1=(0.D0,0.D0)
            END IF
            B1=B1*EA1+LUMBDA/U0
            D1=D1*EA1-(1.D0,0.D0)/LUMBDA
            Q1=Q1*EA1+LUMBDA/V0
         END IF
         BE1=(0.D0,0.D0)
         DE1=(0.D0,0.D0)
         QE1=(0.D0,0.D0)
!
      END IF
!
      IF (ZOB<ZSR) THEN
!
         IF (KPRM==0.AND.NSR==NOB) THEN
            A2=(0.D0,0.D0)
            C2=(0.D0,0.D0)
            P2=(0.D0,0.D0)
         ELSEIF (NMINUS==0.OR.MPLUS==0) THEN
            A2=LUMBDA/U0
            C2=(1.D0,0.D0)/LUMBDA
            P2=LUMBDA/V0
         ELSEIF (ABS(HVK(NSR)-1.)>=.00001) THEN
            IF (REAL(AE2)>-200.) THEN
               CAB=EXP(AE2)
            ELSE
               CAB=(0.D0,0.D0)
            END IF
            IF (REAL(CE2)>-200.) THEN
               CCD=EXP(CE2)
            ELSE
               CCD=(0.D0,0.D0)
            END IF
            IF (REAL(PE2)>-200.) THEN
               CPQ=EXP(PE2)
            ELSE
               CPQ=(0.D0,0.D0)
            END IF
            A2=A2*CAB+LUMBDA/U0
            C2=C2*CCD+(1.D0,0.D0)/LUMBDA
            P2=P2*CPQ+LUMBDA/V0
         ELSE
            IF (REAL(AE2)>-200.) THEN
               EA1=EXP(AE2)
            ELSE
               EA1=(0.D0,0.D0)
            END IF
            A2=A2*EA1+LUMBDA/U0
            C2=C2*EA1+(1.,0)/LUMBDA
            P2=P2*EA1+LUMBDA/V0
         END IF
         AE2=(0.D0,0.D0)
         CE2=(0.D0,0.D0)
         PE2=(0.D0,0.D0)
!
      END IF
!
! --- Calculate the coefficients in other layers
!
!     Propagations of the coefficients a, b according to
!     equations (34) and (35).
!
      NOB1=NOB-NSR
!
      IF (NOB/=NSR) THEN
!
         FCTA=(1.D0,0.D0)
         FCTB=(1.D0,0.D0)
         FCTC=(1.D0,0.D0)
         FCTD=(1.D0,0.D0)
         EXPA=(0.D0,0.D0)
         EXPC=(0.D0,0.D0)
!
         IF (NOB1>=0) THEN
!
            DO L=1,NOB1
               IF (ABS(ZPL(L)-NUPL(L-1))>1.D-35) THEN
                  IF (ABS(ZPL(L)-NUPL(L))<PENETRATION*ABS(NUPL(L))) THEN
                     FCTA=(0.D0,0.D0)
                  ELSE
                     FCTA=FCTA*(ZPL(L)-NUPL(L))/(ZPL(L)-NUPL(L-1))
                  END IF
               END IF
               FCTB=FCTB*(ZPL(L)+NUPL(L))/(ZPL(L)+NUPL(L-1))
               IF (ABS(YPL(L)-GMPL(L-1))>1.D-35) THEN
                  IF (ABS(YPL(L)-GMPL(L))<PENETRATION*ABS(GMPL(L))) THEN
                     FCTC=(0.D0,0.D0)
                  ELSE
                     FCTC=FCTC*(YPL(L)-GMPL(L))/(YPL(L)-GMPL(L-1))
                  END IF
               END IF
               FCTD=FCTD*(YPL(L)+GMPL(L))/(YPL(L)+GMPL(L-1))
               EXPA=EXPA+(UPL(L-1)-UPL(L))*ZBND(NSR+L-1)
            END DO
!
         END IF
!
         IF (NOB1<0) THEN
!
            DO L=1,-NOB1
               FCTA=FCTA*(ZMN(L)-NUMN(L))/(ZMN(L)-NUMN(L-1))
               IF (ABS(ZMN(L)+NUMN(L-1))>1.D-35) THEN
                  IF (ABS(ZMN(L)+NUMN(L))<PENETRATION*ABS(NUMN(L))) THEN
                     FCTB=(0.D0,0.D0)
                  ELSE
                     FCTB=FCTB*(ZMN(L)+NUMN(L))/(ZMN(L)+NUMN(L-1))
                  END IF
               END IF
               FCTC=FCTC*(YMN(L)-GMMN(L))/(YMN(L)-GMMN(L-1))
               IF (ABS(YMN(L)+GMMN(L-1))>1.D-35) THEN
                  IF (ABS(YMN(L)+GMMN(L))<PENETRATION*ABS(GMMN(L))) THEN
                     FCTD=(0.D0,0.D0)
                  ELSE
                    FCTD=FCTD*(YMN(L)+GMMN(L))/(YMN(L)+GMMN(L-1))
                  END IF
               END IF
               EXPA=EXPA+(UMN(L-1)-UMN(L))*ZBND(NSR-L)
            END DO
!
         END IF
!
         EXPC=EXPA
         FCTP=FCTC
         FCTQ=FCTD
         EXPB=-EXPA
         EXPD=-EXPC
         EXPP=EXPC
         EXPQ=EXPD
!
         IF (.NOT.(NSR==0.AND.NOB==MLAYER.OR.NSR==MLAYER.AND.NOB==0))   &
           THEN
!
            IF (NMINUS==0) THEN
               A1=A1*FCTA
               C1=C1*FCTC
               P1=P1*FCTP
               AE1=AE1+EXPA
               CE1=CE1+EXPC
               PE1=PE1+EXPP
            ELSEIF (MPLUS==0) THEN
               B2=B2*FCTB
               D2=D2*FCTD
               Q2=Q2*FCTQ
               BE2=BE2+EXPB
               DE2=DE2+EXPD
               QE2=QE2+EXPQ
            ELSE
               A1=A1*FCTA
               A2=A2*FCTA
               C1=C1*FCTC
               C2=C2*FCTC
               P1=P1*FCTP
               P2=P2*FCTP
               B1=B1*FCTB
               B2=B2*FCTB
               D1=D1*FCTD
               D2=D2*FCTD
               Q1=Q1*FCTQ
               Q2=Q2*FCTQ
               AE1=AE1+EXPA
               AE2=AE2+EXPA
               CE1=CE1+EXPC
               CE2=CE2+EXPC
               PE1=PE1+EXPP
               PE2=PE2+EXPP
               BE1=BE1+EXPB
               BE2=BE2+EXPB
               DE1=DE1+EXPD
               DE2=DE2+EXPD
               QE1=QE1+EXPQ
               QE2=QE2+EXPQ
!
            END IF
!
         END IF
!
         IF (NMINUS==0.OR.MPLUS==0) THEN
!
            IF (ZOB>=ZSR) THEN
               B1=B1*FCTB
               D1=D1*FCTD
               Q1=Q1*FCTQ
               BE1=BE1+EXPB
               DE1=DE1+EXPD
               QE1=QE1+EXPQ
            ELSE
               A2=A2*FCTA
               C2=C2*FCTC
               P2=P2*FCTP
               AE2=AE2+EXPA
               CE2=CE2+EXPC
               PE2=PE2+EXPP
            END IF
!
         END IF
!
      END IF
!
! --- Calculate the kernels of the Hankel transforms: the coefficients
!     with the expoentials of z and z'
!
      IF (NOB1>0) THEN
         UI=UPL(NOB1)
         VI=VPL(NOB1)
      ELSE
         UI=UMN(-NOB1)
         VI=VMN(-NOB1)
      END IF
!
!  -- If the source is in the upper-most layer
!
!     Due to the complexity of the if blocks,  each block level is
!     marked by *****, _____, -----, or .....
!
      IF (NMINUS==0) THEN
!   **********************************
!   *                                *
!    -- If the receiver is not in the lower-most layer
!
         IF (NOB/=MLAYER) THEN
!   ______________________________
!   !                            !

            IF (KITG==0) THEN
!    ...........................
!    .                         .
               EXPA=AE1+U0*ZSR+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  CAB=EXP(EXPA)
                  EA1=A1*CAB
                  EC1=C1*CAB
                  EP1=P1*CAB
               ELSE
                  EA1=(0.D0,0.D0)
                  EC1=(0.D0,0.D0)
                  EP1=(0.D0,0.D0)
               END IF
!    .                         .
!    ...........................
            END IF
!
            IF (KITG==1) THEN
!    ...........................
!    .                         .
               EXPA=AE1+U0*ZSRH+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  CAB=EXP(EXPA)/U0
                  EA1=A1*CAB
                  EC1=C1*CAB
                  EP1=P1*CAB
               ELSE
                  EA1=(0.D0,0.D0)
                  EC1=(0.D0,0.D0)
                  EP1=(0.D0,0.D0)
               END IF
!
               EXPA=AE1+U0*ZSRL+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  CAB=EXP(EXPA)/U0
                  EA1=EA1-A1*CAB
                  EC1=EC1-C1*CAB
                  EP1=EP1-P1*CAB
               END IF
!     .                        .
!     ..........................
            END IF
!     !                              !
!     ________________________________
         END IF
!
!    -- If the receiver is in the lower-most layer
!
         IF (NOB==MLAYER) THEN
!   ______________________________
!   !                            !
            EA1=(0.D0,0.D0)
            EC1=(0.D0,0.D0)
            EP1=(0.D0,0.D0)
!   !                            !
!   ______________________________
         END IF
!   *                                *
!   **********************************
      END IF
!
!  -- If the source is in the lower-most layer
!
      IF (MPLUS==0) THEN
!   ***********************************
!   *                                 *
         IF (NOB/=0) THEN
!   _________________________________
!   !                               !
            IF (KITG==0) THEN
!    ...........................
!    .                         .
               EXPB=BE2-U0*ZSR-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=EXP(EXPB)
                  EB2=B2*CAB
                  ED2=D2*CAB
                  EQ2=Q2*CAB
               ELSE
                  EB2=(0.D0,0.D0)
                  ED2=(0.D0,0.D0)
                  EQ2=(0.D0,0.D0)
               END IF
!    .                           .
!    .............................
            END IF
!
            IF (KITG==1) THEN
!    .............................
!    .                           .
               EXPB=BE2-U0*ZSRH-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=-EXP(EXPB)/U0
                  EB2=B2*CAB
                  ED2=D2*CAB
                  EQ2=Q2*CAB
               ELSE
                  EB2=(0.D0,0.D0)
                  ED2=(0.D0,0.D0)
                  EQ2=(0.D0,0.D0)
               END IF
!
               EXPB=BE2-U0*ZSRL-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=-EXP(EXPB)/U0
                  EB2=EB2-B2*CAB
                  ED2=ED2-D2*CAB
                  EQ2=EQ2-Q2*CAB
               END IF
!    .                            .
!    ..............................
            END IF
!    !                                  !
!    ____________________________________
         END IF
!
         IF (NOB==0) THEN
!    ____________________________________
!    !                                  !
            EB2=(0.D0,0.D0)
            ED2=(0.D0,0.D0)
            EQ2=(0.D0,0.D0)
!    !                                  !
!    ____________________________________
         END IF
!   *                                      *
!   ****************************************
      END IF
!
!  -- For sources either in the upper-most or the lower-most layers
!
      IF (NMINUS==0.OR.MPLUS==0) THEN
!   ****************************************
!   *                                      *
         IF (ZOB<ZSR) THEN
!   _____________________________________
!   !                                   !
            IF (KPRM/=0.OR.NSR/=NOB) THEN
!   ----------------------------------
!   |                                |
!
               IF (KITG==0) THEN
!
                  EXPA=AE2-U0*ZSR+UI*ZOB
                  IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                     CAB=EXP(EXPA)
                     EA2=A2*CAB
                     EC2=C2*CAB
                     EP2=P2*CAB
                  ELSE
                     EA2=(0.D0,0.D0)
                     EC2=(0.D0,0.D0)
                     EP2=(0.D0,0.D0)
                  END IF
               END IF
!
               IF (KITG==1) THEN
                  EXPA=AE2-U0*ZSRH+UI*ZOB
                  IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                     CAB=-EXP(EXPA)/U0
                     EA2=A2*CAB
                     EC2=C2*CAB
                     EP2=P2*CAB
                  ELSE
                     EA2=(0.D0,0.D0)
                     EC2=(0.D0,0.D0)
                     EP2=(0.D0,0.D0)
                  END IF
!
                  EXPA=AE2-U0*ZSRL+UI*ZOB
                  IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                     CAB=-EXP(EXPA)/U0
                     EA2=EA2-A2*CAB
                     EC2=EC2-C2*CAB
                     EP2=EP2-P2*CAB
                  END IF
               END IF
!   |                                |
!   ----------------------------------
            END IF
!
            IF (KPRM==0.AND.NSR==NOB) THEN
!   ----------------------------------
!   |                                |
               EA2=(0.D0,0.D0)
               EC2=(0.D0,0.D0)
               EP2=(0.D0,0.D0)
!   |                                |
!   ----------------------------------
            END IF
!   !                                  !
!   ____________________________________
         END IF
!
         IF (ZOB>=ZSR) THEN
!   ____________________________________
!   !                                  !
            IF (KPRM/=0.OR.NSR/=NOB) THEN
!   ---------------------------------
!   |                               |
!
               IF (KITG==0) THEN
!
                  EXPB=BE1+U0*ZSR-UI*ZOB
                  IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                     CAB=EXP(EXPB)
                     EB1=B1*CAB
                     ED1=D1*CAB
                     EQ1=Q1*CAB
                  ELSE
                     EB1=(0.D0,0.D0)
                     ED1=(0.D0,0.D0)
                     EQ1=(0.D0,0.D0)
                  END IF
!
               END IF
!
               IF (KITG==1) THEN
!
                  EXPB=BE1+U0*ZSRH-UI*ZOB
                  IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                     CAB=EXP(EXPB)/U0
                     EB1=B1*CAB
                     ED1=D1*CAB
                     EQ1=Q1*CAB
                  ELSE
                     EB1=(0.D0,0.D0)
                     ED1=(0.D0,0.D0)
                     EQ1=(0.D0,0.D0)
                  END IF
!
                  EXPB=BE1+U0*ZSRL-UI*ZOB
                  IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                     CAB=EXP(EXPB)/U0
                     EB1=EB1-B1*CAB
                     ED1=ED1-D1*CAB
                     EQ1=EQ1-Q1*CAB
                  END IF
!
               END IF
!   |                                |
!   ----------------------------------
            END IF
!
            IF (KPRM==0.AND.NSR==NOB) THEN
!   ----------------------------------
!   |                                |
               EB1=(0.D0,0.D0)
               ED1=(0.D0,0.D0)
               EQ1=(0.D0,0.D0)
!   |                                |
!   ----------------------------------
            END IF
!   !                                !
!   __________________________________
         END IF
!   *                                      *
!   ****************************************
      END IF
!
!  -- For sources neither in the upper-most nor the lower-most layers
!
      IF (NMINUS/=0.AND.MPLUS/=0) THEN
!   ****************************************
!   *                                      *
         IF (NOB/=MLAYER) THEN
!   __________________________________
!   !                                !
            IF (KITG==0) THEN
!   ...........................
!   .                         .
               EXPA=AE1+U0*ZSR+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  EP1=EXP(EXPA)
                  EA1=A1*EP1
                  EC1=C1*EP1
                  EP1=P1*EP1
               ELSE
                  EA1=(0.D0,0.D0)
                  EC1=(0.D0,0.D0)
                  EP1=(0.D0,0.D0)
               END IF
               EXPA=AE2-U0*ZSR+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  EP2=EXP(EXPA)
                  EA2=A2*EP2
                  EC2=C2*EP2
                  EP2=P2*EP2
               ELSE
                  EA2=(0.D0,0.D0)
                  EC2=(0.D0,0.D0)
                  EP2=(0.D0,0.D0)
               END IF
!   .                         .
!   ...........................
            END IF
!
            IF (KITG==1) THEN
!   ...........................
!   .                         .
               EXPA=AE1+U0*ZSRH+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  CAB=EXP(EXPA)/U0
                  EA1=A1*CAB
                  EC1=C1*CAB
                  EP1=P1*CAB
               ELSE
                  EA1=(0.D0,0.D0)
                  EC1=(0.D0,0.D0)
                  EP1=(0.D0,0.D0)
               END IF
               EXPA=AE2-U0*ZSRH+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  CAB=-EXP(EXPA)/U0
                  EA2=A2*CAB
                  EC2=C2*CAB
                  EP2=P2*CAB
               ELSE
                  EA2=(0.D0,0.D0)
                  EC2=(0.D0,0.D0)
                  EP2=(0.D0,0.D0)
               END IF
!
               EXPA=AE1+U0*ZSRL+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  CAB=EXP(EXPA)/U0
                  EA1=EA1-A1*CAB
                  EC1=EC1-C1*CAB
                  EP1=EP1-P1*CAB
               ELSE
                  EA1=EA1-(0.D0,0.D0)
                  EC1=EC1-(0.D0,0.D0)
                  EP1=EP1-(0.D0,0.D0)
               END IF
               EXPA=AE2-U0*ZSRL+UI*ZOB
               IF (REAL(EXPA)>-200..AND.REAL(EXPA)<=EMAX) THEN
                  CAB=-EXP(EXPA)/U0
                  EA2=EA2-A2*CAB
                  EC2=EC2-C2*CAB
                  EP2=EP2-P2*CAB
               ELSE
                  EA2=EA2-(0.D0,0.D0)
                  EC2=EC2-(0.D0,0.D0)
                  EP2=EP2-(0.D0,0.D0)
               END IF
!   .                         .
!   ...........................
            END IF
!   !                                !
!   __________________________________
         END IF
!
         IF (NOB==MLAYER) THEN
!   __________________________________
!   !                                !
            EA1=(0.D0,0.D0)
            EC1=(0.D0,0.D0)
            EP1=(0.D0,0.D0)
            EA2=(0.D0,0.D0)
            EC2=(0.D0,0.D0)
            EP2=(0.D0,0.D0)
!   !                                !
!   __________________________________
         END IF
!
         IF (NOB/=0) THEN
!   __________________________________
!   !                                !
!
            IF (KITG==0) THEN
!    ...........................
!    .                         .
               EXPB=BE1+U0*ZSR-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=EXP(EXPB)
                  EB1=B1*CAB
                  ED1=D1*CAB
                  EQ1=Q1*CAB
               ELSE
                  EB1=(0.D0,0.D0)
                  ED1=(0.D0,0.D0)
                  EQ1=(0.D0,0.D0)
               END IF
               EXPB=BE2-U0*ZSR-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=EXP(EXPB)
                  EB2=B2*CAB
                  ED2=D2*CAB
                  EQ2=Q2*CAB
               ELSE
                  EB2=(0.D0,0.D0)
                  ED2=(0.D0,0.D0)
                  EQ2=(0.D0,0.D0)
               END IF
!    .                          .
!    ............................
            END IF
!
            IF (KITG==1) THEN
!    ............................
!    .                          .
               EXPB=BE1+U0*ZSRH-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=EXP(EXPB)/U0
                  EB1=B1*CAB
                  ED1=D1*CAB
                  EQ1=Q1*CAB
               ELSE
                  EB1=(0.D0,0.D0)
                  ED1=(0.D0,0.D0)
                  EQ1=(0.D0,0.D0)
               END IF
               EXPB=BE2-U0*ZSRH-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=-EXP(EXPB)/U0
                  EB2=B2*CAB
                  ED2=D2*CAB
                  EQ2=Q2*CAB
               ELSE
                  EB2=(0.D0,0.D0)
                  ED2=(0.D0,0.D0)
                  EQ2=(0.D0,0.D0)
               END IF
!
               EXPB=BE1+U0*ZSRL-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=EXP(EXPB)/U0
                  EB1=EB1-B1*CAB
                  ED1=ED1-D1*CAB
                  EQ1=EQ1-Q1*CAB
               ELSE
                  EB1=EB1-(0.D0,0.D0)
                  ED1=ED1-(0.D0,0.D0)
                  EQ1=EQ1-(0.D0,0.D0)
               END IF
               EXPB=BE2-U0*ZSRL-UI*ZOB
               IF (REAL(EXPB)>-200..AND.REAL(EXPB)<=EMAX) THEN
                  CAB=-EXP(EXPB)/U0
                  EB2=EB2-B2*CAB
                  ED2=ED2-D2*CAB
                  EQ2=EQ2-Q2*CAB
               ELSE
                  EB2=EB2-(0.D0,0.D0)
                  ED2=ED2-(0.D0,0.D0)
                  EQ2=EQ2-(0.D0,0.D0)
               END IF
!    .                          .
!    ............................
            END IF
!   !                                !
!   __________________________________
         END IF
!
         IF (NOB==0) THEN
!   __________________________________
!   !                                !
            EB1=(0.D0,0.D0)
            ED1=(0.D0,0.D0)
            EQ1=(0.D0,0.D0)
            EB2=(0.D0,0.D0)
            ED2=(0.D0,0.D0)
            EQ2=(0.D0,0.D0)
!   !                                !
!   __________________________________
         END IF
!   *                                      *
!   ****************************************
      END IF
!
! --- Calculate the kernel functions of the Hankel transforms
!     in terms of CAB etc. where CAB is defined as
!         CAB =a*exp(uz)+b*exp(-uz) and
!         CAB1=a*exp(uz)-b*exp(-uz).
!     The exponential functions exp(+-uz') are contained in a and b.
!
      IF (NMINUS==0) THEN
         CAB=EA1
         CAB1=EA1
         CCD=EC1
         CCD1=EC1
         CPQ=EP1
         CPQ1=EP1
!    --   Magnetic dipole kernels
         IF (KEMD==2) THEN
            DCAB =U0*EA1
            DCAB1=U0*EA1
            DCCD =U0*EC1
            DCCD1=U0*EC1
         END IF
      ELSEIF (MPLUS==0) THEN
         CAB=EB2
         CAB1=-EB2
         CCD=ED2
         CCD1=-ED2
         CPQ=EQ2
         CPQ1=-EQ2
!
         IF (KEMD==2) THEN
            DCAB =-U0*EB2
            DCAB1= U0*EB2
            DCCD =-U0*ED2
            DCCD1= U0*ED2
         END IF
      ELSE
         CAB=EA1+EA2+EB1+EB2
         CAB1=EA1+EA2-EB1-EB2
         CCD=EC1+EC2+ED1+ED2
         CCD1=EC1+EC2-ED1-ED2
         CPQ=EP1+EP2+EQ1+EQ2
         CPQ1=EP1+EP2-EQ1-EQ2
         IF (KEMD==2) THEN
            DCAB =U0*(EA1-EA2+EB1-EB2)
            DCAB1=U0*(EA1-EA2-EB1+EB2)
            DCCD =U0*(EC1-EC2+ED1-ED2)
            DCCD1=U0*(EC1-EC2-ED1+ED2)
         END IF
      END IF
      IF (NMINUS==0.OR.MPLUS==0) THEN
         IF (ZOB>=ZSR) THEN
            CAB=CAB+EB1
            CAB1=CAB1-EB1
            CCD=CCD+ED1
            CCD1=CCD1-ED1
            CPQ=CPQ+EQ1
            CPQ1=CPQ1-EQ1
            IF (KEMD==2) THEN
               DCAB =DCAB +U0*EB1
               DCAB1=DCAB1-U0*EB1
               DCCD =DCCD +U0*ED1
               DCCD1=DCCD1-U0*ED1
            END IF
         ELSE
            CAB=CAB+EA2
            CAB1=CAB1+EA2
            CCD=CCD+EC2
            CCD1=CCD1+EC2
            CPQ=CPQ+EP2
            CPQ1=CPQ1+EP2
            IF (KEMD==2) THEN
               DCAB =DCAB -U0*EA2
               DCAB1=DCAB1-U0*EA2
               DCCD =DCCD -U0*EC2
               DCCD1=DCCD1-U0*EC2
            END IF
         END IF
      END IF
!
!  ---- Now finally,  the kernel functions FKN.  Note
!       that they are corrected for various purposes
!
!  --- Electric dipoles
!
      IF (KEMD==1) THEN
!   **************************************
!   *                                    *
!
         IF (KPRM==1.OR.NSR==NOB) THEN
!   ___________________________________
!   !                                 !
!
!  ---  If rho=0,  only the first 4 element of fkn are needed.
!
            IF (KRHO==0) THEN
!   ---------------------------------
!   |                               |
!
!  --- Remove the charge terms from the kernels if KCHRG=1
!
!      Exx, Eyy and Ezz have different factors before the
!      integral before and after the charge term is removed.
!      This is taken into account here.
!
               IF (KEYG==1.OR.KEYG==2) THEN
                  IF (KCHRG==0) THEN
                     FKN(1)=.5*(KKH(NOB)*CAB+LUMBDA**2*VI*CCD1)
                     FKN(2)=LUMBDA**2*CPQ*HVK(NSR)**2
                  ELSE
                     FKN(1)=KKH(NOB)*CAB
                     FKN(2)=-KKH(NOB)*CPQ*HVK(NSR)**2
                  END IF
               END IF
               IF (KEYG==2) FKN(3)=.5*(UI*CAB1+LUMBDA**2*CCD)
!
               IF (KEYG==3.OR.KEYG==4) THEN
                  FKN(1)=CAB
                  FKN(2)=CPQ
                  FKN(3)=VI*CPQ1
               END IF
!        --  FKN(4) for KEYG=4 is identical to FKN(3) for KEYG=2
               IF (KEYG==4) FKN(4)=.5*(UI*CAB1+LUMBDA**2*CCD)
!
!   |                               |
!   ---------------------------------
            END IF
!
!  --- The general case with rho .ne. 0
!
            IF (KRHO/=0) THEN
!   ---------------------------------
!   |                               |
!
!  --- Corrections to the kernels for impoved filtering accuracy
!
!      FKN(2) and FKN(5) tends to 2*LUMBDA**2 as LUMBDA goes to
!      infinity for z=z'=0.  Since FKN(5) is related to z components
!      of the electric field which are not measured at the earth's
!      surface,  it is not corrected here.  For z' and z < 0, most
!      kernels for the electric field goes to LUMBDA**2 as LUMBDA
!      goes to infinity.  Since no electric field are measured in
!      such cases,  they will not be corrected here.
!
!      FKN(10) goes to LUMBDA as LUMBDA goest to infinity (CAB goes
!      to 1).  FKN(10) is related to Hzx and Hzy.  It is also
!      corrected on the earth's surface.
!
!      The filters used in this program (the filter for functions
!      with opening angle of analycity of pi/4) yield accurate
!      results even for kernels without correction.  However,
!      corrected kernel may allow the use of filters with much
!      higher accuracy (such as those for functions with opening
!      angle of analycity of pi/2 which decays not as fast as
!      the filter for pi/4)
!
!      The corrections must also be done in the routines computing
!      the electric fields,  routine ONE_D_GREEN.   Since z and z' will
!      never be zero in the routine THR_D_GREEN,  no corrections are
!      needed there.
!
               IF (KEYG==1.OR.KEYG==2) THEN
!
                  FKN(1)=CAB
                  IF (KCHRG==0) THEN
                     FKN(2)=LUMBDA**2*CCD1*VI-KKH(NOB)*CAB
!   -- Correct the kernels
                     IF (ABS(ZOB)<.001.AND.ABS(ZSR)<.001) FKN(2)=FKN(2)   &
                       -CMPLX(2.*LUMBDA**2,0.)
                     FKN(3)=LUMBDA**2*CPQ*HVK(NSR)**2
                  ELSE
!   -- Remove the charge terms
                     FKN(2)=(0.D0,0.D0)
!  --- Note that the factor before the integral for Gzz after
!      removing the charge term is also different.  In order to
!      simplify routine ONE_D_GREEN,  this factor is considered here.
                     FKN(3)=-KKH(NOB)*CPQ*HVK(NSR)**2
                  END IF
!
                  IF (KCHRG==0) THEN
                     FKN(4)=LUMBDA*CCD1*VI-KKH(NOB)/LUMBDA*CAB
                     FKN(5)=LUMBDA**3*CCD*HVK(NSR)**2
                     FKN(6)=LUMBDA*CPQ1*VI*HVK(NSR)**2
                  ELSE
                     FKN(4)=(0.D0,0.D0)
                     FKN(5)=-KKH(NOB)*(LUMBDA*CCD-UI/LUMBDA*CAB1)
                     FKN(6)=(0.D0,0.D0)
                  END IF
!
               END IF
!
               IF (KEYG==3.OR.KEYG==4) THEN
!   ---  FKN(1) and FKN(4) are identical to those for KEYG=1 and 2
                  FKN(1)=CAB
                  FKN(2)=CPQ
                  FKN(3)=VI*CPQ1
                  FKN(4)=LUMBDA*CCD1*VI-KKH(NOB)/LUMBDA*CAB
!   --- The fifth kernel for G^x_z for J1 transform are identical
!       to the 9th kernel for the magnetic field.
                  FKN(5)=LUMBDA*CCD-UI/LUMBDA*CAB1
               END IF
!
               IF (KEYG==2.OR.KEYG==4) THEN
                  FKN(7)=LUMBDA**2*CCD-UI*CAB1
                  FKN(8)=UI*CAB1
                  FKN(9)=LUMBDA*CCD-UI/LUMBDA*CAB1
               END IF
!
!  --- Corrections on cab for sources and receivers in the air
!      and on the air-earth interface.
!      Here 1.E-3 is regarded as zero.
!
               IF (KEYG==2.OR.KEYG==4) THEN
                  IF ((ZSR<0..AND.ZOB<0.).AND.   &
                    (ABS(ZSR)>=1.E-3.OR.ABS(ZOB)>=1.E-3)) THEN
                     FKN(10)=LUMBDA*(CAB-LUMBDA/U0*(EXP(-U0*ABS(ZOB-ZSR))   &
                           -EXP(U0*(ZSR+ZOB))))
                  ELSEIF (ABS(ZSR)<1.E-3.AND.ABS(ZOB)<1.E-3) THEN
                     FKN(10)=LUMBDA*(CAB-(1.D0,0.D0))
                  ELSE
                     FKN(10)=LUMBDA*CAB
                  END IF
                  FKN(11)=LUMBDA*CPQ*HVK(NSR)**2
               END IF
!   |                               |
!   ---------------------------------
            END IF
!   !                                 !
!   ___________________________________
         END IF
!
! ---- Note that the primary parts are now substracted from the
!      final results if Z' and Z are not in the same layer
!
         IF (KPRM==0.AND.NSR/=NOB) THEN
!   ___________________________________
!   !                                 !
            IF (ZOB>=ZSR) THEN
!   ---------------------------------
!   |                               |
               EXPA=EXP(U0*ZSR-U0*ZOB)
               EB1=LUMBDA/U0*EXPA
               ED1=-1./LUMBDA*EXPA
               EQ1=LUMBDA/V0*EXPA
               PAB=EB1
               PAB1=-EB1
               PCD=ED1
               PCD1=-ED1
               PPQ=EQ1
               PPQ1=-EQ1
!   |                               |
!   ---------------------------------
            END IF
!
            IF (ZOB<ZSR) THEN
!   ---------------------------------
!   |                               |
               EXPA=EXP(-U0*ZSR+U0*ZOB)
               EA2=LUMBDA/U0*EXPA
               EC2=1./LUMBDA*EXPA
               EP2=LUMBDA/V0*EXPA
               PAB=EA2
               PAB1=EA2
               PCD=EC2
               PCD1=EC2
               PPQ=EP2
               PPQ1=EP2
!   |                               |
!   ---------------------------------
            END IF
!
            IF (KRHO==0) THEN
!   ---------------------------------
!   |                               |
!
               IF (KEYG==1.OR.KEYG==2) THEN
                  IF (KCHRG==0) THEN
                     FKN(1)   &
                      =.5*(KKH(NOB)*CAB-KKH(NSR)*PAB+LUMBDA**2*(VI*   &
                      CCD1-V0*PCD1))
                     FKN(2)=LUMBDA**2*(CPQ-PPQ)*HVK(NSR)**2
                  ELSE
                     FKN(1)=KKH(NOB)*(CAB-PAB)
                     FKN(2)=-KKH(NOB)*(CPQ-PPQ)*HVK(NSR)**2
                  END IF
               END IF
               IF (KEYG==2) FKN(3)   &
                 =.5*(UI*CAB1-U0*PAB1+LUMBDA**2*(CCD-PCD))
!
               IF (KEYG==3.OR.KEYG==4) THEN
                  FKN(1)=CAB-PAB
                  FKN(2)=CPQ-PPQ
                  FKN(3)=VI*CPQ1-V0*PPQ1
               END IF
               IF (KEYG==4) FKN(4)   &
                 =.5*(UI*CAB1-U0*PAB1+LUMBDA**2*(CCD-PCD))
!   |                               |
!   ---------------------------------
            END IF
!
            IF (KRHO/=0) THEN
!   ---------------------------------
!   |                               |
!  --- Remove the charge terms from the kernels if KCHRG=1
!
!  !! This will never happen since KCHRG is set to zero in
!     routine THR_D_HF_TABLE where KPRM can be 0 for separating the
!     primary and the secondary Green's functions.
!
               IF (KEYG==1.OR.KEYG==2) THEN
!
                  FKN(1)=CAB-PAB
                  IF (KCHRG==0) THEN
                     FKN(2)=LUMBDA**2*(CCD1*VI-PCD1*V0)   &
                          -(KKH(NOB)*CAB-KKH(NSR)*PAB)
                     FKN(3)=LUMBDA**2*(CPQ-PPQ)*HVK(NSR)**2
                  ELSE
                     FKN(2)=(0.D0,0.D0)
                     FKN(3)=-KKH(NOB)*(CPQ-PPQ)*HVK(NSR)**2
                  END IF
!
                  IF (KCHRG==0) THEN
                     FKN(4)=LUMBDA*(CCD1*VI-PCD1*V0)   &
                          -(KKH(NOB)*CAB-KKH(NSR)*PAB)/LUMBDA
                     FKN(5)=LUMBDA**3*(CCD-PCD)*HVK(NSR)**2
                     FKN(6)=LUMBDA*(CPQ1*VI-PPQ1*V0)*HVK(NSR)**2
                  ELSE
                     FKN(4)=(0.D0,0.D0)
                     FKN(5)=-KKH(NOB)*(LUMBDA*CCD-UI/LUMBDA*CAB1)+KKH(NSR)   &
                          *(LUMBDA*PCD-U0/LUMBDA*PAB1)
                     FKN(6)=(0.D0,0.D0)
                  END IF
!
               END IF
!
               IF (KEYG==3.OR.KEYG==4) THEN
                  FKN(1)=CAB-PAB
                  FKN(2)=CPQ-PPQ
                  FKN(3)=VI*CPQ1-V0*PPQ1
                  FKN(4)=LUMBDA*(CCD1*VI-PCD1*V0)   &
                       -(KKH(NOB)*CAB-KKH(NSR)*PAB)/LUMBDA
                  FKN(5)=LUMBDA*(CCD-PCD)-(UI*CAB1-U0*PAB1)/LUMBDA
               END IF
!
               IF (KEYG==2.OR.KEYG==4) THEN
                  FKN(7)=LUMBDA**2*(CCD-PCD)-(UI*CAB1-U0*PAB1)
                  FKN(8)=UI*CAB1-U0*PAB1
                  FKN(9)=LUMBDA*(CCD-PCD)-(UI*CAB1-U0*PAB1)/LUMBDA
               END IF
!
               IF (KEYG==2.OR.KEYG==4) THEN
                  FKN(10)=LUMBDA*(CAB-PAB)
                  FKN(11)=LUMBDA*(CPQ-PPQ)*HVK(NSR)**2
               END IF
!   |                               |
!   ---------------------------------
            END IF
!   !                                 !
!   ___________________________________
         END IF
!   *                                    *
!   **************************************
      END IF
!
!  --- Magnetic dipoles
!
      IF (KEMD==2) THEN
!   **************************************
!   *                                    *
!
!   -- Kernel for magnetic dipoles do not separate primary and
!      secondary parts if source and receiver are not in the
!      same layer.  However,  this can be readily modified by
!      following the computations above for the electric dipoles
!      (extra computation of PAB etc.).
!
         IF (KPRM==0.AND.NSR/=NOB) THEN
            WRITE (*,1010)
!            WRITE (4,1010)
            STOP 'Program aborted.  Check error messages in Marco.out'
         END IF
!
         IF (KRHO/=0) THEN
!   ___________________________________
!   !                                 !
!
!   -- In order to make the output compatible with the electric
!      dipoles cases so that routine HFIL needs not
!      be changed,  here the output FKN are order in the same way
!      as for the electric dipoles, namely, FKN(1-3) and FKN(7-8)
!      are for the J0 transforms and the rest are for the J1
!      transforms.  Since only 8 distinctive kernels exist for
!      the magnetic dipoles,  some elements of FKN are not used.
!      Note that in Exx, Eyx, etc. of the following comments the
!      first indices are for the field compoments directions and
!      the second indices are for the source orientations.
!
!      On the earth's surface CAB and CAB1 goes to 1, DCAB and
!      DCAB1 goes to LUMBDA as LUMBDA goes to infinity.
!
!      Note that all kernels for both the electric fields and the
!      magnetic fields are computed although sometimes only one
!      set of them are required.  The following computations are
!      trivial in CPU times as compared to that needed by the other
!      parts of this routine.
!
            DG=DCCD-DCAB1*UI/LUMBDA/LUMBDA
!
            FKN(1)=VI*(HVK(NSR)**2*CPQ1+DCCD1)*LUMBDA*LUMBDA-KKH(NOB)*DCAB
            FKN(2)=DCAB
            FKN(3)=UI*DCAB1
            FKN(4)=VI*(HVK(NSR)**2*CPQ1+DCCD1)*LUMBDA-KKH(NOB)*DCAB/LUMBDA
            FKN(5)=HVK(NSR)**2*(HVK(NOB)**2*CPQ+DCCD)*LUMBDA*LUMBDA*LUMBDA
            FKN(6)=LUMBDA*CAB
            FKN(7)=(DG+HVK(NSR)**2*CPQ)*LUMBDA*LUMBDA
            IF (KPRM==1.AND.ABS(ZSR-ZOB)<1.E-4) THEN
               FKN(8)=(CAB-(1.D0,0.D0))*LUMBDA*LUMBDA
            ELSE
               FKN(8)=CAB*LUMBDA*LUMBDA
            END IF
            FKN(9)=LUMBDA*(DG+HVK(NSR)**2*CPQ)
            FKN(10)=LUMBDA*DCAB
            FKN(11)=LUMBDA*UI*CAB1
!   !                                 !
!   ___________________________________
         END IF
!
         IF (KRHO==0) THEN
!   ___________________________________
!   !                                 !
            DG=DCCD-UI/LUMBDA**2*DCAB1
!
            FKN(1)=.5*DCAB*KKH(NOB)+.5*                                    &
                   (VI*(HVK(NSR)**2*CPQ1+DCCD1)*LUMBDA*LUMBDA) ! Eyx and Exy
            FKN(2)=UI*DCAB1+.5*LUMBDA**2*(DG+HVK(NSR)**2*CPQ)  ! Hxx and Hyy
            FKN(3)=CAB*LUMBDA*LUMBDA                           ! Hzz
!   !                                 !
!   ___________________________________
         END IF
!   *                                    *
!   **************************************
      END IF
!
! --- Conversion to single precision.  The acutaul kernels
!     may not be necessarily returned in double preaicsion
!     and need be converted to single precision.  While this
!     conversion can be done automatically on some machines,
!     some machines may have problems dealing with this.
!
!     This kernel can be designed to operated fully in double
!     precision and return all values in double precision,
!     i.e.,  the array FKN.  However,  it is better to do
!     the conversion here and return a single precision array
!     FKNS since the other parts of the program operate mainly
!     in single precision.
!
      DO L=1,11
        FKNS(L)=CMPLX(REAL(FKN(L)),AIMAG(FKN(L)),4)
      END DO
!
      RETURN
!
 1010 FORMAT ('Error: kernels for magnetic dipoles do not ',   &
            'separate primary and secondary ',/'parts if ',   &
            'source and receiver are not in the same layer.',   &
            /'Modify routine ONE_D_KERNEL if you want to.')
!
   END SUBROUTINE ONE_D_KERNEL
!
!
   SUBROUTINE ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM, &
                              KITG,KCHRG,NOB,NSR,ZOB,ZSRH,ZSRL,ALMAX,KEH,S)
!
!****   Numerical integration for the case rho = 0
!
!       The integration range is from 0 to infinity. This routine determines
!       the upper integral limit automatically by double the integration
!       interval untill convergence is reached.
!
!    Input parameters:
!
!       KEH : =1, 2, 3, or 4 represents the number of the kernel values
!              for the field components. For magnetic dipoles,  the
!              first one is for the E-fields, and the last two are for
!              the H-fields.   KEH depends on the values of KEYG and KEMD.
!
!              For electric dipoles,  KEMD=1:
!
!                KEYG=1:  KEH=2,  the two elements for the general electric
!                         Green's function;
!                KEYG=2:  KEH=3,  the first two are for the E-fields,
!                         and the third one is for the H-fields;
!                KEYG=3:  KEH=3,  the three elements for the current and
!                         charge terms of the electric Green's function.
!                         in the case of KEYG=1.  The last one is for the
!                         magnetic field (as the third element as in the
!                         case of KEYG=2);  and
!                KEYG=4:  KEH=4,  the first three elements are those as
!                         in the case of KEYG=3.  The last one is for the
!                         magnetic field (as the third element as in the
!                         case of KEYG=2).
!
!              For magnetic dipoles,  KEMD=2:
!
!                KEYG=1:  KEH=1;  and
!                KEYG=3:  KEH=2.
!
!              KEH is defined in routines THR_D_HF_TABLE and ONE_D_HF_TABLE
!              (parameter NS)
!
!       Parameters KEMD, MLAYER, ZBND, LRYTH, HVK, KKH, KANIS, KPRM,
!       KITG, KCHRG, NOB,  NSR and ALMAX are to be passed to routine
!       kernel.  See routine kernel for their descriptions.
!
!    Output parameters:
!
!       S:  Complex S(4).  Kernels for electric or magnetic fields in case
!           rho=0 (source and receiver above one another).   See the above
!           description for KEH.
!
!****  CALLED by:  gridhf, gridcs
!
!****  CALLS    :  simpsn
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: KEYG,KANIS,KCHRG,KEH,KEMD,KITG,KPRM,           &
                             MLAYER,NOB,NSR
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER)
      REAL, INTENT(IN) :: LRYTH(MLAYER),HVK(0:MLAYER),ZBND(0:MLAYER),       &
                          ALMAX,ZOB,ZSRH,ZSRL
      COMPLEX, INTENT(OUT) :: S(4)
!
      REAL :: A0,A1,B1,T
      INTEGER :: I,J,N,NINT,KRHO
      COMPLEX :: S0(4)
!
! --- EPS is the desired relative accuracy of numerical intergaration.
!
      REAL, PARAMETER :: EPS=1.E-4
!
!  -- Parameter KRHO is required by routine ONE_D_KERNEL.
!     KRHO=0 means rho is zero
!
      KRHO=0
!
      A0=1.E-8
      A1=A0
      B1=1.E-4
      T=B1-A0
      DO I=1,KEH
         S(I)=(0.,0.)
      END DO
      CALL ONE_D_SIMPSON_FOR_HANKEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,   &
                                    KRHO,KITG,KCHRG,NOB,NSR,ZOB,ZSRH,ZSRL,            &
                                    A1,B1,EPS,8,N,KEH,S0,S)
      DO J=1,KEH
         S(J)=S0(J)
      END DO
      NINT=N
  100 A1=B1
      B1=A1+T*2.
      IF (B1>ALMAX) THEN
!       WRITE (4,*)' Warning: Numerical integration did not converge.',
!    &            ' Upper limit tended to infinity.',
!    &            ' Terminated automatically.'
!       DO 2 I=1,KEH
! 2     WRITE (4,*)' Accuracy of integration: ',
!    &             CABS(S0(I))/(1.E-30+CABS(S(I)))
!
!******  Return
!
         RETURN
      END IF
      CALL ONE_D_SIMPSON_FOR_HANKEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,   &
                                    KRHO,KITG,KCHRG,NOB,NSR,ZOB,ZSRH,ZSRL,            &
                                    A1,B1,EPS,8,N,KEH,S0,S)
      DO J=1,KEH
         S(J)=S(J)+S0(J)
      END DO
      NINT=NINT+N
      T=B1-A0
      DO I=1,KEH
         IF (CABS(S0(I))>(1.E-30+CABS(S(I)))*EPS) THEN
            GOTO 100
         END IF
      END DO
!
      RETURN
!
   END SUBROUTINE ONE_D_0_2_INFTY
!
!
   SUBROUTINE ONE_D_SIMPSON_FOR_HANKEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,   &
                                       KPRM,KRHO,KITG,KCHRG,NOB,NSR,ZOB,ZSRH,ZSRL,  &
                                       A,B,EPS,K,N,KEH,S,ST)
!
!****   NUMERICAL INTEGRATION USING ONE_D_SIMPCSSON'S RULE
!       FOR A LIMITED ROI_INTERVAL [A, B]
!
!    Input parameters:
!
!      A:    Real.  Lower limit of the interval of integration.
!      B:    Real.  Upper limit of the interval of integration.
!      EPS:  Real.  Desired relative accuracy of the numerical
!            integration.
!      K:    Integer.  Miminal number of steps for the prevention
!            of false convergence.
!      ST:   Complex.  The accumulative sum of the integrals in
!            all previous intervals.  It is used to check if the
!            results for the interval [A, B] is significant for
!            accurate computation.
!
!      Parameter KEH is defined in routine ONE_D_0_2_INFTY.  See detailed
!      description in that routine.
!
!      Parameters KEMD, MLAYER, ZBND, LRYTH, HVK, KKH, KANIS, KPRM,
!      KRHO, KITG, KCHRG, NOB,  NSR,  and FKN are to be passed
!      to routine kernel.  See routine kernel for their descriptions.
!
!    Output parameters:
!
!      N:    Integer. Number of steps used for convergence.
!
!            Note that the parameter NLIM controls the maximal
!            number of steps in the integration.  In actual modeling
!            problems the numerical integration here occasionally
!            do not converge,  no matter how large NLIM is.
!            However, this have little effects on the final results.
!            But the computation can be greatly affected by NLIM.
!            NLIM is preasigned in the parameter list.
!
!      S:    Complex S(5).  Results of the integration.  Check
!            routine ONE_D_0_2_INFTY for detailed description.
!
!
!    Note that there are multiple returns and gotos due to the complexity
!    of convergence tests.  They are marked by five stars like *****.
!
!
!****   CALLED by:  simpinf
!
!****   CALLS    :  kernel
!
      IMPLICIT NONE
!
!
      INTEGER, INTENT(IN) :: KANIS,KCHRG,KEH,KEMD,KITG,KPRM,KRHO,MLAYER, &
                             NOB,NSR,KEYG
      COMPLEX, INTENT(IN) :: ST(3)
      COMPLEX, INTENT(OUT) :: S(4)
      COMPLEX :: S0(4),T1(4),T2(4),FKN(11)
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER)
      REAL, INTENT(IN) :: LRYTH(MLAYER),HVK(0:MLAYER),ZBND(0:MLAYER)
      INTEGER, INTENT(OUT) :: N
      REAL, INTENT(IN) :: A,B,EPS,ZOB,ZSRH,ZSRL
      REAL :: H,X,C
      INTEGER ::  I,J,K
      INTEGER, PARAMETER :: NLIM=1024
!
      DO I=1,KEH
         S0(I)=(0.,0.)
      END DO
!
      N=1
      C=ABS(A)+ABS(B)
      H=.5*(B-A)
!
      CALL ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KRHO, &
                        KITG,KCHRG,NOB,NSR,ZOB,(ZSRH+ZSRL)/2.,ZSRH,ZSRL,A,FKN)
!
      DO J=1,KEH
         T1(J)=H*FKN(J)
      END DO
!
      CALL ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KRHO, &
                        KITG,KCHRG,NOB,NSR,ZOB,(ZSRH+ZSRL)/2.,ZSRH,ZSRL,B,FKN)
!
      DO J=1,KEH
         T1(J)=T1(J)+H*FKN(J)
      END DO
!
!***** Branch entry point for GOTO 10
!
  100 X=A-H
      DO J=1,KEH
         T2(J)=.5*T1(J)
      END DO
      DO I=1,N
         X=X+2.*H
         CALL ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM, &
                           KRHO,KITG,KCHRG,NOB,NSR,ZOB,(ZSRH+ZSRL)/2.,     &
                           ZSRH,ZSRL,X,FKN)
         DO J=1,KEH
            T2(J)=T2(J)+H*FKN(J)
         END DO
      END DO
      DO J=1,KEH
         S(J)=.333333333*(4.*T2(J)-T1(J))
      END DO
!
! ---- K is used to prevent false convergence
!
      IF (N>K) THEN
!-------------------------------
!|                             |
!
! ---- If convrged within the interval [a,b], then return
!
         DO I=1,KEH
            IF (CABS(S(I)-S0(I))>(1.E-30+CABS(S(I)))*EPS) THEN
               GOTO 150
            END IF
         END DO
!
!***** Return
!
         RETURN
!
! ---- In case inconvergence within the interval [a,b], still
!      return if the absolut values of the integrals for this
!      interval are less than eps times the integrals over the
!      whole interval (0,b] or if step number is over NLIM.
!
!***** Branch entry point for GOTO 30
!
  150    DO I=1,KEH
            IF (CABS(S(I))>CABS(ST(I))*EPS) THEN
               GOTO 200
            END IF
         END DO
!
!***** Return
!
         RETURN
!
!***** Branch entry point for GOTO 40
!
  200    IF (N>=NLIM) THEN
            DO I=1,KEH
               S0(I)=(S(I)-S0(I))/(CABS(S(I))+CABS(ST(I))+1.E-30)
            END DO
!
! ---- Warning will be issued if the total accuracy (relative)
!      is worse than EPS
!
            DO I=1,KEH
               IF (CABS(S0(I))>EPS) THEN
!          WRITE (4,*) 'Warning: numerical integration ',
!    &                'did not converge!'
!          WRITE (4,*) ' Accuracy of integration:',
!    &                (CABS(S0(II)),II=1,KEH)
!
!***** Return
!
                  RETURN
               END IF
            END DO
!
!***** Return
!
            RETURN
         END IF
!
!|                             |
!-------------------------------
      END IF
!
      N=N+N
      H=.5*H
      DO J=1,KEH
         S0(J)=S(J)
         T1(J)=T2(J)
      END DO
!
!***** Restart of a new iteration if the step length is still
!      distinguishable by the machine.
!
      IF (ABS(C+H-C)>1.E-37) THEN
         GOTO 100
      END IF
!
      WRITE (4,*) ' Warning: numerical integration step ',      &
                  ' tends to zero. Terminated automatically',   &
                  'A, B and N =',A,B,N
!
      RETURN
!
   END SUBROUTINE ONE_D_SIMPSON_FOR_HANKEL
!
!
   SUBROUTINE ONE_D_SIMPCS(A,B,EPS,N,FK,S,RDJXYZ,AJ,CS_TYPE,KEMD,KEYG,   &
                           PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB,ZOBG,     &
                           NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
!****    Simpson integration of an arbitrary function
!
!   Input parameters:
!
!      A:    Real.  Lower limit of the interval of integration.
!      B:    Real.  Upper limit of the interval of integration.
!      EPS:  Real.  Desired relative accuracy of the numerical
!            integration.
!      FK:   external subroutine that generates NF function
!            values passed by the array F.
!      RDJXYZ: Real,  parameter to be passed to routines ONE_D_LINE
!            or ONE_D_CIRCLE.  It is either RAD for ONE_D_CIRCLE or AJXYZ
!            for ONE_D_LINE.  See routine ONE_D_CIRCLE or ONE_D_LINE for
!            descriptions of the two parameters.
!
!      Parameters CS_TYPE, KEMD, KEYG, PSTION, FRQ, MLAYER, ZBND,
!      KKH, CDH, NZOB, ZOBG, NZSR, ZSRG,  RHOMIN, NHFILM,
!      RRG, NRG, GRHF, and GRHO0 are to be passed into routine ONE_D_GREEN.
!      See ONE_D_GREEN for detailed descriptions.
!
!   Output parameters:
!
!      N:    Integer,  the number of steps used for convergence.
!      S:    Complex S(6).  Up to 6 integrals are computed
!            simultaneously.
!
!
!   Remarks:
!
!      Tests have shown that the numerical integrations need
!      be done in double precisions for circular loops because
!      of the canceling of the components.  With single
!      precisions computations the time domain magnetic fields
!      were very inaccurate.  Even with double precisions those
!      time domain results (after Fourier transform of the
!      frequency domain results) cannot have an accuracy of 1 %,
!      while the frequency domain results can supposedly have
!      an maximal accuracy of 1.E-4.  Increasing the number
!      of steps for the numerical integrations here does not
!      seem to solve the problem.
!
!    Note that this routine needs a kernel routine defined as
!    Subroutine FK(KEMD,X,NF,F) where X is the integration variable,
!    KEMD is to be passed to the routine ONE_D_GREEN which computes EM
!    field components due to dipoles, NF is the number of functions
!    to be integrated (NF <= 6),  and F (Complex F(6)) contains the
!    values of the kernel functions that are integrated.
!
!    In order to avoid double complex operation which is non-standard
!    on PCs,  complex operations are broken into double precision
!    real computations.
!
!    Note that there are multiple gotos due to the complexity of
!    convergence tests.  They are marked by five stars like *****.
!
!****  CALLED by:  csource
!
!****  CALLS    :  line, circle
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: KEMD,NZOB,NZSR,NHFILM,NRG,CS_TYPE,KEYG,MLAYER
      REAL, INTENT(IN) :: A,AJ,B,EPS
      REAL, INTENT(IN) :: RDJXYZ
      COMPLEX, INTENT(OUT) :: S(6)
!
      INTEGER :: I,J,KCONT,NF,N
      REAL :: H,SM,X,C,RS,AS
      COMPLEX :: F(6),S0(6)
      DOUBLE PRECISION RT2(6),AT2(6),RT1(6),AT1(6)
      INTEGER, PARAMETER :: K=4,NLIMT=2048
      EXTERNAL FK
!
! --- Parameters solely used for data passing
!
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER),CDH(0:MLAYER),                 &
                             GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      REAL, INTENT(IN) :: ZBND(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),         &
                          FRQ,RHOMIN,RRG(NRG),PSTION(10)
!
      DO I=1,6
         S0(I)=(0.,0.)
      END DO
!
      N=1
      C=ABS(A)+ABS(B)
      H=.5*(B-A)
!
      CALL FK(A,RDJXYZ,AJ,NF,F,CS_TYPE,KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,    &
              KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
      DO I=1,NF
         RT1(I)=DBLE(H)*DBLE(REAL(F(I)))
         AT1(I)=DBLE(H)*DBLE(AIMAG(F(I)))
      END DO
      CALL FK(B,RDJXYZ,AJ,NF,F,CS_TYPE,KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,    &
              KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
      DO I=1,NF
         RT1(I)=RT1(I)+DBLE(H)*DBLE(REAL(F(I)))
         AT1(I)=AT1(I)+DBLE(H)*DBLE(AIMAG(F(I)))
      END DO
!
!***** Branch entry point for GOTO 10
!
  100 X=A-H
      DO I=1,NF
         RT2(I)=.5D0*RT1(I)
         AT2(I)=.5D0*AT1(I)
      END DO
      DO I=1,N
         X=X+2.*H
         CALL FK(X,RDJXYZ,AJ,NF,F,CS_TYPE,KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                 KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
         DO J=1,NF
            RT2(J)=RT2(J)+DBLE(H)*DBLE(REAL(F(J)))
            AT2(J)=AT2(J)+DBLE(H)*DBLE(AIMAG(F(J)))
         END DO
      END DO
      DO I=1,NF
         RS=SNGL((4.D0*RT2(I)-RT1(I))/3.D0)
         AS=SNGL((4.D0*AT2(I)-AT1(I))/3.D0)
         S(I)=CMPLX(RS,AS)
      END DO
!
! --- K is the minimal number of steps necessary to provent
!     from false convergence
!
      IF (N>=K) THEN
!
! --- The number of steps is limited to be NLIMT
!
!     For circular loops it is very likely that the number of
!     steps exceed the designed limit and the accuracy of
!     integration is less than 1.E-4.  Thus no warnings will
!     be issued for such cases
!
         IF (N>=NLIMT) THEN
!  -- KCONT controls whether the integration should continue
            KCONT=0
            IF (ABS(B-6.28319)>.001) THEN
               SM=CABS(S(1))
               DO I=2,NF
                  IF (SM<CABS(S(I))) SM=CABS(S(I))
               END DO
!            DO I=1,NF
!               ERR=CABS(S(I)-S0(I))/(1.E-30+SM)
!              IF(ERR.GT.EPS) WRITE (4,20) ERR,I,NF
!            END DO
            END IF
         END IF
! 20     FORMAT('Warning: Number of steps for numerical ',
!             'integration exceeded maximum allowed.',
!            /'Ralative error: ',1PE11.3,'  for  I=',I2,
!             '  and  NF=',I2)
!
! --- Test convergence
!
!     Due to numerical inaccuracy,  some components may be
!     very small.  Thus the accuracy of integration is relative
!     to the maximum of all components
!
         IF (N<NLIMT) THEN
            SM=CABS(S(1))
            DO I=2,NF
               IF (SM<CABS(S(I))) SM=CABS(S(I))
            END DO
            DO I=1,NF
               IF (CABS(S(I)-S0(I))>(1.E-30+SM)*EPS) THEN
                  KCONT=1
!
!***** Goto 50
!
                  GOTO 200
               END IF
            END DO
            KCONT=0
         END IF
!
      END IF
!
! --- Reduce the step and start a new loop
!
  200 IF (N<K.OR.KCONT==1) THEN
!
         N=N+N
         DO I=1,NF
            S0(I)=S(I)
            RT1(I)=RT2(I)
            AT1(I)=AT2(I)
         END DO
         H=.5*H
!
!***** Restart of a new iteration if the step length is still
!      distinguishable by the machine.
!
         IF (ABS(C+H-C)>1.E-37) THEN
            GOTO 100
         END IF
         N=-N
         WRITE (4,*) 'Warning: Step in numerical integration tended to zero.'
!
      END IF
!
      RETURN
!
   END SUBROUTINE ONE_D_SIMPCS
!
!
   SUBROUTINE ONE_D_LINE (X,AJXYZ,AJ,NF,F,CS_TYPE,KEMD,KEYG,PSTION,FRQ,    &
                          MLAYER,ZBND,KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,  &
                          NHFILM,RRG,NRG,GRHF,GRHO0)
!
!****   Kernel for the Numerical Integration of a
!       Line Current Along the Coordinate Axes
!
!
!   Input parameters:
!
!       AJXYZ:  Real,  controlling parameter for the axis the current
!               line lies along.  AJXYZ is used to pass the integer
!               parameter JXYZ to routine ONE_D_SIMPCS.  ONE_D_SIMPCS calls
!               routines ONE_D_LINE and ONE_D_CIRCLE.  Because the first
!               parameter in the arguement list of ONE_D_CIRCLE is real,
!               the parameter AJXYZ is introduced to make the arguement
!               list of ONE_D_CIRCLE and ONE_D_LINE to be compatible.
!               The value of AJXYZ (or JXYZ) means:
!               = 1: x-direction;
!                 2: y-direction; and
!                 3: z-direction.
!       AJ:    Real(*4),  amplitude of current.  It is usually 1.
!       X:     Real,  integration vaiable.
!       KEYG:  Integer(*4),  mode of computation which controls if magnetic
!              fields need to be computed,  and thus controlling the
!              number of output functions,  NF.  KEYG is also passed into
!              routine ONE_D_GREEN.  See ONE_D_GREEN for more description.
!
!
!
!      Parameters CS_TYPE, KEMD, KEYG, PSTION, FRQ, MLAYER, ZBND,
!      KKH, CDH, NZOB, ZOBG, NZSR, ZSRG,  RHOMIN, NHFILM,
!      RRG, NRG, GRHF, and GRHO0 are to be passed into routine ONE_D_GREEN.
!      See ONE_D_GREEN for detailed descriptions.
!
!   Output parameters:
!
!       NF:    Integer,  number functions (field components) to be
!              integrated.  It is controlled by the parameter KEYG.
!              NF=3 if KEYG=1,  and NF=6 if KEYG=2.
!       F:     Complex(*8) F(6),  returned NF field components.
!              The first three elements are electric field components
!              and the last three,  if computed (KEYG=2),  are magnetic
!              field components.
!
!****  CALLED by:  csource, simp
!
!****  CALLS:      green
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: KEMD,NZOB,NZSR,NHFILM,NRG,CS_TYPE,MLAYER,KEYG
      REAL, INTENT(IN) :: PSTION(10),AJXYZ,AJ
      INTEGER, INTENT(OUT) :: NF
      COMPLEX, INTENT(OUT) :: F(6)
      COMPLEX :: ECOMP(9),HCOMP(9),                     &
                 EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,   &
                 HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ
      REAL :: X,X_LINE,Y_LINE,Z_LINE_X,Z_LINE_Y,X_Z_LINE,Y_Z_LINE,  &
              XX,X1,X2,Y1,Y2,Z1,Z2,PSTN(10)
      INTEGER :: I,JXYZ
!
! --- Parameters used solely for data passing
!
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER),CDH(0:MLAYER),                  &
                             GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      REAL, INTENT(IN) :: ZBND(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),          &
                          FRQ,RHOMIN,RRG(NRG)
!
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ),   &
                  (HCOMP(1),HXX),(HCOMP(2),HYX),(HCOMP(3),HZX),   &
                  (HCOMP(4),HXY),(HCOMP(5),HYY),(HCOMP(6),HZY),   &
                  (HCOMP(7),HXZ),(HCOMP(8),HYZ),(HCOMP(9),HZZ)
!
      X_LINE   (XX)=(Y2-Y1)/(X2-X1)*(XX-X1)+Y1  ! Y coordinate for a line along x
      Y_LINE   (XX)=(X2-X1)/(Y2-Y1)*(XX-Y1)+X1  ! X coordinate for a line along y
      Z_LINE_X (XX)=(Z2-Z1)/(X2-X1)*(XX-X1)+Z1  ! Z coordinate for a line along x
      Z_LINE_Y (XX)=(Z2-Z1)/(Y2-Y1)*(XX-Y1)+Z1  ! Z coordinate for a line along y
      X_Z_LINE (XX)=(X2-X1)/(Z2-Z1)*(XX-Z1)+X1  ! X coordinate for a line along z
      Y_Z_LINE (XX)=(Y2-Y1)/(Z2-Z1)*(XX-Z1)+Y1  ! Y coordinate for a line along z
!
      X1=PSTION(4)
      Y1=PSTION(5)
      Z1=PSTION(6)
      X2=PSTION(9)   ! pstion are defined in routine ONE_D_SOURCE
      Y2=PSTION(10)
      Z2=PSTION(8)
!
! --- Take the integer value of AJXYZ
!
      JXYZ=INT(AJXYZ+.1)
!
      IF (KEYG==1) THEN
         NF=3
      ELSE
         NF=6
      END IF
!
! --- The array PSTN is used to pass soure and receiver positions
!     to routine ONE_D_GREEN,  so that the values in the array PSTION
!     won't be altered after this routine is called.  This may not
!     be necessary here in this routine but using PSTN is much safer.
!
      DO I=1,10               ! 8 or 10
         PSTN(I)=PSTION(I)
      END DO
!
      IF (JXYZ==1) THEN
!
         PSTN(4)=X
         PSTN(5)=X_LINE(X)
         PSTN(6)=Z_LINE_X(X)
         CALL ONE_D_GREEN(CS_TYPE,KEMD,KEYG,PSTN,FRQ,MLAYER,ZBND,KKH,CDH,   &
                          NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,   &
                          GRHO0,ECOMP,HCOMP)
!
         F(1)=(EXX+EXY*(Y2-Y1)/(X2-X1)+EXZ*(Z2-Z1)/(X2-X1))*AJ
         F(2)=(EYX+EYY*(Y2-Y1)/(X2-X1)+EYZ*(Z2-Z1)/(X2-X1))*AJ
         F(3)=(EZX+EZY*(Y2-Y1)/(X2-X1)+EZZ*(Z2-Z1)/(X2-X1))*AJ
         IF (NF==6) THEN
            F(4)=(HXX+HXY*(Y2-Y1)/(X2-X1)+HXZ*(Z2-Z1)/(X2-X1))*AJ
            F(5)=(HYX+HYY*(Y2-Y1)/(X2-X1)+HYZ*(Z2-Z1)/(X2-X1))*AJ
            F(6)=(HZX+HZY*(Y2-Y1)/(X2-X1)+HZZ*(Z2-Z1)/(X2-X1))*AJ
         END IF
!
      ELSEIF (JXYZ==2) THEN
!
         PSTN(5)=X
         PSTN(4)=Y_LINE(X)
         PSTN(6)=Z_LINE_Y(X)
         CALL ONE_D_GREEN(CS_TYPE,KEMD,KEYG,PSTN,FRQ,MLAYER,ZBND,KKH,CDH,  &
                          NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,  &
                          GRHO0,ECOMP,HCOMP)
!
         F(1)=(EXY+EXX*(X2-X1)/(Y2-Y1)+EXZ*(Z2-Z1)/(Y2-Y1))*AJ
         F(2)=(EYY+EYX*(X2-X1)/(Y2-Y1)+EYZ*(Z2-Z1)/(Y2-Y1))*AJ
         F(3)=(EZY+EZX*(X2-X1)/(Y2-Y1)+EZZ*(Z2-Z1)/(Y2-Y1))*AJ
         IF (NF==6) THEN
            F(4)=(HXY+HXX*(X2-X1)/(Y2-Y1)+HXZ*(Z2-Z1)/(Y2-Y1))*AJ
            F(5)=(HYY+HYX*(X2-X1)/(Y2-Y1)+HYZ*(Z2-Z1)/(Y2-Y1))*AJ
            F(6)=(HZY+HZX*(X2-X1)/(Y2-Y1)+HZZ*(Z2-Z1)/(Y2-Y1))*AJ
         END IF
!
      ELSE
!
         IF (CS_TYPE==2) THEN
!
!     ---   Special case when all transmitters are vertical bipoles
!
            PSTN(6)=X
            CALL ONE_D_GREEN(CS_TYPE,KEMD,KEYG,PSTN,FRQ,MLAYER,ZBND,KKH,CDH,  &
                             NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,  &
                             GRHO0,ECOMP,HCOMP)
!
            F(1)=EXZ*AJ
            F(2)=EYZ*AJ
            F(3)=EZZ*AJ
            IF (NF.EQ.6) THEN
               F(4)=HXZ*AJ
               F(5)=HYZ*AJ
               F(6)=HZZ*AJ
            END IF
!
         ELSE
!
!     -- For vertical bipoles mixed with other transmitters
!
            PSTN(6)=X
            PSTN(4)=X_Z_LINE(X)
            PSTN(5)=Y_Z_LINE(X)
            CALL ONE_D_GREEN(CS_TYPE,KEMD,KEYG,PSTN,FRQ,MLAYER,ZBND,KKH,CDH,   &
                             NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,   &
                             GRHO0,ECOMP,HCOMP)
!
            F(1)=(EXZ+EXX*(X2-X1)/(Z2-Z1)+EXY*(Y2-Y1)/(Z2-Z1))*AJ
            F(2)=(EYZ+EYX*(X2-X1)/(Z2-Z1)+EYY*(Y2-Y1)/(Z2-Z1))*AJ
            F(3)=(EZZ+EZX*(X2-X1)/(Z2-Z1)+EZY*(Y2-Y1)/(Z2-Z1))*AJ

            IF (NF==6) THEN
               F(4)=(HXZ+HXX*(X2-X1)/(Z2-Z1)+HXY*(Y2-Y1)/(Z2-Z1))*AJ
               F(5)=(HYZ+HYX*(X2-X1)/(Z2-Z1)+HYY*(Y2-Y1)/(Z2-Z1))*AJ
               F(6)=(HZZ+HZX*(X2-X1)/(Z2-Z1)+HZY*(Y2-Y1)/(Z2-Z1))*AJ
            END IF
!
         END IF
!
      END IF
!
      RETURN
!
   END SUBROUTINE ONE_D_LINE
!
!
   SUBROUTINE ONE_D_CIRCLE (THETA,RAD,AJ,NF,F,CS_TYPE,KEMD,KEYG,PSTION,     &
                            FRQ,MLAYER,ZBND,KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,    &
                            RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
!****     Kernel for the Numerical Integration of a
!         Horizontal Circular Loop Current
!
!
!   Input parameters:
!
!       RAD:   Real(*4),  radius of the loop.
!       AJ:    Real, amplitude of current.  It is usually 1.
!       THETA: Real, angle of the line from the dipole location
!              on the circle to the loop center with respect to
!              the x axis.   It is the integration variable.
!              THETA is defined arbitrarily. The integration
!              should be from 0 to 2*pi.
!       KEYG:  Integer,  mode of computation which controls if magnetic
!              fields need to be computed,  and thus controlling the
!              number of output functions,  NF.  KEYG is also passed into
!              routine ONE_D_GREEN.  See ONE_D_GREEN for more description.
!
!       Parameters CS_TYPE, KEMD, KEYG, PSTION, FRQ, MLAYER, ZBND,
!       KKH, CDH, NZOB, ZOBG, NZSR, ZSRG,  RHOMIN, NHFILM,
!       GRHF, and GRHO0 are to be passed into routine ONE_D_GREEN.
!       See ONE_D_GREEN for detailed descriptions.
!
!   Output parameters:
!
!       NF:    Integer,  number functions (field components) to be
!              integrated.  It is controlled by the parameter KEYG.
!              NF=3 if KEYG=1,  and NF=6 if KEYG=2.
!       F:     Complex(*8) F(6),  returned NF field components.
!              The first three elements are electric field components
!              and the last three,  if computed (KEYG=2),  are magnetic
!              field components.
!
!
!****  CALLED by:  simp
!
!****  CALLS    :  green
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: KEMD,NZOB,NZSR,NHFILM,NRG,CS_TYPE,KEYG,MLAYER
      INTEGER, INTENT(OUT) :: NF
      COMPLEX, INTENT(OUT) :: F(6)
      REAL, INTENT(IN) :: PSTION(8),RAD,THETA,AJ
      INTEGER :: I
      REAL :: PSTN(8),SN,CS
      COMPLEX :: ECOMP(9),HCOMP(9),                         &
                 EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,       &
                 HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ
!
! --- Parameters used solely for data passing
!
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER),CDH(0:MLAYER),                  &
                             GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      REAL, INTENT(IN) :: ZBND(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),          &
                          FRQ,RHOMIN,RRG(NRG)
!
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ),   &
                  (HCOMP(1),HXX),(HCOMP(2),HYX),(HCOMP(3),HZX),   &
                  (HCOMP(4),HXY),(HCOMP(5),HYY),(HCOMP(6),HZY),   &
                  (HCOMP(7),HXZ),(HCOMP(8),HYZ),(HCOMP(9),HZZ)
!
      IF (KEYG==1) THEN
         NF=3
      ELSE
         NF=6
      END IF
!
! --- The array PSTN is used to pass soure and receiver positions
!     to routine ONE_D_GREEN,  so that the values in the array PSTION
!     won't be altered after this routine is called.  This is necessary
!     here since the x and y coordinates of the source are variables.
!
      DO I=1,8
         PSTN(I)=PSTION(I)
      END DO
!
      SN=SIN(THETA)
      CS=COS(THETA)
!
      PSTN(4)=PSTION(4)+RAD*CS
      PSTN(5)=PSTION(5)+RAD*SN
!
      CALL ONE_D_GREEN(CS_TYPE,KEMD,KEYG,PSTN,FRQ,MLAYER,ZBND,KKH,CDH,    &
                       NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,    &
                       GRHO0,ECOMP,HCOMP)
!
      F(1)=(EXX*(-SN)+EXY*CS)*RAD*AJ
      F(2)=(EYX*(-SN)+EYY*CS)*RAD*AJ
      F(3)=(EZX*(-SN)+EZY*CS)*RAD*AJ
      IF (NF==6) THEN
         F(4)=(HXX*(-SN)+HXY*CS)*RAD*AJ
         F(5)=(HYX*(-SN)+HYY*CS)*RAD*AJ
         F(6)=(HZX*(-SN)+HZY*CS)*RAD*AJ
      END IF
!
      RETURN
!
   END SUBROUTINE ONE_D_CIRCLE
!
!
   SUBROUTINE ONE_D_SOURCE (CS_TYPE,ANGLES,RECVR,NCRD,TX_CRDX,TX_CRDY,   &
                            TX_CRDZ,RAD,KEYG,KACC,FRQ,MLAYER,ZBND,AJ,    &
                            KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,          &
                            NHFILM,RRG,NRG,GRHF,GRHO0,EHFLD)
!
!****  Electromagnetic fields due to electric or magnetic sources
!
!      Fields are obtained by the integration of dipole sources
!
!
!   Input parameters:
!
!     CS_TYPE:   Integer(*4),  type of excitation and configuration.  See
!             documentation "MARCO.DOC" for description.  It is passed
!             into this routine for proper corrections to the electric
!             fields,  i.e.,  the removal of charge terms in the Green's
!             functions for current loop sources.
!     ANGLES: Real ANGLES(2),  orientations of the magnetic dipoles for
!             CS_TYPE=9.
!             The two elements of MD_ANGLE(1:2,J) contain the dip angle
!             MD_ANGLE(1,J) and the azimuthal angle MD_ANGLE(2,J) of the Jth
!             magnetic dipole.  The dip angle is the angle from the axis down
!             to the earth (note that this is the internal positive z-axis
!             which differs from the input-output z-axis that points upwards).
!             The azimuthal angle is the angle from the north,  the y-axis.
!             Thus for a vertical magnetic dipole MD_ANGLE(1,J)=180 for
!             pointing up air and MD_ANGLE(1,J) =0 for pointing down.  A
!             horizontal magnetic dipole pointing north will have MD_ANGLE(1,J)
!             =90 and MD_ANGLE(2,J)=0,  and a horizontal magnetic dipole
!             pointing east will have MD_ANGLE(1,J)=90 and MD_ANGLE(2,J)=90.
!     RECVR: Real RECVR(3),  receiver coordinates in the x, y,
!             and z-directions,  respectively.
!     NCRD:
!     TX_CRDX, TX_CRDY, TX_CRDZ: Real TX_CRDX(NCRD), TX_CRDY(NCRD),
!     TX_CRDZ(NCRD):  coordinates of electrodes (the end points of current
!             bipoles or loop corners) or the center coordinates of a
!             current loop or a magnetic dipole.   For various values of
!             CS_TYPE,  TX_CRDX, TX_CRDY,  and TX_CRDZ contain the
!             following information:
!             CS_TYPE =2, and 3:  the first two elements of TX_CRDX etc.
!                         represent the two electrodes of the bipoles;
!                     =4: the arrays TX_CRDX etc. show the coordinates
!                         of the four corner of the rectangular loop.
!                     =5, and 6: the first elements of TX_CRDX etc. contain
!                         the coordinates of the centre of the circular
!                         loop;  and
!                     =7, 8, and 9: the first elements of TX_CRDX etc.
!                         contain the coordinates of the centre of the
!                         magnetic dipole.
!     RAD:    Real,  radius of the current loop as with CS_TYPE=5 and 6.
!     KEYG:   Integer, mode of computation controlling whether mangetic
!             fields are computed.
!             KEYG=1:  Computing electric fields only.  This is used
!                      when the exciting electric fields are computed
!                      as the right hand side of the matric equation
!                      for 3D modeling;  and
!                 =2:  All components of the electric and magnetic fields
!                      are computed.
!     KACC:   Integer: parameter controlling the accuracy of the numerical
!             integration.  For approximate solutions with KACC=1, the
!             normal fields are computed to an accuracy of 1.E-3 only.
!             However,  this would be the minimal accuracy for such cases
!             since the dipole fields are computed to an accuracy of
!             1.E-7 or so.  This parameter is also used extensively in the
!             computation of scattered fields in routine THR_D_GREEN.
!     AJ:     Real,  current amplitude for electric sources or
!             dipole moment for magnetic sources.
!
!     Parameters FRQ, MLAYER, ZBND, KKH, CDH, NZOB, ZOBG, NZSR, ZSRG,
!     RHOMIN, NHFILM, RRG, NRG, GRHF, and GRHO0 are to be passed
!     into routine ONE_D_GREEN.  See ONE_D_GREEN for detailed descriptions.
!
!
!   Output parameters:
!
!     EHFLD:  Complex EHFLD(6),  components of the electric and magnetic
!             fields in the x, y, and z-directions,  respectively.
!
!
!****  CALLED by:  main, eincs, eincsgs
!
!****  CALLS    :  line, simp, green
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: NZOB,NZSR,NHFILM,NRG,MLAYER,KACC,KEYG,     &
                             CS_TYPE,NCRD
      REAL, INTENT(IN) :: RECVR(3),TX_CRDX(NCRD),TX_CRDY(NCRD),TX_CRDZ(NCRD), &
                          RAD,ANGLES(2)
      COMPLEX, INTENT(OUT) :: EHFLD(6)
!
      INTEGER ::  I,I1,I2,J,JXYZ,L,L1,L2,NF,NINT,KEMD
      REAL :: A,B,EPS,XOB,XSR,YOB,YSR,ZOB,ZSR,ZSR1,ZSR2,XSR2,YSR2
      REAL :: AJXYZ,PSTION(10),PX,PY,PZ,DIP,AZIM
      COMPLEX :: EX,EY,EZ,HX,HY,HZ,SEHS(6),                             &
                 EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,                   &
                 HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ,ECOMP(9),HCOMP(9)
      COMPLEX :: SEH(6),SEHA(6),SEH1(6)
      EQUIVALENCE (PSTION(1),XOB),(PSTION(2),YOB),(PSTION(3),ZOB),      &
                  (PSTION(4),XSR),(PSTION(5),YSR),(PSTION(6),ZSR),      &
!      --  The last four elements of PSIION are: 7 for zsr1 and 8 for zsr2
!          for a vertical bipole;  9 for xsr2 and 10 for ysr2 for an electric
!          bipole.  The z-coordinate of an electric bipole is always stored
!          in PSTION(8), both vertical or non-vertical bipoles
                  (PSTION(7),ZSR1),(PSTION( 8),ZSR2),          &

!*** pstion (8) in green and circle!  last two may not be used

                  (PSTION(9),XSR2),(PSTION(10),YSR2),          &
                  (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),         &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),         &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ),         &
                  (HCOMP(1),HXX),(HCOMP(2),HYX),(HCOMP(3),HZX),         &
                  (HCOMP(4),HXY),(HCOMP(5),HYY),(HCOMP(6),HZY),         &
                  (HCOMP(7),HXZ),(HCOMP(8),HYZ),(HCOMP(9),HZZ)
!
! --- Parameters used solely for data passing
!
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER),CDH(0:MLAYER),                  &
                             GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      REAL, INTENT(IN) :: ZBND(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),          &
                          FRQ,RHOMIN,RRG(NRG),AJ
!
!  --  EPSH and EPS! are the highest accuracies for numerical integration
!      of bipole and circular loop currents,  respecitively.  EPSL is
!      the accuracy for both of them if the code computes approximate
!      solutions only.
      REAL, PARAMETER :: EPSH=1.E-05,EPSC=1.E-4,EPSL=1.E-3
!
      EXTERNAL ONE_D_CIRCLE, ONE_D_LINE
!
!
      XOB=RECVR(1)
      YOB=RECVR(2)
      ZOB=RECVR(3)
!
!  -- Determine the accuracy of the numerical integration according
!     to the accuracy level.
!
      IF (KACC==1) THEN
         EPS=EPSL
      ELSE
         EPS=EPSH
         IF (CS_TYPE==5.OR.CS_TYPE==6) EPS=EPSC
      END IF
!
! --- CS_TYPE=7, 8, or 9 are for magnetic dipole sources
!
      IF (CS_TYPE==7.OR.CS_TYPE==8.OR.CS_TYPE==9) THEN
         KEMD=2
      ELSE
         KEMD=1
      END IF
!
      IF (CS_TYPE/=2) THEN
         ZSR1=TX_CRDZ(1)
         ZSR2=ZSR1             !*??
      END IF
!
      IF (CS_TYPE==2) THEN
!
! --- Vertical current bipole
!
!     This is a special case when all transmitters are vertical bipoles
!
         JXYZ=3
         AJXYZ=JXYZ
         XSR=TX_CRDX(1)
         XSR2=TX_CRDX(2)   ! ^^^^^^^^^^^ APR initisialisation 28 June, 2001
         YSR=TX_CRDY(1)
         YSR2=TX_CRDY(2)   ! ^^^^^^^^^^^ APR initisialisation 28 June, 2001
         ZSR=.5*(TX_CRDZ(1)+TX_CRDZ(2))
         ZSR1=TX_CRDZ(1)
         ZSR2=TX_CRDZ(2)
!
! --- Note that the Green's functions are integrated analytically
!     in the vertical direction. This also implies the restriction
!     that the vertical source must not be inclined.
!
!     The array seh is in double precision, but the routine line
!     is written in single precisions.  Thus the array sehs is
!     necessary for passing the results.
!
         CALL ONE_D_LINE(ZSR,AJXYZ,AJ,NF,SEHS,CS_TYPE,KEMD,KEYG,PSTION,   &
                         FRQ,MLAYER,ZBND,KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,     &
                         RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
         DO I=1,NF
            SEH(I)=SEHS(I)
         END DO
!
      END IF
!
      IF (CS_TYPE==3) THEN
!
!  -- Arbitrarily oriented electric bipole
!
!     To maximize accuracy the line integrations are transformed along one of the
!     three axes.  Note that vertical bipoles that are computed together with other
!     transmitters do not use the analytical integrations in the kernels, as in the
!     case of CS_TYPE=2).
!
         XSR=TX_CRDX(1)
         YSR=TX_CRDY(1)
         ZSR=TX_CRDZ(1)
         XSR2=TX_CRDX(2)
         YSR2=TX_CRDY(2)
         ZSR2=TX_CRDZ(2)
!
         IF (ABS(YSR2-YSR)>=ABS(XSR2-XSR).AND.ABS(YSR2-YSR)>=ABS(ZSR2-ZSR)) THEN
!
!  -- Integration along the y-axis
!
!     Note that this does the line integration of an arbitrarily oriented straight
!     line.  The integration is transformed to the y-axis
!
            JXYZ=2
            AJXYZ=JXYZ
            A=YSR
            B=YSR2
            CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                              KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                              ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
         ELSE IF (ABS(XSR2-XSR)>=ABS(YSR2-YSR).AND.ABS(XSR2-XSR)>=ABS(ZSR2-ZSR)) THEN
!
!  -- Integration along the x-axis
!
!     Note that this does the line integration of an arbitrarily oriented straight
!     line.  The integration is transformed to the y-axis
!
            JXYZ=1
            AJXYZ=JXYZ
            A=XSR
            B=XSR2
            CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                              KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                              ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
         ELSE
!
!  -- Integration along the z-axis
!
!     For vertical bipoles mixed with other transmitters
!
            JXYZ=3
            AJXYZ=JXYZ
            A=ZSR
            B=ZSR2
            CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                              KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                              ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
         END IF
!
      END IF
!
! --- Horizontal rectangular loop
!
      IF (CS_TYPE==4 .AND. NCRD==4) THEN
!
         IF (KEYG==1) THEN
            NF=3
         ELSE
            NF=6
         END IF
!
         DO J=1,NF
            SEH(J)=(0.,0.)
            SEH1(J)=(0.,0.)
            SEHA(J)=(0.,0.)
         END DO
!
! --- The loop L is designed to add the two current bipoles of opposit
!     direction together before the final summation in order to reduce
!     round-off errors.
!
         DO L=1,2
            IF (L==1) THEN
               L1=1
               L2=3
            ELSE
               L1=2
               L2=4
            END IF
!
            DO I=L1,L2,2
!
               I1=I
               I2=I+1
               IF (I2>4) I2=1
!
               XSR=TX_CRDX(I1)
               YSR=TX_CRDY(I1)
               ZSR=TX_CRDZ(I1)

               XSR2=TX_CRDX(I2)
               YSR2=TX_CRDY(I2)
               ZSR2=TX_CRDZ(I2)
!
         IF (ABS(YSR2-YSR)>=ABS(XSR2-XSR).AND.ABS(YSR2-YSR)>=ABS(ZSR2-ZSR)) THEN
!
!  -- Integration along the y-axis
!
            JXYZ=2
            AJXYZ=JXYZ
            A=YSR
            B=YSR2
            CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                              KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                              ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
         ELSE IF (ABS(XSR2-XSR)>=ABS(YSR2-YSR).AND.ABS(XSR2-XSR)>=ABS(ZSR2-ZSR)) THEN
!
!  -- Integration along the x-axis
!
            JXYZ=1
            AJXYZ=JXYZ
            A=XSR
            B=XSR2
            CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                              KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                              ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
         ELSE
!
!  -- Integration along the z-axis
!
            JXYZ=3
            AJXYZ=JXYZ
            A=ZSR
            B=ZSR2
            CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                              KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                              ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
         END IF
!
               DO J=1,NF
                  IF (L==1) THEN
                     SEH1(J)=SEH1(J)+SEH(J)
                  ELSE
                     SEHA(J)=SEHA(J)+SEH(J)
                  END IF
               END DO
!
            END DO
         END DO
!
! --- Add the subtotals together
!
         DO J=1,NF
            SEH(J)=SEH1(J)+SEHA(J)
         END DO
!
      END IF
!
! --- Arbitrary horizontal loop
!
!     Line integrations used here are similar to bipole cases except that
!     the 1st and last electrodes are connected.
!
!     Note that the charge terms are conceled in the Hankel kernels
!
      IF (CS_TYPE==4 .AND. NCRD/=4) THEN
!
         IF (KEYG==1) THEN
            NF=3
         ELSE
            NF=6
         END IF
!
         DO J=1,NF
            SEH(J)=(0.,0.)
            SEH1(J)=(0.,0.)
         END DO
!
         DO L=1,NCRD
!
            XSR=TX_CRDX(L)
            YSR=TX_CRDY(L)
            ZSR=TX_CRDZ(L)
            IF (L==NCRD) THEN
               XSR2=TX_CRDX(1)
               YSR2=TX_CRDY(1)
               ZSR2=TX_CRDZ(1)
            ELSE
               XSR2=TX_CRDX(L+1)
               YSR2=TX_CRDY(L+1)
               ZSR2=TX_CRDZ(L+1)
            END IF
!
            IF (ABS(YSR2-YSR)>=ABS(XSR2-XSR).AND.ABS(YSR2-YSR)>=ABS(ZSR2-ZSR)) THEN
!
!  -- Integration along the y-axis
!
               JXYZ=2
               AJXYZ=JXYZ
               A=YSR
               B=YSR2
               CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                                 KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                                 ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
           ELSE IF (ABS(XSR2-XSR)>=ABS(YSR2-YSR).AND.ABS(XSR2-XSR)>=ABS(ZSR2-ZSR)) THEN
!
!  -- Integration along the x-axis
!
               JXYZ=1
               AJXYZ=JXYZ
               A=XSR
               B=XSR2
               CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                                 KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                                 ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
!
            ELSE
!
!  -- Integration along the z-axis
!
               JXYZ=3
               AJXYZ=JXYZ
               A=ZSR
               B=ZSR2
               CALL ONE_D_SIMPCS(A,B,EPS,NINT,ONE_D_LINE,SEH,AJXYZ,AJ,CS_TYPE,  &
                                 KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,NZOB, &
                                 ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0)
            END IF
!
            DO J=1,NF
               SEH1(J)=SEH1(J)+SEH(J)
            END DO
!
         END DO
!
! --- Assign SEH1 to SEH.  This is designed so that the above "subroutine"
!     XYBIPOLE remain the same throughout this routine (using SEH only)
!
         DO J=1,NF
            SEH(J)=SEH1(J)
         END DO
!
      END IF
!
! --- Horizontal circular loop
!
      IF (CS_TYPE==5.OR.CS_TYPE==6) THEN
         XSR=TX_CRDX(1)
         YSR=TX_CRDY(1)
         ZSR=TX_CRDZ(1)

!*** pstion (8) in circle!  last two may not be used

         CALL ONE_D_SIMPCS(0.,2.*3.1415926,EPS,NINT,ONE_D_CIRCLE,SEH,RAD,   &
                           AJ,CS_TYPE,KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH, &
                           CDH,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,   &
                           GRHF,GRHO0)
      END IF
!
      IF (CS_TYPE<=6) THEN
!
         EX=SEH(1)
         EY=SEH(2)
         EZ=SEH(3)
         IF (KEYG==2) THEN
            HX=SEH(4)
            HY=SEH(5)
            HZ=SEH(6)
         END IF
!
      END IF
!
!  -- Arbitrary magnetic dipoles
!
!     Note that the first elements of the array crdx, crdy, and
!     crdz are the dipole coordinates
!
!     Zsr1 and zsr2 have been determined earlier
!
      IF (CS_TYPE==7.OR.CS_TYPE==8.OR.CS_TYPE==9) THEN
!
         XSR=TX_CRDX(1)
         YSR=TX_CRDY(1)
         ZSR=TX_CRDZ(1)

!*** pstion (8) in green!  last two may not be used

         CALL ONE_D_GREEN(CS_TYPE,KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,KKH,CDH,  &
                          NZOB,ZOBG,NZSR,ZSRG,RHOMIN,NHFILM,RRG,NRG,GRHF,    &
                          GRHO0,ECOMP,HCOMP)
!
!  --- Note that the coordinate systems for I/O and for computations are
!      different.  It is important to define the dip angle as the angle from
!      the axis pointing down and the azimuthal angle as the angle from the
!      north.
!
!         DIP=ANGLES(1)/180.*3.14159265359
!         AZIM=ANGLES(2)/180.*3.14159265359
         DIP=ANGLES(1)                  !^^^^^^^^^^^^^^^^^^^
         AZIM=ANGLES(2)                 !^^^^^^^^^^^^^^^^^^^
!    --- Multiplied by dipole moment
         PX=SIN(DIP)*COS(AZIM)*AJ
         PY=SIN(DIP)*SIN(AZIM)*AJ
         PZ=COS(DIP)*AJ
!
         EX=PX*EXX+PY*EXY+PZ*EXZ
         EY=PX*EYX+PY*EYY+PZ*EYZ
         EZ=PX*EZX+PY*EZY+PZ*EZZ
         IF (KEYG==2) THEN
            HX=PX*HXX+PY*HXY+PZ*HXZ
            HY=PX*HYX+PY*HYY+PZ*HYZ
            HZ=PX*HZX+PY*HZY+PZ*HZZ
         END IF
!
      END IF
!
      EHFLD(1)=EX
      EHFLD(2)=EY
      EHFLD(3)=EZ
      IF (KEYG==2) THEN
         EHFLD(4)=HX
         EHFLD(5)=HY
         EHFLD(6)=HZ
      END IF
!
      RETURN
!
   END SUBROUTINE ONE_D_SOURCE
!
!
   SUBROUTINE ONE_D_GREEN (CS_TYPE,KEMD,KEYG,PSTION,FRQ,MLAYER,ZBND,      &
                           KKH,CDH,NZOB,ZOBG,NZSR,ZSRG,                   &
                           RHOMIN,NHFILM,RRG,NRG,GRHF,GRHO0,ECOMP,HCOMP)
!
!****   Electromagnetic fields of a dipole source in
!       layered anisotropic earths
!
!
!   Input parameters:
!
!     CS_TYPE:   Integer(*4),  type of excitation and configuration.  See
!             documentation "MARCO.DOC" for description.  It is passed
!             into this routine for proper corrections to the electric
!             fields,  i.e.,  the removal of charge terms in the Green's
!             functions for current loop sources.
!     KEMD:   Integer,  switch for electric or magnetic dipoles.
!             KEMD=1:  electric dipoles;  and
!                 =2:  magnetic dipoles.
!     KEYG:   Integer,  mode of computation controlling whether mangetic
!             fields are computed.
!             KEYG=1:  Computing electric fields only.  This is used
!                      when the exciting electric fields are computed
!                      as the right hand side of the matric equation
!                      for 3D modeling;  and
!                 =2:  All components of the electric and magnetic fields
!                      are computed.
!     PSTION: Real PSTION(8),  the positions of the source and the
!             receiver plus the lower and upper z-coordinates the kernels
!             are integrated analytically.  The first 3 elements of the
!             array is for the x, y, and z-coordinates of the receiver,
!             which are followed by the x, y, and z-coordinates of the
!             source.  The last two elements are the lower and upper
!             z-coordinates of the integral interval.  If the kernels
!             are not integrated,  the last two elements must be identical
!             to the source z-coordinate,  i.e.,  the last three elements
!             of PSTION must be the same if the kernels are not to be
!             integrated in the vertical direction.
!     FRQ:    Real(*4), frequency.
!     MLAYER: Integer, number of layers excluding the air.
!     ZBND:   Real ZBND(0:MLAYER), coordinates of the layer
!             boundaries with the air earth interface being zbnd(0)=0.
!     KKH:    Complex(*8) KKH(0:MLAYER),  square ( **2) of the complex wave
!             number of the layers including the air (layer number 0).
!     CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!             the layers in the lateral direction including the
!             air (layer 0).
!     NZOB:   Integer, number of z-levels. Determined in the main program.
!     ZOBG:   Real ZOBG(NZOB), the nzob z-levels coordinates.
!     NZSR:   Integer,  number of z'-levels.
!     ZSRG:   Real ZSRG(NZSR),  the nzsr z'-levels.
!     RHOMIN: Real,  minimum of the lateral grid (rho) which determines
!             the minimum of rho in the Hankel integrals.  RHOMIN=0.1 for
!             the low frequency mdule and RHOMIN=0.01 for the high
!             frequency module.
!     NHFILM: Integer,  maximal number of grids in the lateral direction
!             (rho) for all the Hankel integrals.
!     NRG:    Integer,  number of grids in the lateral direction (rho).
!     RRG:    Real RRG(NRG),  the NRG grid points in rho.
!     GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!             the Hankel integrals.  To be passed to the interpolation
!             routines.
!     GRHO0:  Complex GRHO0(4,NZSR,NZOB), tabulated values of the
!             Hankel integrals for rho=0 (source and receiver have the
!             same x and y coordinates).
!
!   Output parameters:
!
!     ECOMP:  Complex ECOMP(9),  the nine components of the electric
!             field tensor,  Exx, Eyx, Ezx, Exy, ..., and Ezz.   See the
!             EQUIVALENCE statement.   Note that in parameters Exy etc.
!             the first index "x" denotes the direction of the field and
!             the second index "y" denotes the direction of the source.
!     HCOMP:  Complex HCOMP(9),  the nine components fo the magnetic
!             field tensor which is arranged in the same way as ECOMP.
!
!
!     Note that the Green's functions are not separated into primary and
!     secondary parts as in routine THR_D_GREEN.   Whether the kernels are
!     integrated analytically in the z'-directions or not is controlled
!     in the routine ONE_D_HF_TABLE.  The calling routine ONE_D_LINE must
!     correctly determine this.
!
!     For loop sources, i.e., ksrc=4, 5, or 6, the charge terms in
!     the electric fields need be canceled in the program since
!     they cannot be canceled numerically. This is considered in
!     kernel function, routine kernel, as well as in the routines
!     gridhf and gridcs.   However,  the components Ezz and Exx
!     for rho=0 have different factors before and after the charge
!     terms are removed.  Those factors are numerically more
!     advantagous to be considered here than to be considered in
!     the kernel functions.
!
!     Note that the Hankel integrals for the Green's functions must
!     computed before this routine is called.  The integrals are first
!     tabulated by routine ONE_D_HF_TABLE and then interpolated by routines
!     INTERPO_PLPOL etc.
!
!****  CALLED by:  line, circle, csource
!
!****  CALLS    :
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: KEMD,KEYG,NZOB,NZSR,NHFILM,NRG,CS_TYPE,MLAYER
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER),CDH(0:MLAYER),                  &
                             GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      REAL, INTENT(IN) :: ZBND(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),FRQ,      &
                          RHOMIN,PSTION(8)
      COMPLEX, INTENT(OUT) :: ECOMP(9),HCOMP(9)
!
      REAL :: CRRTN,RHO,RHO1,RR0,RR1
      REAL :: XR,YR,XI,YI,C1,XOB,YOB,ZOB,XSR,YSR,ZSR,ZSR1,ZSR2,RRG(NRG)
      INTEGER :: NF,I,II,NS,NOB,IOB,ISR,ZP_LEVEL
      COMPLEX :: EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,   &
                 HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ,   &
                 S(4),HCRR,HF(11),WMU
!
!  --- Routine INTERPO_PLPOL may used for computing normal fields at
!      high frequencies.  It offers higer accuracy for large rho (> 10 m),
!      but its run time is large.
!
      LOGICAL, PARAMETER :: PLPOL=.FALSE.
!
      RHO(XR,YR,XI,YI)=SQRT((XR-XI)**2+(YR-YI)**2)
!
      C1=1./4./3.1415926
      WMU=CMPLX(0.,78.9568352E-7*FRQ)

!   print *,cdh

!
! --- Extract parameter values for XOB etc. from PSTION
!
      XOB=PSTION(1)
      YOB=PSTION(2)
      ZOB=PSTION(3)
      XSR=PSTION(4)
      YSR=PSTION(5)
      ZSR=PSTION(6)
      ZSR1=PSTION(7)
      ZSR2=PSTION(8)
!
      DO I=MLAYER-1,0,-1
         IF (ZOB>=ZBND(I)) THEN
            NOB=I+1
            GOTO 100
         END IF
      END DO
      NOB=0
!
! ---- Determine the level of zob in the grid array zobg.
!      Note that there is only one z'-level which is
!      therefore ignored.
!
  100 DO I=1,NZOB
         IF (ABS(ZOB-ZOBG(I))<.01) THEN
            IOB=I
            GOTO 200
         END IF
      END DO
!
!      WRITE (23,*) 'Warning: failed to choose a z-level for zob=',ZOB
!      WRITE (*,*) 'Warning: failed to choose a z-level for zob=',ZOB
!
! ---- Determine the level of zsr in the grid array zsrg
!      Note that the z'-levels in the zsr-direction are
!      determined by the full lengths of the electrode span.
!
!      Note that in case of horizontal current bipoles or loops
!      zsr1 and zsr2 take the value of the z-coordinates of
!      any electrode.
!
  200 DO I=1,NZSR
         IF (CS_TYPE==2.AND.  &
             ABS(ZSR1-ZSRG(1,I))<.01.AND.ABS(ZSR2-ZSRG(2,I))<.01) THEN
            ISR=I
            ZP_LEVEL=1
            GOTO 300
         END IF
         IF (CS_TYPE/=2.AND.ABS(ZSR-ZSRG(1,I))<.01) THEN
            ISR=I
            ZP_LEVEL=1
            GOTO 300
         END IF
      END DO
!
      ZP_LEVEL=0  ! Z' level not found.  Interpolation in Z' will be used

!    WRITE (23,*) 'Warning: failed to choose a z_prime-level',   &
!               ' for electrodes (z) =',ZSR1,ZSR2
!
!
  300 IF (KEYG==1) THEN
         NF=6
      ELSE
         NF=11
      END IF
!
!  --- Note that both electric and magnetic dipoles have 6 non-zero
!      kernels for the electric fields,  #1 through 6,  and 5 non-zero
!      kernels for magnetic fields,  # 7 through 11.
!      For rho=0,  electric dipoles have 2 non-zero electric kernels
!      and one magnetic kernel, and magnetic dipoles have only one
!      non-zero kernel for the electric fields.
!
!      The kernels for the magnetic dipoles are arranged in such an
!      order that is compatible with the kernels for the electric
!      fields in using all teh subroutines,  especially routine
!      HFIL.
!
      IF (KEYG==2) NS=3
      IF (KEYG==1) THEN
         IF (KEMD==1) THEN
            NS=2
         ELSE
            NS=1
         END IF
      END IF
!
      RHO1=RHO(XOB,YOB,XSR,YSR)
!
      IF (RHO1>=RHOMIN) THEN
!
!  --- Interpolate the hankel integrals
!
!  --- Routine INTERPO_PLPOL may used for computing normal fields at
!      high frequencies.  It offers higer accuracy for large rho (> 10 m),
!      but its run time is large.
!
         IF (ZP_LEVEL==1) THEN
!   -- Interpolation in rho only
            IF (PLPOL) THEN
               CALL INTERPO_PLPOL(GRHF,RRG,NRG,NHFILM,NZSR,NZOB,ALOG(RHO1),   &
                                  IOB,ISR,HF,NF)
            ELSE
               CALL INTERPO_LG6(GRHF,RRG,NRG,NHFILM,NZSR,NZOB,ALOG(RHO1),     &
                             IOB,ISR,HF,NF)
            END IF
         ELSE
!   -- 2D interpolation in rho and z'
            CALL INTERPO_2D_LG6(GRHF,RRG,NRG,NHFILM,NZSR,NZOB,ALOG(RHO1),     &
                                IOB,ZSR,ZSRG,HF,NF)
         END IF
!
!  --- HF are now divided by rho
!
         DO II=1,NF
            HF(II)=HF(II)/RHO1
         END DO
!
      END IF
!
! ---- Electric dipoles
!
      IF (KEMD==1) THEN
!   *****************************************
!   *                                       *
         IF (RHO1>=RHOMIN) THEN
!   --------------------------------------
!   |                                    |
!
!  --- The kernel related to HF(2) tends to 2*LAMBDA**2 as
!      LAMBDA goes to infinity for z=z'=0.  The corresponding
!      kernel has been corrected in the function ONE_D_KERNEL.
!      This affect Exx, Eyx, Eyy and Exy only.  Other components
!      and most components of the electric field in the air
!      have similar behaviors but are not corrected since they
!      are not measured.   The hankel filters used in this program
!      do yield accurate results for all cases even without
!      correction.   The corrections done here can hopefully
!      boost the accuracy of the code.  It is also possible to
!      use better filters which decay slower but have much higher
!      accuracy.
!
!      Note that the charge terms which also involves HF(2)
!      are set to zero in ONE_D_KERNEL for loop type sources in order
!      to councel the charge terms accurately
!
            IF (ABS(ZOB)<.001.AND.ABS(ZSR)<.001) THEN
               IF (CS_TYPE==4.OR.CS_TYPE==5.OR.CS_TYPE==6) THEN
                  CRRTN=0.
               ELSE
                  CRRTN=2./RHO1**3
               END IF
               EXX=-C1*WMU*HF(1)-C1/CDH(NOB)                           &
                   *(((XOB-XSR)/RHO1)**2*(HF(2)-CMPLX(CRRTN,0.))                 &
                   +(1.-2.*((XOB-XSR)/RHO1)**2)/RHO1*HF(4))
               EYX=-C1/CDH(NOB)*(XOB-XSR)*(YOB-YSR)                    &
                   /RHO1**2*(HF(2)-CMPLX(CRRTN,0.)-2.*HF(4)/RHO1)
               EYY=-C1*WMU*HF(1)-C1/CDH(NOB)                           &
                   *(((YOB-YSR)/RHO1)**2*(HF(2)-CMPLX(CRRTN,0.))                 &
                   +(1.-2.*((YOB-YSR)/RHO1)**2)/RHO1*HF(4))
            ELSE
               EXX=-C1*WMU*HF(1)-C1/CDH(NOB)*(((XOB-XSR)/RHO1)**2*HF(2)+  &
                   (1.-2.*((XOB-XSR)/RHO1)**2)/RHO1*HF(4))
               EYX=-C1/CDH(NOB)*(XOB-XSR)*(YOB-YSR)/RHO1**2*              &
                   (HF(2)-2.*HF(4)/RHO1)
               EYY=-C1*WMU*HF(1)-C1/CDH(NOB)*(((YOB-YSR)/RHO1)**2*HF(2)+  &
                   (1.-2.*((YOB-YSR)/RHO1)**2)/RHO1*HF(4))
            END IF
            EXY=EYX
            EZX=-C1/CDH(NOB)*(XOB-XSR)/RHO1*HF(5)
            EZY=-C1/CDH(NOB)*(YOB-YSR)/RHO1*HF(5)
            EXZ=-C1/CDH(NOB)*(XOB-XSR)/RHO1*HF(6)
            EYZ=-C1/CDH(NOB)*(YOB-YSR)/RHO1*HF(6)
!  --- Ezz has different factors before the integral before and
!      after the charge term is removed.  This has been taken into
!      account in routine ONE_D_KERNEL
            EZZ=C1/CDH(NOB)*HF(3)
!
!  --- Compute magnetic fields as well if keyg=2
!
            IF (KEYG==2) THEN
!
               HXX=-C1*(XOB-XSR)*(YOB-YSR)/RHO1**2*(HF(7)-2./RHO1*HF(9))
               HYX= C1*HF(8)+C1*((XOB-XSR)/RHO1)**2*HF(7)                &
                   +C1*(1.-2.*((XOB-XSR)/RHO1)**2)/RHO1*HF(9)
               HXY=-C1*HF(8)-C1*((YOB-YSR)/RHO1)**2*HF(7)                &
                   -C1*(1.-2.*((YOB-YSR)/RHO1)**2)/RHO1*HF(9)
               HYY=-HXX
!
!  --- Corrections for hxz and hyz for sources and receivers in the air.
!      This is necessary for high frequencies (>100 kHz).
!
!      These corrections need be done for all components.  Here only
!      hxz and hyz are done for the time being.
!
!      Corrections are also made for hxz and hyz for sources and
!      receivers on the earth's surface.
!
               IF (ZOB<.0.AND.ZSR<.0.AND.                      &
                 (ABS(ZOB)>=.001.OR.ABS(ZSR)>=.001)) THEN
                  RR0=SQRT(RHO1**2+(ZSR-ZOB)**2)
                  RR1=SQRT(RHO1**2+(ZSR+ZOB)**2)
                  HCRR=RHO1/RR0**3* EXP(-CSQRT(KKH(0))*RR0)    &
                       *((1.,0.)+CSQRT(KKH(0))*RR0)                 &
                       -RHO1/RR1**3* EXP(-CSQRT(KKH(0))*RR1)   &
                       *((1.,0.)+CSQRT(KKH(0))*RR1)
               ELSEIF (ABS(ZOB)<.001.AND.ABS(ZSR)<.001) THEN
                  HCRR=CMPLX(1./RHO1**2,0.)
               ELSE
                  HCRR=(0.,0.)
               END IF
!
               HZX=C1*(YOB-YSR)/RHO1*(HF(10)+HCRR)
               HZY=-C1*(XOB-XSR)/RHO1*(HF(10)+HCRR)
!
               HXZ=-C1*(YOB-YSR)/RHO1*HF(11)
               HYZ=C1*(XOB-XSR)/RHO1*HF(11)
               HZZ=(0.,0.)
!
            END IF
!
!   |                                    |
!   --------------------------------------
         END IF
!
         IF (RHO1<RHOMIN) THEN
!   --------------------------------------
!   |                                    |
!
            IF (ZP_LEVEL==1) THEN
               DO II=1,NS
                  S(II)=GRHO0(II,ISR,IOB)
               END DO
            ELSE
!     --   Interpolate in z' for missing ISR
               CALL INTERPO_LG6_RHO0 (GRHO0,NZSR,NZOB,IOB,ZSR,ZSRG,S,NS)
            END IF
!
            S(1)=-C1/CDH(NOB)*S(1)
            EXX=S(1)
            EYY=S(1)
            EZZ=C1/CDH(NOB)*S(2)
            EYX=(0.,0.)
            EZX=(0.,0.)
            EXY=(0.,0.)
            EZY=(0.,0.)
            EXZ=(0.,0.)
            EYZ=(0.,0.)
!
            IF (KEYG==2) THEN
               HYX=C1*S(3)
               HXY=-C1*S(3)
               HXX=(0.,0.)
               HZX=(0.,0.)
               HYY=(0.,0.)
               HZY=(0.,0.)
               HXZ=(0.,0.)
               HYZ=(0.,0.)
               HZZ=(0.,0.)
            END IF
!
!   |                                    |
!   --------------------------------------
         END IF
!
!   *                                       *
!   *****************************************
      END IF
!
      IF (KEMD==2) THEN
!   *****************************************
!   *                                       *
!
!     Corrections necessary for almost all components!
!     Here only Hzz is corrected for the time being.
!
         IF (RHO1>=RHOMIN) THEN
!   --------------------------------------
!   |                                    |
!
            EXX=C1/CDH(NOB)*(XOB-XSR)*(YOB-YSR)/RHO1**2*(HF(1)-2./RHO1*HF(4))
            EYX=C1*WMU*HF(2)+C1/CDH(NOB)*((YOB-YSR)/RHO1)**2*HF(1)+          &
                C1/CDH(NOB)*((XOB-XSR)**2-(YOB-YSR)**2)/RHO1/RHO1/RHO1*HF(4)
            EZX=C1/CDH(NOB)*(YOB-YSR)/RHO1*HF(5)
            EXY=-C1*WMU*HF(2)-C1/CDH(NOB)*((XOB-XSR)/RHO1)**2*HF(1)-         &
                C1/CDH(NOB)*((YOB-YSR)**2-(XOB-XSR)**2)/RHO1/RHO1/RHO1*HF(4)
            EYY=-EXX
            EZY=-C1/CDH(NOB)*(XOB-XSR)/RHO1*HF(5)
!
            EXZ=C1*WMU*(YOB-YSR)/RHO1*HF(6)
            EYZ=-C1*WMU*(XOB-XSR)/RHO1*HF(6)
            EZZ=(0.,0.)
!
            IF (KEYG==2) THEN
               HXX=C1*(HF(3)                                               &
                 +((YOB-YSR)**2*HF(7)+((XOB-XSR)**2-(YOB-YSR)**2)          &
                 /RHO1*HF(9))/RHO1**2)
               HYX=C1*(XOB-XSR)*(YOB-YSR)/RHO1**2*(-HF(7)+2.*HF(9)/RHO1)
               HZX=C1*(XOB-XSR)/RHO1*HF(10)
               HXY=HYX
               HYY=C1*(HF(3)                                               &
                  +((XOB-XSR)**2*HF(7)+((YOB-YSR)**2-(XOB-XSR)**2)         &
                 /RHO1*HF(9))/RHO1**2)
               HZY=C1*(YOB-YSR)/RHO1*HF(10)
               HXZ=-C1*(XOB-XSR)/RHO1*HF(11)
               HYZ=-C1*(YOB-YSR)/RHO1*HF(11)
               IF (ABS(ZOB-ZSR)<1.E-4) THEN
                  HCRR=-CMPLX(1./RHO1**3,0.)
               ELSE
                  HCRR=(0.,0.)
               END IF
               HZZ=C1*(HF(8)+HCRR)
            END IF
!
!   |                                    |
!   --------------------------------------
         END IF
!
         IF (RHO1<RHOMIN) THEN
!   --------------------------------------
!   |                                    |

            IF (ZP_LEVEL==1) THEN
               DO II=1,NS
                  S(II)=GRHO0(II,ISR,IOB)
               END DO
            ELSE
!     --   Interpolate in z' for missing ISR
               CALL INTERPO_LG6_RHO0 (GRHO0,NZSR,NZOB,IOB,ZSR,ZSRG,S,NS)
            END IF
!
            EYX=C1/CDH(NOB)*S(1)
            EXY=-EYX
            EXX=(0.,0.)
            EZX=(0.,0.)
            EYY=(0.,0.)
            EZY=(0.,0.)
            EXZ=(0.,0.)
            EYZ=(0.,0.)
            EZZ=(0.,0.)
!
            IF (KEYG==2) THEN
               HXX=C1*S(2)
               HYY=HXX
               HZZ=C1*S(3)
               HYX=(0.,0.)
               HZX=(0.,0.)
               HXY=(0.,0.)
               HZY=(0.,0.)
               HXZ=(0.,0.)
               HYZ=(0.,0.)
            END IF
!
!   |                                    |
!   --------------------------------------
         END IF
!
!   *                                       *
!   *****************************************
      END IF
!
! --- Assign the components to the arrays ECOMP and HCOMP
!     for data passing
!
      ECOMP(1)=EXX
      ECOMP(2)=EYX
      ECOMP(3)=EZX
      ECOMP(4)=EXY
      ECOMP(5)=EYY
      ECOMP(6)=EZY
      ECOMP(7)=EXZ
      ECOMP(8)=EYZ
      ECOMP(9)=EZZ
      IF (KEYG==2) THEN
         HCOMP(1)=HXX
         HCOMP(2)=HYX
         HCOMP(3)=HZX
         HCOMP(4)=HXY
         HCOMP(5)=HYY
         HCOMP(6)=HZY
         HCOMP(7)=HXZ
         HCOMP(8)=HYZ
         HCOMP(9)=HZZ
      END IF
!
      RETURN
!
   END SUBROUTINE ONE_D_GREEN
!
!
      SUBROUTINE INTERPO_2D_LG6(GRHF,A,L,NHFILM,NZSR,NZOB,X,IOB,ZSR,ZSRG,F,NF)
!
!****    INTERPOLATION OF THE HANKEL INTEGRALS
!
!    Six-point Lagrangian interpolations in the Rho and z'-direction.
!
!    Note the abscissas are equally spaced
!
! Input parameters:
!
!   GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!           the Hankel integrals.
!   L:      Integer,  number of grid points.
!   A:      Real A(L),  array for grid points.
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   X:      Real,  interpolation point.
!   IOB:    Integer,  number for receiver z-level.  It is used to
!           specify the third array element of GRHF.
!   ZSR:    Real, z' postion
!   ZSRG:   Real ZSRG(2,NZSR), array for all the z'-levels. Note that only
!           the first element of the first dimension (2) is used.
!   NF:     Integer,  number of functions to be interpolated.
!
! Output parameter:
!
!   F:      Complex F(NF),  interpolated NF function values.
!
!
!    This routine is similar to the routine intpl4 a
!    six-point rule is used.
!
!
!**** Called by:  ONE_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER I,I1,ICN2,II,IOB,L,NF,NHFILM,NN,NZSR,NZOB
      INTEGER J,J1,JCN2,JJ
      REAL P,P1,P2,P3,PP1,PP4,X
      REAL Q,Q1,Q2,Q3,QQ1,QQ4,ZSR
      REAL A(L),U(6),V(6),ZSRG(2,NZSR)
      COMPLEX GRHF(11,NHFILM,NZSR,NZOB),F(NF)
!
! --- Sorting in rho (x)
!
      IF (X<=A(1)) THEN
         I=1
      ELSE IF (X>=A(L)) THEN
         I=L
      ELSE
         DO I=1,L-1
            IF (X>=A(I).AND.X<=A(I+1)) THEN
               EXIT
            END IF
         END DO
      END IF
!
      IF (I<=3) THEN
         ICN2=1
      ELSE IF (I>=L-3) THEN
         ICN2=L-5
      ELSE
         ICN2=I-2
      END IF
!
! --- Sorting in z'
!
      IF (ZSR<=ZSRG(1,1)) THEN
         J=1
      ELSE IF (ZSR>=ZSRG(1,NZSR)) THEN
         J=NZSR
      ELSE
         DO J=1,NZSR-1
            IF (ZSR>=ZSRG(1,J).AND.ZSR<=ZSRG(1,J+1)) THEN
               EXIT
            END IF
         END DO
      END IF
!
      IF (J<=3) THEN
         JCN2=1
      ELSE IF (J>=NZSR-3) THEN
         JCN2=NZSR-5
      ELSE
         JCN2=J-2
      END IF
!
! --- Compute interpolant coefficients for rho (x)
!
      P=(X-A(ICN2+2))/(A(2)-A(1))
!
      PP1=(P-1.)*(P+1.)
      PP4=(P-2.)*(P+2.)
      P1=PP1*P/120.
      P2=P*(P-3.)/24.
      P3=(P-3.)*PP4/12.
      U(1)=-P1*(P-2.)*(P-3.)
      U(2)=P2*(P-1.)*PP4
      U(3)=-P3*PP1
      U(4)=P3*P*(P+1.)
      U(5)=-P2*PP1*(P+2.)
      U(6)=P1*PP4
!
! --- Compute interpolant coefficients for z'
!
      Q=(ZSR-ZSRG(1,JCN2+2))/(ZSRG(1,2)-ZSRG(1,1))
!
      QQ1=(Q-1.)*(Q+1.)
      QQ4=(Q-2.)*(Q+2.)
      Q1=QQ1*Q/120.
      Q2=Q*(Q-3.)/24.
      Q3=(Q-3.)*QQ4/12.
      V(1)=-Q1*(Q-2.)*(Q-3.)
      V(2)=Q2*(Q-1.)*QQ4
      V(3)=-Q3*QQ1
      V(4)=Q3*Q*(Q+1.)
      V(5)=-Q2*QQ1*(Q+2.)
      V(6)=Q1*QQ4
!
      DO NN=1,NF
         F(NN)=(.0,.0)
      END DO
!
      DO JJ=1,6
         J1=JCN2+JJ-1
         DO II=1,6
            I1=ICN2+II-1
            DO NN=1,NF
               F(NN)=F(NN)+U(II)*V(JJ)*GRHF(NN,I1,J1,IOB)
            END DO
         END DO
      END DO
!
      RETURN
      END
!
!**** End of INTERPO_2D_LG6
!
!
      SUBROUTINE INTERPO_LG6_RHO0 (GRHO0,NZSR,NZOB,IOB,ZSR,ZSRG,F,NF)
!
!****  INTERPOLATION OF THE HANKEL INTEGRALS for rho=0
!
!    Six-point Lagrangian interpolations in z'-direction.
!
!    This routine is similar to routine INTERPO_LG6
!
!    Note the abscissas are equally spaced
!
! Input parameters:
!
!   GRHO0:   Complex GRHF(4,NZSR,NZOB), tabulated values of
!           the Hankel integrals.
!   X:      Real,  interpolation point.
!   IOB:    Integer,  number for receiver z-level.  It is used to
!           specify the third array element of GRHF.
!   ZSR:    Real, z' postion
!   ZSRG:   Real ZSRG(2,NZSR), array for all the z'-levels. Note that only
!           the first element of the first dimension (2) is used.
!   NF:     Integer,  number of functions to be interpolated.
!
! Output parameter:
!
!   F:      Complex F(NF),  interpolated NF function values.
!
!
!    This routine is similar to the routine intpl4 a
!    six-point rule is used.
!
!
!**** Called by:  ONE_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER IOB,NF,NN,NZSR,NZOB
      INTEGER J,J1,JCN2,JJ
      REAL Q,Q1,Q2,Q3,QQ1,QQ4,ZSR
      REAL V(6),ZSRG(2,NZSR)
      COMPLEX GRHO0(4,NZSR,NZOB),F(NF)
!
! --- Sorting in z'
!
      IF (ZSR<=ZSRG(1,1)) THEN
         J=1
      ELSE IF (ZSR>=ZSRG(1,NZSR)) THEN
         J=NZSR
      ELSE
         DO J=1,NZSR-1
            IF (ZSR>=ZSRG(1,J).AND.ZSR<=ZSRG(1,J+1)) THEN
               EXIT
            END IF
         END DO
      END IF
!
      IF (J<=3) THEN
         JCN2=1
      ELSE IF (J>=NZSR-3) THEN
         JCN2=NZSR-5
      ELSE
         JCN2=J-2
      END IF
!
! --- Compute interpolant coefficients for z'
!
      Q=(ZSR-ZSRG(1,JCN2+2))/(ZSRG(1,2)-ZSRG(1,1))
!
      QQ1=(Q-1.)*(Q+1.)
      QQ4=(Q-2.)*(Q+2.)
      Q1=QQ1*Q/120.
      Q2=Q*(Q-3.)/24.
      Q3=(Q-3.)*QQ4/12.
      V(1)=-Q1*(Q-2.)*(Q-3.)
      V(2)=Q2*(Q-1.)*QQ4
      V(3)=-Q3*QQ1
      V(4)=Q3*Q*(Q+1.)
      V(5)=-Q2*QQ1*(Q+2.)
      V(6)=Q1*QQ4
!
      DO NN=1,NF
         F(NN)=(.0,.0)
      END DO
!
      DO JJ=1,6
         J1=JCN2+JJ-1
         DO NN=1,NF
            F(NN)=F(NN)+V(JJ)*GRHO0(NN,J1,IOB)
         END DO
      END DO
!
      RETURN
      END
!
!**** End of INTERPO_LG6_RHO0
!
!
   SUBROUTINE ONE_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,  &
                             BLMIN,CS_TYPE,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,    &
                             ZOBG,NZSR,ZSRG,NZBG,ZBG,ALMAX,GRHF,RRG,NRG,GRHO0)
!
!****  Compute tabulated Hankel integrals of the Green's functions
!      on a three-demensional grids in the rho (the lateral) direction,
!      z, and z'-directions (or the z and z'-levels).  Note that
!      Hankel integrals for many kernels associated withe the components
!      of the tensor Green's functions are computed simultaneously,
!      thus the array GRHF is four-dimensional.  Those tabulated values
!      are interpolated to compute actual Green's functions or field
!      components.
!
!      This routine is similar to THR_D_HF_TABLE but is used for
!      computing electromagnetic fields of controlled
!      sources only,  ie., the 1D responses of electric or
!      magnetic sources.
!
!
!   Input parameters:
!
!     HIGH_FRQ: Integer, switch for high frequency or low frequency module.
!               =0, use low frequency filters
!               =1, use high frequency filters
!     NHFILM: Integer,  maximal number of grids in the lateral direction
!             (rho) for all the Hankel integrals.
!     MLAYER: Integer, number of layers excluding the air.
!     ZBND:   Real ZBND(0:MLAYER), coordinates of the layer
!             boundaries with the air earth interface being zbnd(0)=0.
!     LRYTH:  Real LRYTH(MLAYER),  thickness of each layer (the air is not
!             included in LRYTH).
!     HVK:    Real HVK(0:MLAYER),  coefficients of anisotropy of the layers
!             including the air (layer 0 with HVK(0)=1).  The anisotropy
!             coefficients are defined as the square roots of the ratios of
!             horizontal conductivities to vertical conductivities of each
!             layer.  Elements of HVK are always equal to or larger than 1.
!     KKH:    Complex(*8) KKH(0:MLAYER),  square ( **2) of the complex wave
!             number of the layers including the air (layer number 0).
!     KANIS:  Integer, flag for the anisotropy of the media.
!             KANIS=1:  the media are anisotropic in the verical
!                       direction;  and
!             KANIS=0:  the media are isotropic.
!             If the media are isotropic,  use KANIS=0 to simplify
!             the computation.
!     CS_TYPE:   Integer,  type of excitation and configuration.  See
!             documentation "MARCO.DOC" for description.  It is passed
!             into this routine for proper corrections to the electric
!             fields,  i.e.,  the removal of charge terms in the Green's
!             functions for current loop sources.  It is also used to
!             determine whether the kernels for electric or magnetic
!             sources are to be computed.
!     BLMIN:  Real,  small interval to be cut from a vertical current bipole
!             that passes the center of a cell.  It is used to avoid
!             singularity.  Note that it has a different function from the
!             BLMIN in routine THR_D_HF_TABLE.
!     KEYG:   Integer.  Mode of computation controlling whether mangetic
!             fields are to be computed.
!             KEYG=1:  Computing electric fields only.  This is used
!                      when elements of the scattering impedance
!                      matrix are computed;  and
!                 =2:  All components of the electric and magnetic fields
!                      are computed as in the computation of secondary
!                      E- and H-fields.
!     DMIN:   Real,  minmum of dimension for numerical treatments of cells.
!             DMIN=0.1 for the low frequency mdule and DMIN=0.001 for the
!             high frequency module.
!     RHOMIN: Real,  minimal dimension in the lateral direction (rho).
!     RHOMAX: Real,  maxiaml dimension in the lateral direction (rho).
!     NZOB:   Integer, number of z-levels. Determined in the main program.
!     ZOBG:   Real ZOBG(NZOB), the nzob z-levels coordinates.
!     NZSR:   Integer,  number of z'-levels.
!     ZSRG:   Real ZSRG(2,NZSR),  the nzsr z'-levels.
!     ZBG:    Real ZBG(2,NZSR),  working array for the nzsr z'-levels.
!
!   Output parameters:
!
!     NRG:    Integer,  number of grids in the lateral direction (rho).
!     RRG:    Real RRG(NRG),  the NRG grid points in rho.
!     GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!             the Hankel integrals.  To be passed to the interpolation
!             routines.
!     GRHO0:  Complex GRHO0(4,NZSR,NZOB), tabulated values of the
!             Hankel integrals for rho=0 (source and receiver have the
!             same x and y coordinates).
!
!     Parameter ALMAX is to be passed into routine ONE_D_KERNEL.  See
!     ONE_D_KERNEL for its description.
!
!
!   Remarks:
!
!        The grid points in the rho (or R) direction are set
!        up automatically by the Hankel transform subroutine
!        on a logrithmical scale.   Note that the interpolated
!        values in the rho-direction must be divided by rho
!        to obtain the value of the Hankel transform.
!
!        The grid values of the Hankel transform in the z and z'
!        directions are stored at exactly those z and z'-levels
!        (ZOBG and ZSRG) which are determined by discretization.
!        Hence no interpolations in the z and z'-direction are
!        necessary.
!
!        The Hankel transforms for vertical current bipoles are
!        integrated analytically in the z'-directrion.  Results
!        are stored in the preassigned z'-levels (zsrgrd) with
!        both upper and lower limits for integration. This analytical
!        integration increases the accuracy and efficiency of the
!        algorithm substantially.  But this design restricts that
!        the vertical bipole sources must not be inclined.  Otherwise,
!        some routines must be rewritten.
!
!        The results will be integrated analytically in the routine
!        kernel for vertical bipole sources. This analytical
!        integration increases the accuracy and efficiency
!        substantially. Yet this design restricts that the
!        vertical bipole source must not be inclined. Otherwise,
!        some routines must be rewritten.
!
!        It is assumed that there is only one z'-level for
!        the source current. This is clear for horizontal bipoles
!        or loops. For vertical current bipoles there must be
!        fixed end points.
!
!
!**** Called by:  MAIN_PRM_AT_RCV
!
!**** Calls:      ONE_D_0_2_INFTY,  HFIL
!
!
      IMPLICIT NONE
!
      REAL, INTENT(IN) :: ALMAX,BLMIN,DMIN,RHOMAX,RHOMIN
      INTEGER, INTENT(IN) :: KANIS,KEYG,CS_TYPE,MLAYER,NHFILM,NZOB,NZSR,NZBG,HIGH_FRQ
      INTEGER, INTENT(INOUT) :: NRG
      REAL, INTENT(IN) :: ZOBG(NZOB),ZSRG(2,NZSR),                           &
                          LRYTH(MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER)
      REAL, INTENT(INOUT) :: ZBG(2,NZBG),RRG(NHFILM)
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER)
      COMPLEX, INTENT(INOUT) :: GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB)
      INTEGER :: KITG,KPRM,KCHRG,KEMD,NF,NS,NOB,NSR,NSR1,NSR2,               &
                 I,II,INTER,J,J3,JJ
      COMPLEX :: S(4),S1(4)
!
!  -- HF and HF1 are allocatable working arrays for the kernels of the
!     Hankel transforms.
!
      COMPLEX, ALLOCATABLE :: HF(:,:),HF1(:,:)
!
      ALLOCATE(HF(11,NHFILM),HF1(11,NHFILM))
      HF=(0.,0.);  HF1=(0.,0.)
!
! --- CS_TYPE=7, 8, or 9 are for magnetic dipole sources
!
      IF (CS_TYPE==7.OR.CS_TYPE==8.OR.CS_TYPE==9) THEN
         KEMD=2
      ELSE
         KEMD=1
      END IF
!
! --- The parameter KCHRG controls the charge terms in the
!     kernels of Hankel transform.  For loop sources, i.e.,
!     ksrc=0 and 4, the charge terms in the electric fields
!     need be canceled in the program since they cannot be
!     canceled numerically.
!
      IF (CS_TYPE==4.OR.CS_TYPE==5.OR.CS_TYPE==6) THEN
         KCHRG=1
      ELSE
         KCHRG=0
      END IF
!
      IF (CS_TYPE==2) THEN
         KITG=1
      ELSE
         KITG=0
      END IF
!
! --- The primary and secondary parts of the Green's functions
!     are computed together.
!
      KPRM=1
!
      IF (KEYG==1) THEN
         NF=6

      ELSE
         NF=11
      END IF
!
      IF (KEYG==2) NS=3
      IF (KEYG==1) THEN
         IF (KEMD==1) THEN
            NS=2
         ELSE
            NS=1
         END IF
      END IF
!
      Receiver_z_level_loop:  DO I=1,NZOB
!
         DO II=MLAYER-1,0,-1
            IF (ZOBG(I)>=ZBND(II)) THEN
               NOB=II+1
               GOTO 50
            END IF
         END DO
         NOB=0
!
      50    CONTINUE
         Source_z_level_loop:  DO J=1,NZSR
!
            DO II=1,NF
               DO J3=1,NHFILM
                  GRHF(II,J3,J,I)=(0.,0.)
               END DO
            END DO
            DO J3=1,NS
               GRHO0(J3,J,I)=(0.,0.)
            END DO
!
            IF (CS_TYPE==2) THEN
               DO II=MLAYER-1,0,-1
                  IF (ZSRG(1,J)>=ZBND(II)) THEN
                     NSR1=II+1
                     GOTO 60
                  END IF
               END DO
               NSR1=0
   60          DO II=MLAYER-1,0,-1
                  IF (ZSRG(2,J)>=ZBND(II)) THEN
                     NSR2=II+1
                     GOTO 80
                  END IF
               END DO
               NSR2=0
            END IF
!
   80       IF (CS_TYPE/=2.OR.NSR1==NSR2) THEN
               INTER=1
               ZBG(1,1)=ZSRG(1,J)
               ZBG(2,1)=ZSRG(2,J)
            ELSE
!
! --- Break the interval [zsrg(1,j), zsrg(2,j)] into subintervals
!     determined by the layer boundaries the two vertical electrodes
!     straddle over.
!
               ZBG(1,1)=ZSRG(1,J)
               INTER=1
!                                                  DO II = 0, MLAYER    !^^^^^^^^^^^
               DO II = 0, MLAYER-1   !^^^^^^^^^^^ APR correction 28 June, 2001
! --- Note that zsrg(2,*) must be > or = zsrg(1,*)
                  IF (ZBND(II)>=ZSRG(1,J).AND.ZBND(II)<=ZSRG(2,J).AND.   &
                      ABS(ZBND(II)-ZBG(1,1))>DMIN) THEN
                     ZBG(2,INTER)=ZBND(II)
                     INTER=INTER+1
                     ZBG(1,INTER)=ZBG(2,INTER-1)
                  END IF
               END DO
               ZBG(2,INTER)=ZSRG(2,J)
!
            END IF
!
            DO JJ=1,INTER
!
               DO II=MLAYER-1,0,-1
                  IF ((ZBG(1,JJ)+ZBG(2,JJ))/2.>=ZBND(II)) THEN
                     NSR=II+1
                     GOTO 90
                  END IF
               END DO
               NSR=0
!
! ---- If zobg(i) lies in the integral interval [zbg(1,*),zbg(2,*)]
!      the intergral will be cut into two parts for vertical
!      currents.
!
!      Note that zbg(2,*) > zbg(1,*)
!
! ----- Note the grid points in the Rho-direction are generated
!       by the program HFIL
!
   90          IF (CS_TYPE/=2.OR.ZOBG(I)>ZBG(2,JJ).OR.ZOBG(I)<ZBG(1,JJ)) THEN
                  IF (HIGH_FRQ==0)  &
                  CALL HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,  &
                             KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,                &
                             ZOBG(I),ZBG(2,JJ),ZBG(1,JJ),NRG,RRG,HF,NHFILM)
                  IF (HIGH_FRQ==1)  &
                  CALL HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,  &
                             KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,                &
                             ZOBG(I),ZBG(2,JJ),ZBG(1,JJ),NRG,RRG,HF,NHFILM)
               ELSE
                  IF (HIGH_FRQ==0)  &
                  CALL HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,  &
                             KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,                &
                             ZOBG(I),ZBG(2,JJ),ZOBG(I),NRG,RRG,HF,NHFILM)
                  IF (HIGH_FRQ==1)  &
                  CALL HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,  &
                             KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,                &
                             ZOBG(I),ZBG(2,JJ),ZOBG(I),NRG,RRG,HF,NHFILM)
                  IF (HIGH_FRQ==0)  &
                  CALL HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,  &
                             KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,                &
                             ZOBG(I),ZOBG(I),ZBG(1,JJ),NRG,RRG,HF1,NHFILM)
                  IF (HIGH_FRQ==1)  &
                  CALL HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,  &
                             KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,                &
                             ZOBG(I),ZOBG(I),ZBG(1,JJ),NRG,RRG,HF1,NHFILM)
               END IF
!
               IF(CS_TYPE==2.AND.ZOBG(I)>=ZBG(1,JJ).AND.ZOBG(I)<=ZBG(2,JJ))THEN
!  ---- This may also happen for keyg=2 for cells just below
!       the earth's surface
                  DO II=1,NF
                     DO J3=1,NRG
                        GRHF(II,J3,J,I)=GRHF(II,J3,J,I)+HF(II,J3)+HF1(II,J3)
                     END DO
                  END DO
               ELSE
!
                  DO II=1,NF
                     DO J3=1,NRG
                        GRHF(II,J3,J,I)=GRHF(II,J3,J,I)+HF(II,J3)
                     END DO
                  END DO
!
               END IF
!
! --  In order to avoid the case where the transmitter and
!     the receiver coincide with each other which may happen
!     due to discretizations for a body under vertical bipole
!     source excitation, namely, the center of a cell lies
!     on the source line,  the electrodes are positioned
!     slightly above or below the receiver (cell center)
!     in such cases.
!
               IF (ABS(ZOBG(I)-ZBG(2,JJ))>=DMIN.OR.            &
                   ABS(ZOBG(I)-ZBG(1,JJ))>=DMIN)     THEN
!
                  IF (CS_TYPE/=2.OR.ZOBG(I)>ZBG(2,JJ).OR.ZOBG(I)<ZBG(1,JJ)) THEN
                     CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH, &
                                      KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),   &
                                      ZBG(2,JJ),ZBG(1,JJ),ALMAX,NS,S)
                  ELSEIF (ABS(ZOBG(I)-ZBG(1,JJ))<DMIN) THEN
                     CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH, &
                                      KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),   &
                                      ZBG(2,JJ),ZOBG(I)+2.*BLMIN,ALMAX,NS,S)
                     S1=(0.,0.)
                  ELSEIF (ABS(ZOBG(I)-ZBG(2,JJ))<DMIN) THEN
                     CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH, &
                                      KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),   &
                                      ZOBG(I)-2.*BLMIN,ZBG(1,JJ),ALMAX,NS,S1)
                     S=(0.,0.)
                  ELSE
                     CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH, &
                                      KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),   &
                                      ZBG(2,JJ),ZOBG(I)+2.*BLMIN,ALMAX,NS,S)
                     CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH, &
                                      KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),   &
                                      ZOBG(I)-2.*BLMIN,ZBG(1,JJ),ALMAX,NS,S1)
                  END IF
!
                  DO J3=1,NS
                     IF (CS_TYPE/=2.OR.ZOBG(I)>ZBG(2,JJ).OR.        &
                         ZOBG(I)<ZBG(1,JJ))               THEN
                        GRHO0(J3,J,I)=GRHO0(J3,J,I)+S(J3)
                     ELSE
                        GRHO0(J3,J,I)=GRHO0(J3,J,I)+S(J3)+S1(J3)
                     END IF
!
                  END DO
               END IF
!
            END DO
!
         END DO Source_z_level_loop
!
      END DO Receiver_z_level_loop
!
      DO J3=1,NRG
         RRG(J3)=ALOG(RRG(J3))
      END DO
!
      DEALLOCATE(HF,HF1)
!
      RETURN
!
   END SUBROUTINE ONE_D_HF_TABLE
!
!
      SUBROUTINE INTERPO_LG(GRHF,A,L,NHFILM,NZSR,NZOB,X,IOB,ISR,F,NF)
!
!**** INTERPOLATION OF THE HANKEL INTEGRALS
!
!    One-dimensional three-point Lagrangian interpolations
!    in the Rho-direction.
!
! Input parameters:
!
!   GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!           the Hankel integrals.
!   L:      Integer,  number of grid points.
!   A:      Real A(L),  array for grid points.
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   X:      Real,  interpolation point.
!   IOB:    Integer,  number for receiver z-level.  It is used to
!           specify the third array element of GRHF.
!   ISR:    Integer,  number for receiver z'-level.  It is used to
!           specify the fourth array element of GRHF.
!   NF:     Integer,  number of functions to be interpolated.
!
! Output parameter:
!
!   F:      Complex F(NF),  interpolated NF function values.
!
!
!    This routine is similar to the routine intpl4 a
!    three-point rule is used.
!
!
!**** Called by:  THR_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL A1,A2,A3,X
      INTEGER I,I1,II,IOB,ISR,L,L1,NF,NHFILM,NN,NZSR,NZOB
      REAL A(L),U(3)
      COMPLEX GRHF(11,NHFILM,NZSR,NZOB),F(NF)
!
! --- Sorting
!
      L1=L-2
      DO I=1,L1
         IF (X<=A(I+1)) THEN
            GOTO 100
         END IF
      END DO
      I=L-2
  100 IF (I/=1.AND.X-A(I)<A(I+1)-X) I=I-1
!
! --- Compute interpolant coefficients
!
      A1=A(I)
      A2=A(I+1)
      A3=A(I+2)
      U(1)=(X-A2)*(X-A3)/((A1-A2)*(A1-A3))
      U(2)=(X-A1)*(X-A3)/((A2-A1)*(A2-A3))
      U(3)=(X-A1)*(X-A2)/((A3-A1)*(A3-A2))
!
      DO NN=1,NF
         F(NN)=(.0,.0)
      END DO
!
      DO II=1,3
         I1=I+II-1
!
         DO NN=1,NF
            F(NN)=F(NN)+U(II)*GRHF(NN,I1,ISR,IOB)
         END DO
      END DO
      RETURN
      END
!
!**** End of INTERPO_LG
!
!
      SUBROUTINE INTERPO_LG1(GRHF3,A,L,NHFILM,NZSR,X,ISR,F,NF)
!
!****   INTERPOLATION OF THE GREEN'S FUNCTIONS FOR
!     OUTCROPPING CELLS.
!
!    One-dimensional three-point Lagrangian interpolations
!    in the Rho-direction.
!
! Input parameters:
!
!   GRHF3:  Complex GRHF3(11,NHFILM,NZSR), tabulated values of
!           the Hankel integrals for an outcropping cell.
!   L:      Integer,  number of grid points.
!   A:      Real A(L),  array for grid points.
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   X:      Real,  interpolation point.
!   ISR:    Integer,  number for receiver z'-level.  It is used to
!           specify the fourth array element of GRHF.
!   NF:     Integer,  number of functions to be interpolated.
!
! Output parameter:
!
!   F:      Complex F(NF),  interpolated NF function values.
!
!
!    This routine is similar to the routine intpl4 except that a
!    five-point rule is used and that there is no z-level.
!
!
!**** Called by:  THR_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      REAL A1,A2,A3,X
      INTEGER I,I1,II,ISR,L,L1,NF,NHFILM,NN,NZSR
      REAL A(L),U(3)
      COMPLEX GRHF3(11,NHFILM,NZSR),F(NF)
!
! --- Sorting
!
      L1=L-2
      DO I=1,L1
         IF (X<=A(I+1)) THEN
            GOTO 100
         END IF
      END DO
      I=L-2
  100 IF (I/=1.AND.X-A(I)<A(I+1)-X) I=I-1
!
! --- Computing interpolant coefficients
!
      A1=A(I)
      A2=A(I+1)
      A3=A(I+2)
      U(1)=(X-A2)*(X-A3)/((A1-A2)*(A1-A3))
      U(2)=(X-A1)*(X-A3)/((A2-A1)*(A2-A3))
      U(3)=(X-A1)*(X-A2)/((A3-A1)*(A3-A2))
!
      DO NN=1,NF
         F(NN)=(.0,.0)
      END DO
!
      DO II=1,3
         I1=I+II-1
         DO NN=1,NF
            F(NN)=F(NN)+U(II)*GRHF3(NN,I1,ISR)
         END DO
      END DO
!
      RETURN
      END
!
!**** End of INTERPO_LG1
!
!
      SUBROUTINE INTERPO_LG4(GRHF,A,L,NHFILM,NZSR,NZOB,X,IOB,ISR,F,NF)
!
!**** INTERPOLATION OF THE HANKEL INTEGRALS
!
!    Five-point Lagrangian interpolations
!    in the Rho-direction.
!    Note the abscissas are equally spaced
!
! Input parameters:
!
!   GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!           the Hankel integrals.
!   L:      Integer,  number of grid points.
!   A:      Real A(L),  array for grid points.
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   X:      Real,  interpolation point.
!   IOB:    Integer,  number for receiver z-level.  It is used to
!           specify the third array element of GRHF.
!   ISR:    Integer,  number for receiver z'-level.  It is used to
!           specify the fourth array element of GRHF.
!   NF:     Integer,  number of functions to be interpolated.
!
! Output parameter:
!
!   F:      Complex F(NF),  interpolated NF function values.
!
!
!    This routine is similar to the routine intpl15 a
!    five-point rule is used.
!
!
!**** Called by:  THR_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER I,I1,ICN2,II,IOB,ISR,L,NF,NHFILM,NN,NZSR,NZOB
      REAL P,P1,P2,PP,X
      REAL A(L),U(5)
      COMPLEX GRHF(11,NHFILM,NZSR,NZOB),F(NF)
!
! --- Sorting
!
      IF (X<=A(1)) THEN
         I=1
      ELSEIF (X>=A(L)) THEN
         I=L
      ELSE
         DO I=1,L-1
            IF (X>=A(I).AND.X<=A(I+1)) THEN
               EXIT
            END IF
         END DO
      END IF
!
      IF (I<=3) THEN
         ICN2=1
      ELSEIF (I>=L-2) THEN
         ICN2=L-4
      ELSE
         ICN2=I-2
      END IF
!
! --- Compute interpolant coefficients
!
      P=(X-A(ICN2+2))/(A(2)-A(1))
!
      PP=P*P
      P1=(PP-1.)*P/24.
      P2=P*(PP-4.)/6.
      U(1)=P1*(P-2.)
      U(2)=-(P-1.)*P2
      U(3)=(PP-1.)*(PP-4.)/4.
      U(4)=-(P+1.)*P2
      U(5)=P1*(P+2.)
!
      DO NN=1,NF
         F(NN)=(.0,.0)
      END DO
!
      DO II=1,5
         I1=ICN2+II-1
         DO NN=1,NF
            F(NN)=F(NN)+U(II)*GRHF(NN,I1,ISR,IOB)
         END DO
      END DO
!
      RETURN
      END
!
!**** End of INTERPO_LG4
!
!
      SUBROUTINE INTERPO_LG5(GRHF3,A,L,NHFILM,NZSR,X,ISR,F,NF)
!
!****   INTERPOLATION OF THE HANKEL INTEGRALS FOR
!     OUTCROPPING CELLS.
!
!    Five-point Lagrangian interpolations
!    in the Rho-direction.
!    Note the abscissas are equally spaced
!
!
! Input parameters:
!
!   GRHF3:  Complex GRHF3(11,NHFILM,NZSR), tabulated values of
!           the Hankel integrals for an outcropping cell.
!   L:      Integer,  number of grid points.
!   A:      Real A(L),  array for grid points.
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   X:      Real,  interpolation point.
!   ISR:    Integer,  number for receiver z'-level.  It is used to
!           specify the fourth array element of GRHF.
!   NF:     Integer,  number of functions to be interpolated.
!
! Output parameter:
!
!   F:      Complex F(NF),  interpolated NF function values.
!
!
!    This routine is similar to the routine intpl except that a
!    five-point rule is used.
!
!
!**** Called by:  THR_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER I,I1,ICN2,II,ISR,L,NF,NHFILM,NN,NZSR
      REAL P,P1,P2,PP,X
      REAL A(L),U(5)
      COMPLEX GRHF3(11,NHFILM,NZSR),F(NF)
!
      IF (X<=A(1)) THEN
         I=1
         GOTO 100
      END IF
      IF (X>=A(L)) THEN
         I=L
         GOTO 100
      END IF
      DO I=1,L-1
         IF (X>=A(I).AND.X<=A(I+1)) THEN
            EXIT
         END IF
      END DO
!
  100 IF (I<=3) THEN
         ICN2=1
      ELSEIF (I>=L-2) THEN
         ICN2=L-4
      ELSE
         ICN2=I-2
      END IF
      P=(X-A(ICN2+2))/(A(2)-A(1))
!
      PP=P*P
      P1=(PP-1.)*P/24.
      P2=P*(PP-4.)/6.
      U(1)=P1*(P-2.)
      U(2)=-(P-1.)*P2
      U(3)=(PP-1.)*(PP-4.)/4.
      U(4)=-(P+1.)*P2
      U(5)=P1*(P+2.)
!
      DO NN=1,NF
         F(NN)=(.0,.0)
      END DO
!
      DO II=1,5
         I1=ICN2+II-1
         DO NN=1,NF
            F(NN)=F(NN)+U(II)*GRHF3(NN,I1,ISR)
         END DO
      END DO
!
      RETURN
      END
!
!**** End of INTERPO_LG5
!
!
      SUBROUTINE INTERPO_LG6(GRHF,A,L,NHFILM,NZSR,NZOB,X,IOB,ISR,F,NF)
!
!****    INTERPOLATION OF THE HANKEL INTEGRALS
!
!    Six-point Lagrangian interpolations
!    in the Rho-direction.
!    Note the abscissas are equally spaced
!
! Input parameters:
!
!   GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!           the Hankel integrals.
!   L:      Integer,  number of grid points.
!   A:      Real A(L),  array for grid points.
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   X:      Real,  interpolation point.
!   IOB:    Integer,  number for receiver z-level.  It is used to
!           specify the third array element of GRHF.
!   ISR:    Integer,  number for receiver z'-level.  It is used to
!           specify the fourth array element of GRHF.
!   NF:     Integer,  number of functions to be interpolated.
!
! Output parameter:
!
!   F:      Complex F(NF),  interpolated NF function values.
!
!
!    This routine is similar to the routine intpl4 a
!    six-point rule is used.
!
!
!**** Called by:  ONE_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER I,I1,ICN2,II,IOB,ISR,L,NF,NHFILM,NN,NZSR,NZOB
      REAL P,P1,P2,P3,PP1,PP4,X
      REAL A(L),U(6)
      COMPLEX GRHF(11,NHFILM,NZSR,NZOB),F(NF)
!
! --- Sorting
!
      IF (X<=A(1)) THEN
         I=1
      ELSEIF (X>=A(L)) THEN
         I=L
      ELSE
         DO I=1,L-1
            IF (X>=A(I).AND.X<=A(I+1)) THEN
               EXIT
            END IF
         END DO
      END IF
!
      IF (I<=3) THEN
         ICN2=1
      ELSEIF (I>=L-3) THEN
         ICN2=L-5
      ELSE
         ICN2=I-2
      END IF
!
! --- Compute interpolant coefficients
!
      P=(X-A(ICN2+2))/(A(2)-A(1))
!
      PP1=(P-1.)*(P+1.)
      PP4=(P-2.)*(P+2.)
      P1=PP1*P/120.
      P2=P*(P-3.)/24.
      P3=(P-3.)*PP4/12.
      U(1)=-P1*(P-2.)*(P-3.)
      U(2)=P2*(P-1.)*PP4
      U(3)=-P3*PP1
      U(4)=P3*P*(P+1.)
      U(5)=-P2*PP1*(P+2.)
      U(6)=P1*PP4
!
      DO NN=1,NF
         F(NN)=(.0,.0)
      END DO
!
      DO II=1,6
         I1=ICN2+II-1
         DO NN=1,NF
            F(NN)=F(NN)+U(II)*GRHF(NN,I1,ISR,IOB)
         END DO
      END DO
!
      RETURN
      END
!
!**** End of INTERPO_LG6
!
!
   SUBROUTINE INTERPO_PLPOL(GRHF,A,L,NHFILM,NZSR,NZOB,X,IOB,ISR,F,NF)
!
!****    INTERPOLATION OF THE HANKEL TRANSFORMS
!
!      Eight-point polynomial or rational interpolations
!      in the Rho-direction.
!
!
!   Input parameters:
!
!     GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!             the Hankel integrals.
!     L:      Integer,  number of grid points.
!     A:      Real A(L),  array for grid points.
!     NHFILM: Integer,  maximal number of grids in the lateral direction
!             (rho) for all the Hankel integrals.
!     X:      Real,  interpolation point.
!     IOB:    Integer,  number for receiver z-level.  It is used to
!             specify the third array element of GRHF.
!     ISR:    Integer,  number for receiver z'-level.  It is used to
!             specify the fourth array element of GRHF.
!     NF:     Integer,  number of functions to be interpolated.
!
!   Output parameter:
!
!     F:      Complex F(NF),  interpolated NF function values.
!
!
!      This routine takes much more computation time than the
!      Lagrangian interpolations because the interpolation is
!      done recursively for each component of the array F.
!
!
!**** Called by:  ONE_D_GREEN
!
!**** Calls:      none
!
!
      IMPLICIT NONE
!
      INTEGER, INTENT(IN) :: IOB,ISR,L,NF,NHFILM,NZSR,NZOB
      REAL, INTENT(IN) :: A(L)
      COMPLEX, INTENT(OUT) :: F(NF)
!
      INTEGER :: I,I1,ICN2,II,NN
      REAL :: X
      INTEGER, PARAMETER :: NINT=8, NINTM=10
      COMPLEX :: DY,YA(NINTM)
!
      REAL :: XA(NINT)
      COMPLEX, INTENT(IN) :: GRHF(11,NHFILM,NZSR,NZOB)
!
      IF (X<=A(1)) THEN
         I=1
      ELSEIF (X>=A(L)) THEN
         I=L
      ELSE
         DO I=1,L-1
            IF (X>=A(I).AND.X<=A(I+1)) THEN
               EXIT
            END IF
         END DO
      END IF
!
      IF (I<=4) THEN
         ICN2=1
      ELSEIF (I>=L-4) THEN
         ICN2=L-7
      ELSE
         ICN2=I-3
      END IF
!
      DO II=1,NINT
         I1=ICN2+II-1
         XA(II)=A(I1)
      END DO
!
! --- May need to use a two dimensional array for YA
!     in order to save time.
!
      DO NN=1,NF
!
         DO II=1,NINT
            I1=ICN2+II-1
            YA(II)=GRHF(NN,I1,ISR,IOB)
         END DO
!
         CALL INTERPO_POLINT(XA,YA,NINT,X,F(NN),DY)
!
      END DO
!
      RETURN
!
   END SUBROUTINE INTERPO_PLPOL
!
!
      SUBROUTINE INTERPO_POLINT(XA,YA,N,X,Y,DY)
!
!**** Polynomial interpolation
!
!   modified from Press et al., Numerical recipes, p.82
!
!
      IMPLICIT NONE
!
      REAL DIF,DIFT,HO,HP,TINY,X
      INTEGER I,M,N,NMAX,NS
!
      PARAMETER (NMAX=10,TINY=1.E-30)
      REAL XA(N)
      COMPLEX YA(N),Y,DY,C(NMAX),D(NMAX),W,DEN
      NS=1
      DIF=ABS(X-XA(1))
      DO I=1,N
         DIFT=ABS(X-XA(I))
         IF (DIFT<DIF) THEN
            NS=I
            DIF=DIFT
         END IF
         C(I)=YA(I)
         D(I)=YA(I)
      END DO
      Y=YA(NS)
      NS=NS-1
      DO M=1,N-1
         DO I=1,N-M
            HO=XA(I)-X
            HP=XA(I+M)-X
            W=C(I+1)-D(I)
            DEN=CMPLX(HO-HP,0.)
            IF (ABS(DEN)<TINY) THEN
               STOP 'Error in routine INTERPO_POLINT: two identical XA!'
            END IF
            DEN=W/DEN
            D(I)=HP*DEN
            C(I)=HO*DEN
         END DO
         IF (2*NS<N-M) THEN
            DY=C(NS+1)
         ELSE
            DY=D(NS)
            NS=NS-1
         END IF
         Y=Y+DY
      END DO
      RETURN
      END
!
!
   SUBROUTINE THR_D_HF_TABLE(HIGH_FRQ,NHFILM,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,  &
                             KSFT,BLMIN,KEYG,DMIN,RHOMIN,RHOMAX,NZOB,ZOBG,  &
                             NZSR,ZSRG,ALMAX,RRG,NRG,RRG3,NRG3,GRHF,GRHF3,  &
                             GRHO0,GRHO03)
!
!****  Compute tabulated Hankel integrals of the Green's functions
!    on a three-demensional grids in the rho (the lateral) direction,
!    z, and z'-directions (or the z and z'-levels).  Note that
!    Hankel integrals for many kernels associated withe the components
!    of the tensor Green's functions are computed simultaneously,
!    thus the array GRHF is four-dimensional.  Those tabulated values
!    are interpolated to compute actual Green's functions or field
!    components.
!
!
! Input parameters:
!
!   HIGH_FRQ: Integer, switch for high frequency or low frequency module.
!             =0, use low frequency filters
!             =1, use high frequency filters
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   MLAYER: Integer, number of layers excluding the air.
!   ZBND:   Real ZBND(0:MLAYER), coordinates of the layer
!           boundaries with the air earth interface being zbnd(0)=0.
!   LRYTH:  Real LRYTH(MLAYER),  thickness of each layer (the air is not
!           included in LRYTH).
!   HVK:    Real HVK(0:MLAYER),  coefficients of anisotropy of the layers
!           including the air (layer 0 with HVK(0)=1).  The anisotropy
!           coefficients are defined as the square roots of the ratios of
!           horizontal conductivities to vertical conductivities of each
!           layer.  Elements of HVK are always equal to or larger than 1.
!   KKH:    Complex(*8) KKH(0:MLAYER),  square ( **2) of the complex wave
!           number of the layers including the air (layer number 0).
!   KANIS:  Integer, flag for the anisotropy of the media.
!           KANIS=1:  the media are anisotropic in the verical
!                     direction;  and
!           KANIS=0:  the media are isotropic.
!           If the media are isotropic,  use KANIS=0 to simplify
!           the computation.
!   KSFT:   Integer,  parameter controlling whethter there is an outcropping
!           cell.  KSFT=1: yes; and KSFT=0:, no.
!   BLMIN:  Real,  redius and height of a cylinder to be removed
!           from computation for the treatment of singularity
!           arising in the computation of magnetic fields due to
!           an outcropping cell.  See description for KUTCRP
!           in routine THR_D_GREEN for more details.
!   KEYG:   Integer.  Mode of computation controlling whether mangetic
!           fields are to be computed.
!           KEYG=1:  Computing electric fields only.  This is used
!                    when elements of the scattering impedance
!                    matrix are computed;  and
!               =2:  All components of the electric and magnetic fields
!                    are computed as in the computation of secondary
!                    E- and H-fields.
!   DMIN:   Real,  minmum of dimension for numerical treatments of cells.
!           DMIN=0.1 for the low frequency mdule and DMIN=0.001 for the
!           high frequency module.
!   RHOMIN: Real,  minimal dimension in the lateral direction (rho).
!   RHOMAX: Real,  maxiaml dimension in the lateral direction (rho).
!   NZOB:   Integer, number of z-levels. Determined in the main program.
!   ZOBG:   Real ZOBG(NZOB), the nzob z-levels coordinates.
!   NZSR:   Integer,  number of z'-levels.
!   ZSRG:   Real ZSRG(NZSR),  the nzsr z'-levels.
!
!   Parameter ALMAX is to be passed into routine ONE_D_KERNEL.  See
!   ONE_D_KERNEL for its description.
!
! Output parameters:
!
!   NRG:    Integer,  number of grids in the lateral direction (rho).
!   RRG:    Real RRG(NRG),  the NRG grid points in rho.
!   NRG3:   Integer,  number of grids in the lateral direction (rho) for
!           the Hankel integrals for outcropping cells, namely, for the
!           array GRHF3 (see following description).
!   RRG3:   Real RRG3(NRG3),  the NRG3 grid points in rho for GRHF3.
!   GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!           the Hankel integrals.  To be passed to the interpolation
!           routines.
!   GRHF3:  Complex GRHF3(11,NHFILM,NZSR), tabulated values of
!           the Hankel integrals for outcropping cells.  To be passed
!           to the interpolation routines.  It is integrated from blmin
!           to zsrg(2,*) for receivers at the earth's surface.
!   GRHO0:  Complex GRHO0(4,NZSR), tabulated values of the
!           Hankel integrals for rho=0 (source and receiver have the
!           same x and y coordinates).
!   GRHO03:  Complex GRHO03(4,NZSR,NZOB), tabulated values of the
!           Hankel integrals for outcropping cells for rho=0 (source
!           and receiver have the same x and y coordinates).
!
!
! Remarks:
!
!      The grid points in the rho (or R) direction are set
!      up automatically by the Hankel transform subroutine
!      on a logrithmical scale.   Note that the interpolated
!      values in the rho-direction must be divided by rho
!      to obtain the value of the Hankel transform.
!
!      The grid values of the Hankel transform in the z and z'
!      directions are stored at exactly those z and z'-levels
!      (ZOBG and ZSRG) which are determined by discretization.
!      Hence no interpolations in the z and z'-direction are
!      necessary.
!
!      All the Hankel transforms are integrated analytically
!      in the z'-directrion. Results are stored in the preassigned
!      z'-levels (ZSRG) with both upper and lower limits for
!      integration.
!
!      If KSFT=1 and KEYG=2, the array grhf3 and grho3 will
!      be compute. These two arrays are used to deal with the
!      singularities of the secondary magnetic fields at the
!      earth's surface (z=z'=0).
!
!
!**** Called by:  main
!
!**** Calls:      ONE_D_0_2_INFTY,  HFILL,  HFILH
!
!
      IMPLICIT NONE
!
      REAL, INTENT(IN) :: ALMAX,BLMIN,DMIN,RHOMAX,RHOMIN
      INTEGER, INTENT(IN) :: KANIS,KEYG,KSFT,MLAYER,NHFILM,NZOB,NZSR,HIGH_FRQ
      INTEGER, INTENT(INOUT) :: NRG,NRG3
      REAL, INTENT(IN) :: ZOBG(NZOB),ZSRG(2,NZSR),                            &
                          LRYTH(MLAYER),ZBND(0:MLAYER),HVK(0:MLAYER)
      REAL, INTENT(INOUT) :: RRG(NHFILM),RRG3(NHFILM)
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER)
      COMPLEX, INTENT(INOUT) :: GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB), &
                                GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER :: KITG,KPRM,KCHRG,KEMD,NF,NOB,NSR,I,II,J,JJ
      REAL    :: ZSR1
      COMPLEX :: S(4),S1(4)
!
!  -- HF and HF1 are allocatable working arrays for the kernels of the
!     Hankel transforms.
!
      COMPLEX, ALLOCATABLE :: HF(:,:),HF1(:,:)
!
      ALLOCATE(HF(11,NHFILM),HF1(11,NHFILM))
!
! --- KEMD control if electric or magnetic dipoles are to be
!   computed.  Here for the Green's tensors within the body,
!   only electric dipoles are considered.
!
      KEMD=1
!
! --- The parameter KCHRG controls the charge terms in the
!   kernels of Hankel transform.
!
      KCHRG=0
!
      KITG=1
!
      IF (KEYG==1) THEN
         NF=6
      ELSE
         NF=11
      END IF
!
      DO I=1,NZOB
!
         DO II=MLAYER-1,0,-1
            IF (ZOBG(I)>=ZBND(II)) THEN
               NOB=II+1
               GOTO 50
            END IF
         END DO
         NOB=0
!
   50    DO J=1,NZSR
!
            DO II=MLAYER-1,0,-1
               IF ((ZSRG(1,J)+ZSRG(2,J))/2.>=ZBND(II)) THEN
                  NSR=II+1
                  GOTO 60
               END IF
            END DO
            NSR=0
!
!---- The Green's functions will be separated into primary and
!     secondary parts if the receiver and the source reside
!     in the same layer in forming the scattering matrices,
!     or if there are receivers located in the 3D structure
!     in computing the scattered fields.
!
! 20   IF(KEYG==1.AND.NOB==NSR .OR.
!   +   KEYG==2.AND.KGHP==0.AND.NOB==NSR) THEN
!
   60       IF (KEYG==1.AND.NOB==NSR) THEN
               KPRM=0
            ELSE
               KPRM=1
            END IF
!
! ---- If zobg(i) lies in the integral interval (zsrg(1,j)-zsrg(2,j)),
!    the intergral will be cut into two parts.
!
!    Note that zsrg(2,j) > zsrg(1,j).
!
! ----- Note the grid points in the Rho-direction are generated
!     by the program HFILL ore HFILH
!
            IF (ZOBG(I)>ZSRG(2,J).OR.ZOBG(I)<ZSRG(1,J)) THEN
               IF (HIGH_FRQ==0)  &
               CALL HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,      &
                          KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,ZOBG(I),            &
                          ZSRG(2,J),ZSRG(1,J),NRG,RRG,HF,NHFILM)
               IF (HIGH_FRQ==1)  &
               CALL HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,      &
                          KITG,KCHRG,NOB,NSR,RHOMIN,RHOMAX,ZOBG(I),            &
                          ZSRG(2,J),ZSRG(1,J),NRG,RRG,HF,NHFILM)
            ELSE
               IF (HIGH_FRQ==0)  &
               CALL HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KITG, &
                          KCHRG,NOB,NSR,RHOMIN,RHOMAX,ZOBG(I),ZSRG(2,J),       &
                          ZOBG(I),NRG,RRG,HF,NHFILM)
               IF (HIGH_FRQ==1)  &
               CALL HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KITG, &
                          KCHRG,NOB,NSR,RHOMIN,RHOMAX,ZOBG(I),ZSRG(2,J),       &
                          ZOBG(I),NRG,RRG,HF,NHFILM)
               IF (HIGH_FRQ==0)  &
               CALL HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KITG, &
                          KCHRG,NOB,NSR,RHOMIN,RHOMAX,ZOBG(I),ZOBG(I),         &
                          ZSRG(1,J),NRG,RRG,HF1,NHFILM)
               IF (HIGH_FRQ==1)  &
               CALL HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KITG, &
                          KCHRG,NOB,NSR,RHOMIN,RHOMAX,ZOBG(I),ZOBG(I),         &
                          ZSRG(1,J),NRG,RRG,HF1,NHFILM)
            END IF
!
            IF (ZOBG(I)>=ZSRG(1,J).AND.ZOBG(I)<=ZSRG(2,J)) THEN
!
!---- This may also happen for keyg=2 for cells just below
!     the earth's surface
               DO JJ=1,NRG
                  DO II=1,NF
                     GRHF(II,JJ,J,I)=HF(II,JJ)+HF1(II,JJ)
                  END DO
               END DO
            ELSE
               DO JJ=1,NRG
                  DO II=1,NF
                     GRHF(II,JJ,J,I)=HF(II,JJ)
                  END DO
               END DO
            END IF
!
! ----- To avoid singularity in case zobg(i) and zsrg(1,j) = 0
!     the lower limit for integration in the z'-direction is
!     increased from 0 to blmin/2.
!     Note that for outcropping structures the electric fields
!     on the top of blocks at the earth's surface are determined
!     from the scattering currents directly.
!
!     Note that the two elements for self-cells are not
!     computed.
!
            IF (KEYG/=2.OR.ABS(ZOBG(I))>=DMIN.OR.ABS(ZSRG(1,J))>=DMIN)  THEN
!----------------------------------------------------
!|                                                  |
! -- Outcroppers are computed later
!
               IF (ZOBG(I)>ZSRG(2,J).OR.ZOBG(I)<ZSRG(1,J)) THEN
                  CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH, &
                                   KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),   &
                                   ZSRG(2,J),ZSRG(1,J),ALMAX,KEYG+1,S)
!
! -- The following two blocks are used to avoid singularity
!    if the receivers are located on or near a layer boundary
!    within the 3D structure, or in the case when the receiver
!    is located on the top or bottom of a cell and yet in a
!    different layer as the cell
!
               ELSEIF (ABS(ZOBG(I)-ZSRG(2,J))<DMIN.AND.NOB/=NSR) THEN
                  CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,  &
                                   KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),    &
                                   ZSRG(2,J)-BLMIN,ZSRG(1,J),ALMAX,KEYG+1,S1)
                  DO JJ=1,KEYG+1
                     S(JJ)=(0.,0.)
                  END DO
               ELSEIF (ABS(ZOBG(I)-ZSRG(1,J))<DMIN.AND.NOB/=NSR) THEN
                  CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,  &
                                   KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),    &
                                   ZSRG(2,J),ZSRG(1,J)+BLMIN,ALMAX,KEYG+1,S)
                  DO JJ=1,KEYG+1
                     S1(JJ)=(0.,0.)
                  END DO
               ELSE
                  CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,  &
                                   KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),    &
                                   ZSRG(2,J),ZOBG(I),ALMAX,KEYG+1,S)
                  CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,  &
                                   KANIS,KPRM,KITG,KCHRG,NOB,NSR,ZOBG(I),    &
                                   ZOBG(I),ZSRG(1,J),ALMAX,KEYG+1,S1)
               END IF
!
            END IF
!|                                                  |
!----------------------------------------------------
!
            DO JJ=1,KEYG+1
               IF (ZOBG(I)>ZSRG(2,J).OR.ZOBG(I)<ZSRG(1,J)) THEN
                  GRHO0(JJ,J,I)=S(JJ)
               ELSE
                  GRHO0(JJ,J,I)=S(JJ)+S1(JJ)
               END IF
            END DO
!
         END DO
      END DO
!
      DO JJ=1,NRG
         RRG(JJ)=ALOG(RRG(JJ))
      END DO
!
      IF (KEYG==2.AND.KSFT==1) THEN
!**************************************************
!*                                                *
!
! ---- For outcropping structures a cylindrical volume with radius
!    of blmin and height of blmin near the observer will be
!    removed in the integration of the magnetic Green's functions.
!
!   Note here the receiver and source are in the same layer.
!   The surface of the earth is always considered to be layer # 1
!   which is the layer of the outcropping cells. Notice the .ge.
!   in the lines determining layer sequences throught the program.
!
!   kprm changed to be 1.   See the comments at the beginning of
!   the routine THR_D_GREEN
!
!    KPRM=0
!
         KPRM=1
!
! --- The array grhf3 adn grho3 are formed for every z'-level,
!   but ... (see below)
!
         DO I=1,NZSR
!
            ZSR1=(ZSRG(1,I)+ZSRG(2,I))/2.
!
            DO II=MLAYER-1,0,-1
               IF (ZSR1>=ZBND(II)) THEN
                  NSR=II+1
                  GOTO 80
               END IF
            END DO
            NSR=0
   80       NOB=NSR
!
! --- Compute GRHF3 for outcropping cells.
!
            IF (ZSRG(1,I)<=.1) THEN
               IF (HIGH_FRQ==0)  &
               CALL HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,   &
                          KPRM,KITG,KCHRG,NOB,NSR,.1,BLMIN,0.,         &
                          ZSRG(2,I),BLMIN,NRG3,RRG3,HF,NHFILM)
               IF (HIGH_FRQ==1)  &
               CALL HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,   &
                          KPRM,KITG,KCHRG,NOB,NSR,.1,BLMIN,0.,         &
                          ZSRG(2,I),BLMIN,NRG3,RRG3,HF,NHFILM)
            END IF
!
            DO II=1,NF
               DO JJ=1,NRG3
                  GRHF3(II,JJ,I)=HF(II,JJ)
               END DO
            END DO
!
            IF (ZSRG(1,I)<=.1) THEN
               CALL ONE_D_0_2_INFTY(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,   &
                                    KKH,KANIS,KPRM,KITG,KCHRG,NOB,NSR, &
                                    0.,ZSRG(2,I),BLMIN,ALMAX,3,S)
               GRHO03(1,I)=S(1)
               GRHO03(2,I)=S(2)
               GRHO03(4,I)=S(3)
            END IF
!
         END DO
!
         DO JJ=1,NRG3
            RRG3(JJ)=ALOG(RRG3(JJ))
         END DO
!
!*                                                *
!**************************************************
      END IF
!
      DEALLOCATE(HF,HF1)
!
   END SUBROUTINE THR_D_HF_TABLE
!
!
      SUBROUTINE THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,CDH,HVK,NZOB,ZOBG,  &
                             NZSR,ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3, &
                             NRG3,GRHF3,GRHO0,GRHO03,CLX,CLY,CLZ,CLMN,KCLMN, &
                             BLMIN,KACC,KUTCRP,KSELF,ECOMP,HCOMP)
!
!****   Integration of the tensor green's functions over a
!     prismatic cell
!
!
! Input parameters:
!
!   KEYG:   Integer.  Mode of computation controlling whether mangetic
!           fields are to be computed.
!           KEYG=1:  Computing electric fields only.  This is used
!                    when elements of the scattering impedance
!                    matrix are computed;  and
!               =2:  All components of the electric and magnetic fields
!                    are computed as in the computation of secondary
!                    E- and H-fields.
!   PSTION: Real PSTION(8),  the positions of the source and the
!           receiver plus the lower and upper z-coordinates the kernels
!           are integrated analytically.  The first 3 elements of the
!           array is for the x, y, and z-coordinates of the receiver,
!           which are followed by the x, y, and z-coordinates of the
!           source.  The last two elements are the lower and upper
!           z-coordinates of the integral interval.  If the kernels
!           are not integrated,  the last two elements must be identical
!           to the source z-coordinate,  i.e.,  the last three elements
!           of PSTION must be the same if the kernels are not to be
!           integrated in teh vertical direction.
!   FRQ:    Real(*4), frequency.
!   MLAYER: Integer, number of layers excluding the air.
!   ZBND:   Real ZBND(0:MLAYER), coordinates of the layer
!           boundaries with the air earth interface being zbnd(0)=0.
!   CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!           the layers in the lateral direction including the
!           air (layer 0).
!   HVK:    Real HVK(0:MLAYER),  coefficients of anisotropy of the layers
!           including the air (layer 0 with HVK(0)=1).  The anisotropy
!           coefficients are defined as the square roots of the ratios of
!           horizontal conductivities to vertical conductivities of each
!           layer.  Elements of HVK are always equal to or larger than 1.
!   NZOB:   Integer, number of z-levels. Determined in the main program.
!   ZOBG:   Real ZOBG(NZOB), the nzob z-levels coordinates.
!   NZSR:   Integer,  number of z'-levels.
!   ZSRG:   Real ZSRG(NZSR),  the nzsr z'-levels.
!   RHOMIN: Real,  minimum of the lateral grid (rho) which determines
!           the minimum of rho in the Hankel integrals.  RHOMIN=0.1 for
!           the low frequency mdule and RHOMIN=0.01 for the high
!           frequency module.
!   DMIN:   Real,  minmum of dimension for numerical treatments of cells.
!           DMIN=0.1 for the low frequency mdule and DMIN=0.001 for the
!           high frequency module.
!   NHFILM: Integer,  maximal number of grids in the lateral direction
!           (rho) for all the Hankel integrals.
!   NRG:    Integer,  actual number of grids in the lateral direction
!           (rho) for the arrays RRG and GRHF.
!   RRG:    Real RRG(NRG),  the NRG grid points in rho.
!   GRHF:   Complex GRHF(11,NHFILM,NZSR,NZOB), tabulated values of
!           the Hankel integrals.  To be passed to the interpolation
!           routines.
!   NRG3:   Integer,  number of actual grids in the lateral direction
!           (rho) for the arrays RRG3 and GRHF3.
!   RRG3:   Real RRG3(NRG),  the NRG3 grid points in rho.
!   GRHF3:  Complex GRHF3(11,NHFILM,NZSR), tabulated values of
!           the Hankel integrals for outcropping cells.  To be passed
!           to the interpolation routines.
!   GRHO0:  Complex GRHO0(4,NZSR,NZOB), tabulated values of the
!           Hankel integrals for rho=0 (source and receiver have the
!           same x and y coordinates).
!   GRHO03:  Complex GRHO03(4,NZSR,NZOB), tabulated values of the
!           Hankel integrals for outcropping cells for rho=0 (source
!           and receiver have the same x and y coordinates).
!   CLX:    Real,  dimension of the cell in the x-direction.
!   CLY:    Real,  dimension of the cell in the y-direction.
!   CLZ:    Real,  dimension of the cell in the z-direction.
!   KCLMN:  Integer,  controlling paramter for the choice of values
!           for the parameter CLMN.  KCLMN=0:  automatic;  and
!           KCLMN=1:  input.  See the following description for
!           CLMN for details.
!   CLMN:   Real,  medium dimension for which the number steps
!           in the numerical integration is defined.  The parameter
!           CLMN is a global parameter. For the numerical
!           integrations of self-cells and most directly adjacent
!           cells,  a parameter CLREF is found by the minimal cell
!           dimensions of that cell if keyg=1.  Otherwise the
!           global value of CLMN is used.  This allows automatic
!           control of the accuracy of integration for most cases
!           while minimizing the computation time.  Since the
!           numbers of steps for the volume and the surface
!           integrations over the cell for certain accuracy are
!           mostly determined by the geometric angle of the
!           receiver with respect to cell deimensions,  the
!           minimal cell dimension may be the best reference
!           length in forming the matrix.   But this reference
!           length may increase computation unnecessarily for
!           computing the secondary fields as well as for the
!           matrix entries of far separeted cells if the body is
!           discretized into greatly non-equal sizes of cells,
!           such as very big cells for some part and very thin
!           plate-like cells for other parts.  Therefore,  a
!           global parameter is necessary.  For keyg=1, however,
!           the global clmn may be used if KCLMN=1 which may
!           add more flexibility in dealing with complex structures
!           as well as for manipulating the numerical integrations.
!           Clmn may be input or may have defaulted values.   See
!           documention on the input parameters KCLMN and CLMN
!           in "MARCO.DOC" for details.
!   BLMIN:  Real,  redius and height of a cylinder to be removed
!           from computation for the treatment of singularity
!           arising in the computation of magnetic fields due to
!           an outcropping cell.  See description for KUTCRP
!           in the following for more details.
!   KACC:   Integer,  accuracy level of computation.  KACC=1, 2
!           3, 4, or 5.  KACC controls the accuracy of the
!           numerical integration of the Green's functions
!           with increasing number of steps as KACC increases.
!           The higher the level,  the more accurate at the
!           cost of computation time.  A 2 or 3 is usually
!           adequate.  For high contrast models us 3 or 4.
!           KACC=5 should be used only for serious convergence
!           tests purpose.  See documentation "MARCO.DOC" for
!           more details.
!   KUTCRP: Integer,  parameter controlling whether the receiver
!           is located just above a outcroping cell,  which is
!           determined in the routines emrspm and emrspms.  If so
!           (koutcrp=1),  electric fields won't be computed by
!           routines THR_D_GREEN and geprm.  Instead, the electric
!           fields at the top of a outcroping cell is determined
!           by the scattering current directly in emrspm and emrspms.
!           Magnetic fields are integrated by excluding a small
!           volume (a cylinder with radius and height of BLMIN).
!           This parameter was first introduced for MT problems
!           and has been adapted for downhole receivers of
!           controlled source problems as well as for MT receivers
!           at different z planes.  Thus, koutcrop=1 does not
!           necessarily mean the body outcrops, it may also mean
!           that the receiver is on the surfaces of or within the
!           body.
!           Note that koutcrop=0 when forming the scattering matrix
!           (keyg=1).
!   KSELF:  Integer,  parameter controlling whether computations
!           for self-cells should be done.  It is to be passed to
!           routine THR_D_GEPRM.  See THR_D_GEPRM for detail.
!
!
! Output parameters:
!
!   ECOMP:  Complex ECOMP(9),  the nine components of the electric
!           field tensor,  Exx, Eyx, Ezx, Exy, ..., and Ezz.  Note
!           that in parameters Exy etc. the first index "x" denotes
!           the direction of the field and the second index "y"
!           denotes the direction of the source.
!   HCOMP:  Complex HCOMP(9),  the nine componenets fo the magnetic
!           field tensor which is arranged in the same way as ECOMP.
!
!
!   Note that the Green's functions are not separated into primary and
!   secondary parts as in routine THR_D_GREEN.   Whether the kernels are
!   integrated analytically in the z'-directions or not is controlled
!   in the routine ONE_D_HF_TABLE.  The calling routine ONE_D_LINE must
!   correctly determine this.
!
!   For loop sources, i.e., ksrc=4, 5, or 6, the charge terms in
!   the electric fields need be canceled in the program since
!   they cannot be canceled numerically. This is considered in
!   kernel function, routine kernel, as well as in the routines
!   gridhf and gridcs.   However,  the components Ezz and Exx
!   for rho=0 have different factors before and after the charge
!   terms are removed.  Those factors are numerically more
!   advantagous to be considered here than to be considered in
!   the kernel functions.
!
!   The parameter KRAT controls the interpolation rules to be
!   used in interpolating the Hankel transforms.
!
!   Note that the Hankel integrals for the Green's functions must
!   computed before this routine is called.  The integrals are first
!   tabulated by routine THR_D_HF_TABLE and then interpolated by routines
!   INTERPO_LG4 etc.
!
!
! --- Remarks:
!
!     In parameters like EXY etc. the first index "x" denotes the
!     direction of the field and the second index "y" denotes
!     the direction of the source.
!
!     Cells are not allowed to intersect any layer boundary if
!     numerical integrations of the Green's functions are applied,
!     for otherwise the implementation of the numerical
!     integrations will be much more complicated and possiblly
!     inaccurate.
!
!     Kernels are integrated analytically in the z'-directions.
!     This has been done in the routine THR_D_HF_TABLE with KITG=1.
!     Thus the numerical integrations here are,  except for
!     self-cells, surface integration only.
!
!     The numbers of steps for the primary and secondary parts,
!     or the total Green's functions if not separated,  have
!     been thoroughly tested for both keyg=1 and keyg=2.
!
!     If keyg=1, the primary and secondary parts of the Green's
!     functions are separated if z and z' are in the same layer.
!     however, if keyg=2, they are not separated unless the
!     receiver is on or within the cell.
!
!
!****  CALLED by:
!
!****  CALLS    :  geprm, ghprm, vxyz, intpl, intpl1, intpl4 and intpl5
!
!
      IMPLICIT NONE
!
      REAL BLMIN,C1,C2,CLDST,CLMN,CLNGTH,CLREF,CLX,CLXS,CLY,CLYS,CLZ,CM,  &
           CMX,CMY,CX,CY,DIST,FRQ,RCD
      REAL RHO,RHO1,RHOMIN,SCL,X1,XI,XOB,XR,XSR,XSRS,Y1,YI,YOB,YR,YSR,    &
           YSRS,ZOB,ZSR
      INTEGER I,II,IOB,ISR,ISUB,J,JSUB,KACC,KCLMN,KEYG,KHF,KPRM,KRCD,     &
              KSELF,KUTCRP,MCX,MCY,MINT,MLAYER,MSX
      INTEGER MSY,MX,MXINT,MY,MYINT,MZINT,NF,NHFILM,NOB,NRG,NRG3,NSR,     &
              NZOB,NZSR
!
      COMPLEX ECOMP(9),HCOMP(9),                              &
              EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,            &
              HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ,            &
              GAX,HF(11),WMU,CDH(0:MLAYER),S(4),              &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),   &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      REAL ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),   &
           RRG(NRG),RRG3(NRG3),PSTION(6),DMIN
!
      RHO(XR,YR,XI,YI)=SQRT((XR-XI)**2+(YR-YI)**2)
!
      C2=1./4./3.1415926
      WMU=CMPLX(0.,78.9568352E-7*FRQ)
!
! --- Extract parameter values for XOB etc. from PSTION
!
      XOB=PSTION(1)
      YOB=PSTION(2)
      ZOB=PSTION(3)
      XSR=PSTION(4)
      YSR=PSTION(5)
      ZSR=PSTION(6)
!
! ---- Set the number of steps for the numerical integration according
!    to the accuracy levels. Note that the numbers of steps are assumed
!    to be equal in both of the three dimensions at first. The actual
!    values are then determined later on by the ratios of the lengths
!    of a specific cell in either dimension with the value of the
!    parameter CLMN and by the distance of the cell to the receiver
!    point.
!
      IF (KACC==1) THEN
         MINT=2
      ELSEIF (KACC==2) THEN
         MINT=4
      ELSEIF (KACC==3) THEN
         MINT=6
      ELSEIF (KACC==4) THEN
         MINT=8
      ELSE
         MINT=12
      END IF
!
! ---- Determine the actual number of steps in each dimensions
!
      MXINT=MINT
      MYINT=MINT
      MZINT=MINT
!
! ---- Determine the reference length of the cell dimensions
!    to which the above-asigned numbers of steps are defined.
!    If kclmn=0 and keyg=1, choose the minimal length of the
!    cell dimensions for self-cells and most directly adjacent
!    cells.  Otherwise, use the global value.
!
      CLREF=AMIN1(CLX,CLY,CLZ)+DMIN
      IF (KCLMN==0.AND.KEYG==1.AND.ABS(XOB-XSR)<CLREF.AND.ABS(YOB-YSR)  &
          <CLREF.AND.ABS(ZOB-ZSR)<CLREF) THEN
         CLREF=AMIN1(CLX,CLY,CLZ)
      ELSE
         CLREF=CLMN
      END IF
!
      IF (CLX>CLREF) MXINT=INT(FLOAT(MXINT)*(CLX/CLREF))
      IF (CLY>CLREF) MYINT=INT(FLOAT(MYINT)*(CLY/CLREF))
      IF (CLZ>CLREF) MZINT=INT(FLOAT(MZINT)*(CLZ/CLREF))
!
! --- Determine the layer numbers the cell and the receiver
!   are located.
!   Note that each cell is confined within a single layer.
!
      DO I=MLAYER-1,0,-1
         IF (ZOB>=ZBND(I)) THEN
            NOB=I+1
            GOTO 100
         END IF
      END DO
      NOB=0
  100 DO I=MLAYER-1,0,-1
         IF (ZSR>=ZBND(I)) THEN
            NSR=I+1
            GOTO 200
         END IF
      END DO
      NSR=0
!
! ---- Determine the level of zob in the grid array zobg
!
  200 DO I=1,NZOB
         IF (ABS(ZOB-ZOBG(I))<DMIN) THEN
            IOB=I
            GOTO 300
         END IF
      END DO
!
!      WRITE (23,*) 'Warning: failed to choose a z-level for zob=',ZOB
!
! ---- Determine the level of zsr in the grid array zsrg
!    Note that the z'-levels in the zsr-direction are
!    determined by the full lengths of the cells
!
  300 DO I=1,NZSR
         IF (ABS(ZSR-CLZ/2.-ZSRG(1,I))<DMIN.AND.  &
             ABS(ZSR+CLZ/2.-ZSRG(2,I))<DMIN) THEN
            ISR=I
            GOTO 400
         END IF
      END DO
!
!      WRITE (23,*) 'Warning: failed to choose a z_prime-level',  &
!                  ' for zsr=',ZSR
!
!
! ---- Determine if the Green's functions are to be computed
!    separately as primary and secondary parts. Note this has
!    been taken into account already in the routine gridhf
!    where the gridding is formed.
!
!    Note that the meaning of KPRM is as follows:
!
!       KPRM = 0: the primary fields (the whole space terms) are cal-
!                 culated by the subroutines THR_D_GEPRM and THR_D_GHPRM; and
!            = 1: the primary fields are calculated together with the
!                 secondary terms by means of Hankel transforms
!
!    It is adviced however, not to calculate the whole space and secon-
!    dary parts separately if the observation points (ZOB or z') is in
!    the air and the source (ZSR) is in the earth, because the conducti-
!    vity of the air approaches zero and only simple precision is used
!    here in the calculation and so the electrical fields resulted may
!    be inaccurate.
!
!    The parameter KGHP is disabled.  See the following description.
!    In case this parameter need to be re-considered,  it must
!    be included in the arguement lists in this routine and
!    probably in routne THR_D_HF_TABLE as well.
!
!   KGHP:   Integer, controlling parameter for treatment of
!           singularity if the receiver is located within a cell.
!           KGHP was originally introduced to control the
!           computation for downhole receivers that are located
!           within a cell.  In such cases (KGHP=0), the primary
!           and secondary parts were separated if the receiver
!           and the source cell were in the same layer.  The
!           electric and the magnetic fields were treated in the
!           same way as for outcropping cells.  The singularity in
!           the primary parts of the magnetic Green's function was
!           removed by excluding a small sphere while the
!           contributions of the secondary parts due to a cylinder
!           were excluded in the numerical integration.   This
!           treatment, however,  seemed inaccurate,  mainly
!           because of the routine ghprm, which might still have
!           undetected error.   Therefore Now the primary and the
!           secondary parts are not separated for keyg=2.  Unlike
!           for outcropping cells,  a cylinder with radius of
!           BLMIN and height of clz is removed from the integration
!           of the magnetic Green's functions.  This treatment has
!           been proven to be more accurate and efficient.
!
!    IF(KEYG==1.AND.NOB==NSR .OR.
!   +   KEYG==2.AND.KGHP==0.AND.NOB==NSR) THEN
!
  400 IF (KEYG==1.AND.NOB==NSR) THEN
         KPRM=0
      ELSE
         KPRM=1
      END IF
!
! ---  Further reductions
!
! -- Reduce the number of steps for the secondary terms.  Tests
!    have shown that with a reduction factor of about 1.5 the
!    numerica integrations of the secondary parts may match the
!    accuracy of the primary parts.  Note the secondary parts
!    cost far more computation time for one single value (one step)
!    than the priamry parts.
!
!    This reduction is only valid if when the primary parts are
!    separated from the computation here
!
!  !! May sometimes affects the accuracy !!
!
!    IF(KPRM==0) THEN
!      MXINT=MXINT*.7
!      MYINT=MYINT*.7
!    END IF
!
! ----- The numbers of steps determined above are for the self-cells
!     only, i.e., for |r-r'|=0.  Each cell will be divided into
!     many sub-cells in order to reduce unnecessary computations
!     for cells having great aspect ratios.  The numbers of steps
!     for the numerical integration is then determined by the
!     distance of the subcells to the receiver point.
!
!     Note that the subcells for the primary parts are determined
!     similarly in the corresponding routines.
!
      IF (KPRM==0) THEN
!
! Calculating the primary terms integrated over the cell
!
! --- Note that the E-field of a outcropping block is computed by
!   the scattering current directly
!
         IF (KUTCRP==0) THEN
            CALL THR_D_GEPRM(PSTION,KACC,KSELF,CLREF,MXINT,MYINT,MZINT,CLX, &
                             CLY,CLZ,FRQ,CDH(NSR),HVK(NSR),DMIN,GAX,ECOMP)
            EXX=ECOMP(1)
            EYX=ECOMP(2)
            EZX=ECOMP(3)
            EXY=ECOMP(4)
            EYY=ECOMP(5)
            EZY=ECOMP(6)
            EXZ=ECOMP(7)
            EYZ=ECOMP(8)
            EZZ=ECOMP(9)
         END IF
         IF (KEYG==2) THEN
            CALL THR_D_GHPRM(PSTION,KACC,BLMIN,CLREF,MXINT,MYINT,MZINT,CLX, &
                             CLY,CLZ,FRQ,CDH(NSR),HVK(NSR),DMIN,HCOMP)
            HXX=HCOMP(1)
            HYX=HCOMP(2)
            HZX=HCOMP(3)
            HXY=HCOMP(4)
            HYY=HCOMP(5)
            HZY=HCOMP(6)
            HXZ=HCOMP(7)
            HYZ=HCOMP(8)
            HZZ=HCOMP(9)
         END IF
         EXX=GAX+CDH(NSR)/CDH(NOB)*(EXX-GAX)
         EYX=CDH(NSR)/CDH(NOB)*EYX
         EYY=GAX+CDH(NSR)/CDH(NOB)*(EYY-GAX)
         EXY=EYX
         EZX=CDH(NSR)/CDH(NOB)*EZX
         EZY=CDH(NSR)/CDH(NOB)*EZY
         EXZ=CDH(NSR)/CDH(NOB)*EXZ
         EYZ=CDH(NSR)/CDH(NOB)*EYZ
         EZZ=CDH(NSR)/CDH(NOB)*EZZ
      END IF
!
      IF (KPRM==1) THEN
         EXX=(0.,0.)
         EYX=(0.,0.)
         EZX=(0.,0.)
         EXY=(0.,0.)
         EYY=(0.,0.)
         EZY=(0.,0.)
         EXZ=(0.,0.)
         EYZ=(0.,0.)
         EZZ=(0.,0.)
         IF (KEYG==2) THEN
            HXX=(0.,0.)
            HYX=(0.,0.)
            HZX=(0.,0.)
            HXY=(0.,0.)
            HYY=(0.,0.)
            HZY=(0.,0.)
            HXZ=(0.,0.)
            HYZ=(0.,0.)
            HZZ=(0.,0.)
         END IF
      END IF
!
! -----------  Compute the secondary terms  --------------
!
! ---- Divide the cell into subcells
!
!    Every subcell has a length of either 2*CLREF or 3*CLREF
!    in either direction, according to kacc.   For higher
!    kacc it is more efficient to have smaller subcell size.
!    But small subcell may increase waste for low kacc.
!
!    Note that the cell is not divided in the vertical direction
!    since the Hankel transforms and intergrated analytically
!    in the z-direction.
!
      IF (KACC<=3) THEN
         SCL=3.*CLREF
      ELSE
         SCL=2.*CLREF
      END IF
      MSX=INT(CLX/SCL)
      MSY=INT(CLY/SCL)
      IF (MSX<1) MSX=1
      IF (MSY<1) MSY=1
      MCX=MXINT/MSX
      MCY=MYINT/MSY

      CLXS=CLX/MSX
      CLYS=CLY/MSY
!
      DO ISUB=1,MSX
         IF (MSX==1) THEN
            XSRS=XSR
         ELSE
            XSRS=XSR+CLXS*(ISUB-1)-CLX/2.+.5*CLXS
         END IF
         DO JSUB=1,MSY
            IF (MSY==1) THEN
               YSRS=YSR
            ELSE
               YSRS=YSR+CLYS*(JSUB-1)-CLY/2.+.5*CLYS
            END IF
!
!-- Determine the distance of the subcell to the receiver point
!   with respect to the dimension of the subcell.
!
!   Note that unlike in the routine geprm where only the dimensions
!   of the surfaces are compared with the distance, here it is the
!   subcell diagonal length that is compared with the distance
!   because the x-y surface used in the integration here is for
!   both the bottom and the top of a cell in the z'-direction.
!
            DIST=SQRT((RHO(XOB,YOB,XSRS,YSRS))**2+(ZOB-ZSR)**2)
            CLNGTH=SQRT(CLXS**2+CLYS**2+CLZ**2)
!
! --- Determine the numbers of steps according to the distance
!   between the source and the receiver
!
!-- Determine the location of the receiver close to the cell.
!   This is necessary for computing the EM fields at receiver
!   sites which are close to the cell.  Note that outcropping
!   cells has been considered already elsewhere.
!
            IF (KEYG==2.AND.KUTCRP==0) THEN
!
               IF (DIST<=CLNGTH) THEN
                  CM=AMIN1(CLXS,CLYS,CLZ)
                  KRCD=5
                  DO I=1,4
                     IF (I==1) THEN
                        RCD=.05*CM
                     ELSEIF (I==2) THEN
                        RCD=.1*CM
                     ELSEIF (I==3) THEN
                        RCD=.2*CM
                     ELSE
                        RCD=.5*CM
                     END IF
                     IF (XOB>=XSRS-.5*CLXS-RCD.AND.XOB<=XSRS+.5*CLXS+  &
                         RCD.AND.YOB>=YSRS-.5*CLYS-RCD.AND.  &
                         YOB<=YSRS+.5*CLYS+RCD.AND.ZOB>=ZSR-.5*CLZ-  &
                         RCD.AND.ZOB<=ZSR+.5*CLZ+RCD) THEN
                        KRCD=I
                        EXIT
                     END IF
                  END DO
               END IF
!
! ---- Determine the numbers of steps according to DIST and KRCD
!
               IF (DIST<=CLNGTH) THEN
                  IF (KRCD==1) THEN
                     MX=8*MCX
                     MY=8*MCY
                  END IF
                  IF (KRCD==2) THEN
                     MX=5*MCX
                     MY=5*MCY
                  END IF
                  IF (KRCD==3) THEN
                     MX=3*MCX
                     MY=3*MCY
                  END IF
                  IF (KRCD==4) THEN
                     MX=MCX*2
                     MY=MCY*2
                  END IF
                  IF (KRCD==5) THEN
                     MX=MCX*3/2
                     MY=MCY*3/2
                  END IF
               ELSEIF (DIST<=3.*CLNGTH) THEN
                  MX=MCX
                  MY=MCY
               ELSE
                  CLDST=SQRT(2.*CLNGTH/DIST)
                  MX=INT(FLOAT(MCX)*CLDST)
                  MY=INT(FLOAT(MCY)*CLDST)
               END IF
!
            END IF
!
! --- The following rules for the numbers of steps have been tested
!   thoroughly.
!
!   The introduction of the parameter clref garantees the accuracy
!   of the self-cells.   Self-cells are treatly more accurately in
!   order to ensure accuracies since on the other hand the primary
!   parts need to be computed only once for a block.
!
!   It seems that the accuracy of the numerical integrations for
!   cells from 0 to about 3 clengths has more effects on the
!   final results than other cells.
!
!   The rule for cldst may be changed as sqrt(clength/dist) to
!   save a little bit computation time.  There seems to be no
!   significant difference which one to use.
!
!   The decay patterns of the step numbers have been tested with
!   clength/dist, sqrt(clength/dist), and (clength/dist)**.3333.
!   It seems that the second one yields adequate accuracy while
!   minimizing the computation time.
!
!-- The following rules are also used by outcropping cells
!   in computing the responses at receiver sites
!
            IF (KEYG/=2.OR.KUTCRP/=0) THEN
!
               IF (DIST<=1.*CLNGTH) THEN
                  MX=MCX*3/2
                  MY=MCY*3/2
! --  Test has shown that the above rule is insufficient for the
!   magentic fields of outcropping cells.  Mx and My are thus
!   increased for outcropping cells.
                  IF (KEYG==2.AND.KUTCRP==1) THEN
                     MX=MX*4
                     MY=MY*4
                  END IF
               ELSEIF (DIST<=3.*CLNGTH) THEN
                  MX=MCX
                  MY=MCY
               ELSE
                  CLDST=SQRT(2.*CLNGTH/DIST)
                  MX=INT(FLOAT(MCX)*CLDST)
                  MY=INT(FLOAT(MCY)*CLDST)
               END IF
!
            END IF
!
            IF (MX<1) MX=1
            IF (MY<1) MY=1
!
!-- A step number of 3 may not be more accuarate than the 2
!   used for the four-point approach to surface integrations
!
            IF (MX==3) MX=2
            IF (MY==3) MY=2
!
            IF (MX>1) CMX=MX-1.
            IF (MY>1) CMY=MY-1.
!
!-- The four-point approach to the surface integration is
!   preserved from the previous work of Xiong et al (1986)
!
            DO I=1,MX
               IF (MX==1) THEN
                  X1=XSRS
                  CX=1.
               ELSEIF (MX==2) THEN
                  X1=XSRS+2.*(I-1.5)*.288675*CLXS
                  CX=.5
               ELSE
                  X1=XSRS-.5*CLXS+CLXS/CMX*(I-1.)
                  CX=1./CMX
                  IF (I==1.OR.I==MX) CX=.5*CX
               END IF
               DO J=1,MY
                  IF (MY==1) THEN
                     Y1=YSRS
                     CY=1.
                  ELSEIF (MY==2) THEN
                     Y1=YSRS+2.*(J-1.5)*.288675*CLYS
                     CY=.5
                  ELSE
                     Y1=YSRS-.5*CLYS+CLYS/CMY*(J-1.)
                     CY=1./CMY
                     IF (J==1.OR.J==MY) CY=.5*CY
                  END IF
!
                  C1=C2*CX*CY*CLXS*CLYS
!
                  RHO1=RHO(XOB,YOB,X1,Y1)
!
! ----- KHF together with keyg controls which gridding to be chosen
!     KHF=2: ordinary grid values; and
!        =1: a cylinder of radius blmin is excluded for treatment
!            of the singularities. See routine gridhf
!
!     Note this need only be done for outcropping cells.
!     for receivers on or within a cells deep in the earth
!     a cylinder of diameter blmin and height clz is excluded.
!     Here for outcropping cells the height of the cylinder is
!     blmin and the diameter is 2*blmin.   See
!     comments at the beginning of this routine.
!
                  IF (KEYG==2.AND.ABS(ZOB)<DMIN.AND.ABS(ZSR-.5*CLZ)  &
                      <DMIN.AND.RHO1<BLMIN) THEN
                     KHF=1
                  ELSE
                     KHF=2
                  END IF
!
! ----- If Rho < RHOMIN it should be assumed to be zero because the
!     Hankel transforms by digital linear filter are limited for
!     Rho >= RHOMIN
!
                  IF (RHO1>=RHOMIN) THEN
!****************************************************
!*                                                  *
!
                     IF (KEYG==1) THEN
                        NF=6
                     ELSE
                        NF=11
                     END IF
!
! --- khf controls which gridding to be chosen
!
!   Note three-point interpolation rules are used for
!   kacc <= 2 and five-point interpolation rules are
!   used for kacc>=3
!
                     IF (KHF==1) THEN
                        IF (KACC<=2)                                       &
                            CALL INTERPO_LG1(GRHF3,RRG3,NRG3,NHFILM,NZSR,  &
                                      ALOG(RHO1),ISR,HF,NF)
                        IF (KACC>=3)                                       &
                            CALL INTERPO_LG5(GRHF3,RRG3,NRG3,NHFILM,NZSR,  &
                                      ALOG(RHO1),ISR,HF,NF)
                     ELSE
                        IF (KACC<=2)                                       &
                            CALL INTERPO_LG(GRHF,RRG,NRG,NHFILM,NZSR,NZOB, &
                                     ALOG(RHO1),IOB,ISR,HF,NF)
                        IF (KACC>=3)                                        &
                            CALL INTERPO_LG4(GRHF,RRG,NRG,NHFILM,NZSR,NZOB, &
                                      ALOG(RHO1),IOB,ISR,HF,NF)
                     END IF
!
! ----- HF are now divided by rho
!
                     DO II=1,NF
                        HF(II)=HF(II)/RHO1
                     END DO
!
                     IF (KUTCRP==0) THEN
!
!-- Note that the correction done to HF(2) in the kernel
!   function, routine ONE_D_KERNEL,  will not affect this routine
!   since z and z' will never be zero.
!
                        EXX=EXX-C1*WMU*HF(1)-C1/CDH(NOB)               &
                            *(((XOB-X1)/RHO1)**2*HF(2)                 &
                            +(1.-2.*((XOB-X1)/RHO1)**2)/RHO1*HF(4))
                        EYX=EYX-C1/CDH(NOB)*(XOB-X1)*(YOB-Y1)          &
                            /RHO1**2*(HF(2)-2.*HF(4)/RHO1)
                        EYY=EYY-C1*WMU*HF(1)-C1/CDH(NOB)               &
                            *(((YOB-Y1)/RHO1)**2*HF(2)                 &
                            +(1.-2.*((YOB-Y1)/RHO1)**2)/RHO1*HF(4))
                        EXY=EYX
                        EZX=EZX-C1/CDH(NOB)*(XOB-X1)/RHO1*HF(5)
                        EZY=EZY-C1/CDH(NOB)*(YOB-Y1)/RHO1*HF(5)
                        EXZ=EXZ-C1/CDH(NOB)*(XOB-X1)/RHO1*HF(6)
                        EYZ=EYZ-C1/CDH(NOB)*(YOB-Y1)/RHO1*HF(6)
                        EZZ=EZZ+C1/CDH(NOB)*HF(3)
!
                     END IF
!
! ---  Compute magneti fields if KEYG=2
!
!    A cylinder of diameter blmin is removed if the receiver
!    is located on or within the cell
!
!    Note that outcropping cells has been considered by the
!    parameter KHF
!
                     IF (KEYG==2.AND.                                 &
                         .NOT.(KUTCRP==1.AND.ABS(ZOB)>=.1.AND.        &
                         ABS(ZSR-.5*CLZ)>=.1.AND.RHO1<=.5*BLMIN)) THEN
!
                        HXX=-C1*(XOB-X1)*(YOB-Y1)                     &
                            /RHO1**2*(HF(7)-2./RHO1*HF(9))+HXX
                        HYX=C1*HF(8)+C1*((XOB-X1)/RHO1)**2*HF(7)      &
                            +C1*(1.-2.*((XOB-X1)/RHO1)**2)/RHO1*HF(9) &
                            +HYX
                        HXY=-C1*HF(8)-C1*((YOB-Y1)/RHO1)**2*HF(7)     &
                            -C1*(1.-2.*((YOB-Y1)/RHO1)**2)/RHO1*HF(9) &
                            +HXY
                        HYY=-HXX
                        HZX=C1*(YOB-Y1)/RHO1*HF(10)+HZX
                        HZY=-C1*(XOB-X1)/RHO1*HF(10)+HZY
                        HXZ=-C1*(YOB-Y1)/RHO1*HF(11)+HXZ
                        HYZ=C1*(XOB-X1)/RHO1*HF(11)+HYZ
                        HZZ=(0.,0.)
                     END IF
!
!*                                                  *
!****************************************************
                  END IF
!
                  IF (RHO1<RHOMIN) THEN
!****************************************************
!*                                                  *
!
                     DO II=1,KEYG+1
                        IF (KEYG==2.AND.KHF==1) THEN
                           S(II)=GRHO03(II,ISR)
                        ELSE
                           S(II)=GRHO0(II,ISR,IOB)
                        END IF
                     END DO
!
                     IF (KUTCRP==0) THEN
                        S(1)=-C1/CDH(NOB)*S(1)
                        EXX=EXX+S(1)
                        EYY=EYY+S(1)
                        EZZ=EZZ-C1/CDH(NOB)*S(2)
                     END IF
!
                     IF (KEYG/=1.AND.KUTCRP/=1) THEN
                        HYX=C1*S(3)+HYX
                        HXY=-C1*S(3)+HXY
                     END IF
!
!*                                                  *
!****************************************************
                  END IF
!
               END DO
            END DO
         END DO
      END DO
!
!
! --- Assign the componenets to the arrays ECOMP and HCOMP
!   for data passing
!
      ECOMP(1)=EXX
      ECOMP(2)=EYX
      ECOMP(3)=EZX
      ECOMP(4)=EXY
      ECOMP(5)=EYY
      ECOMP(6)=EZY
      ECOMP(7)=EXZ
      ECOMP(8)=EYZ
      ECOMP(9)=EZZ
      IF (KEYG==2) THEN
         HCOMP(1)=HXX
         HCOMP(2)=HYX
         HCOMP(3)=HZX
         HCOMP(4)=HXY
         HCOMP(5)=HYY
         HCOMP(6)=HZY
         HCOMP(7)=HXZ
         HCOMP(8)=HYZ
         HCOMP(9)=HZZ
      END IF
!
      RETURN
      END
!
!**** End of THR_D_GREEN
!
!
      SUBROUTINE THR_D_VXYZ(CLX,CLY,CLZ,XSR,YSR,ZSR,XX,YY,ZZ)
!
!**** Six-point rule for numerical integration of a prismatic cube
!
! Input parameters:
!
!   CLX,CLY,CLZ:  Real,  dimension of the cell in the x, y,
!                 and z direction;  and
!   XSR,YSR,ZSR:  Real,  center coordinates of the cell in
!                 the x, y and z-direction.
!
! Output parameters:
!
!   XX, YY, ZZ:   Real XX(6), YY(6), ZZ(6),  the six sampling
!                 points for numerical volume integration.
!
!**** Called by:  THR_D_GEPRM, THR_D_GHPRM
!
!**** Calls:      None
!
!
      IMPLICIT NONE
!
      INTEGER I
      REAL SIGN
      REAL  CLX,CLY,CLZ,XSR,YSR,ZSR,XX(6),YY(6),ZZ(6)
!
      DO I=1,4
         XX(2+I)=XSR
         ZZ(I)=ZSR
      END DO
      DO I=1,2
         YY(I)=YSR
         YY(4+I)=YSR
         SIGN=2.*(I-1.5)
         XX(I)=XSR+SIGN*CLX/2.
         YY(2+I)=YSR+SIGN*CLY/2.
         ZZ(4+I)=ZSR+SIGN*CLZ/2.
      END DO
!
      RETURN
      END
!
!**** End of THR_D_VXYZ
!
!
      SUBROUTINE THR_D_GEPRM(PSTION,KACC,KSELF,CLREF,MXINT,MYINT,MZINT,   &
                             CLX,CLY,CLZ,FRQ,CDH,HVK,DMIN,GAX,ECOMP)
!
!**** Integration of the primary e-fields of the tensor green's function
!
!
! Input parameters:
!
!   KACC:   Integer,  accuracy level of computation.  KACC=1, 2
!           3, 4, or 5.  KACC controls the accuracy of the
!           numerical integration of the Green's functions
!           with increasing number of steps as KACC increases.
!           The higher the level,  the more accurate at the
!           cost of computation time.  A 2 or 3 is usually
!           adequate.  For high contrast models us 3 or 4.
!           KACC=5 should be used only for serious convergence
!           tests purpose.  See documentation "MARCO.DOC" for
!           more details.
!   KSELF:  Integer,  parameter controlling whether computations
!           for self-cells should be done.  This parameter is
!           determined in routines forming the scattering matrix.
!           Primary contributions of self-cells (fields due to
!           the cell at it's own cell center) are the same for
!           cells with the same dimensions in the same layer (
!           being treated as a whole space).  Since self-cells
!           are expensive to compute,  computing them only once
!           helps to reduce computation time.   Note that cells
!           must be arranged in certain order in order to avoid
!           fetching the wrong values for self-cells with different
!           dimensions.  Field values for a self-cell are stored
!           in the parameters EXX1,  EYX1, ..., EZZ1, and GAX1.
!           routine THR_D_GEPRM.  See THR_D_GEPRM for detail.
!   CLREF:  Real,  minimal dimension of the cell in consideration.
!           In routine THR_D_GREEN it is used as the reference
!           dimension for which the number of steps for numerical
!           integration is defined.  Actual number of steps in each
!           dimension depends on the ratio of that dimension to
!           CLREF.  Here and in the computation of the secondary
!           parts of the Green's tensors in routine THR_D_GREEN
!           CLREF is used as a reference to further dividing a
!           cell into subcells for more efficient and accurate
!           treatments of the numerical integrations.
!   MXINT:  Integer,  number of steps in the x-direction.
!   MYINT:  Integer,  number of steps in the y-direction.
!   MZINT:  Integer,  number of steps in the z-direction.
!   CLX:    Real,  dimension of the cell in the x-direction.
!   CLY:    Real,  dimension of the cell in the y-direction.
!   CLZ:    Real,  dimension of the cell in the z-direction.
!   FRQ:    Real(*4), frequency.
!   CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!           the layers including the air (layer 0).
!   HVK:    Real HVK(0:MLAYER),  coefficients of anisotropy of the layers
!           including the air (layer 0 with HVK(0)=1).  The anisotropy
!           coefficients are defined as the square roots of the ratios of
!           horizontal conductivities to vertical conductivities of each
!           layer.  Elements of HVK are always equal to or larger than 1.
!   DMIN:   Real,  minmum of dimension for numerical treatments of cells.
!           DMIN=0.1 for the low frequency mdule and DMIN=0.001 for the
!           high frequency module.
!
! Output parameters:
!
!   GAX:    Complex, the primay current term due to a selff-cell.
!   ECOMP:  Complex ECOMP(9),  the nine components of the electric
!           field tensor,  Exx, Eyx, Ezx, Exy, ..., and Ezz.  Note
!           that in parameters Exy etc. the first index "x" denotes
!           the direction of the field and the second index "y"
!           denotes the direction of the source.
!
!****  CALLED by: THR_D_GREEN
!
!****  CALLS    : THR_D_GASELF,  THR_D_VXYZ
!
!
      IMPLICIT NONE
!
      REAL B1,B2,B3,CLDST,CLNGTH,CLXS,CLYS,CLZS,CMX,CMY,CMZ,CX,CY,CZ,DIST, &
           HVK,R,R1,RA,RK,RR,RR1,RS,SCL,T2,T3,T4,X1,XI,XR,XSRS,Y1,YI,YR,   &
           YSRS,Z1,ZI,ZR,ZSRS
      INTEGER I,II,ISUB,J,J3,JJ,JSUB,KACC,KINT,KSELF,KSUB,L,MCX,MCY,MCZ,   &
              MM1,MM2,MM3,MSX,MSY,MSZ,MX,MXINT,MY,MYINT,MZ,MZINT
      REAL  DMIN,XOB,YOB,ZOB,XSR,YSR,ZSR,PSTION(6),          &
            CLX,CLY,CLZ,FRQ,CLREF,XX(6),YY(6),ZZ(6)
      COMPLEX CDH,K,WMU,CG,G1,G2,G3,G4,C2,C1,                &
              GX,GY,GZ,GZX,GZY,GAX,GAX1,D1,D2,D3,ECOMP(9),   &
              EXX,EXY,EXZ,EYX,EYY,EYZ,EZX,EZY,EZZ,           &
              EXX1,EXY1,EXZ1,EYX1,EYY1,EYZ1,EZX1,EZY1,EZZ1
      SAVE EXX1,EYX1,EZX1,EXY1,EYY1,EZY1,EXZ1,EYZ1,EZZ1,GAX1
!
      R(XR,YR,ZR,XI,YI,ZI)=SQRT((XR-XI)**2+(YR-YI)**2+(ZR-ZI)**2)
      RK(XR,YR,ZR,XI,YI,ZI)=SQRT((XR-XI)**2+(YR-YI)**2+(HVK*(ZR-ZI))**2)
      RR(XR,YR,XI,YI)=SQRT((XR-XI)**2+(YR-YI)**2)
!
      WMU=CMPLX(.0,78.9568352E-7*FRQ)
      K=CSQRT(WMU*CDH)
!
! --- Extract parameter values for XOB etc. from PSTION
!
      XOB=PSTION(1)
      YOB=PSTION(2)
      ZOB=PSTION(3)
      XSR=PSTION(4)
      YSR=PSTION(5)
      ZSR=PSTION(6)
!
      RS=R(XOB,YOB,ZOB,XSR,YSR,ZSR)
!
! ----- Compute a self-cell unless kself=1
!
      IF (KSELF/=1.AND.RS<DMIN) THEN
         EXX=EXX1
         EYX=EYX1
         EZX=EZX1
         EXY=EXY1
         EYY=EYY1
         EZY=EZY1
         EXZ=EXZ1
         EYZ=EYZ1
         EZZ=EZZ1
         GAX=GAX1
!
!**** Goto the end of the routine for return
!
         GOTO 100
!
      END IF
!
! ---- Divide the cell into subcells
!
!    Every subcell has a length of either 2*CLREF or 3*CLREF
!    in either direction, according to kacc.   For higher
!    kacc it is more efficient to have smaller subcell size.
!    But small subcell may increase waste for low kacc.
!
      IF (KACC<=3) THEN
         SCL=3.*CLREF
      ELSE
         SCL=2.*CLREF
      END IF
      MSX=INT(CLX/SCL)
      MSY=INT(CLY/SCL)
      MSZ=INT(CLZ/SCL)
!
!--- For the treatment of the singularity in the current term for
!    self-cells the subdivisions of cells should be in odd
!    numbers (the center subcell is approximated by a sphere or
!    spheroid).   This may also increase the accuracy of the
!    surface integrations for the charge terms a little bit.
!
      MSX=(MSX/2)*2+1
      MSY=(MSY/2)*2+1
      MSZ=(MSZ/2)*2+1
!
      IF (MSX<1) MSX=1
      IF (MSY<1) MSY=1
      IF (MSZ<1) MSZ=1
      MCX=MXINT/MSX
      MCY=MYINT/MSY
      MCZ=MZINT/MSZ
      CLXS=CLX/MSX
      CLYS=CLY/MSY
      CLZS=CLZ/MSZ
!
! ---- Compute the current terms by volumn integrations
!
      GX=(.0,.0)
      GZ=(.0,.0)
      GZX=(.0,.0)
      GZY=(.0,.0)
!
      DO ISUB=1,MSX
         IF (MSX==1) THEN
            XSRS=XSR
         ELSE
            XSRS=XSR+CLXS*(ISUB-1)-CLX/2.+.5*CLXS
         END IF
         DO JSUB=1,MSY
            IF (MSY==1) THEN
               YSRS=YSR
            ELSE
               YSRS=YSR+CLYS*(JSUB-1)-CLY/2.+.5*CLYS
            END IF
            DO KSUB=1,MSZ
               IF (MSZ==1) THEN
                  ZSRS=ZSR
               ELSE
                  ZSRS=ZSR+CLZS*(KSUB-1)-CLZ/2.+.5*CLZS
               END IF
!
!-- Determine the distance of the subcell to the receiver point
!   with respect to the dimension of the subcell.
!
               DIST=SQRT((RR(XOB,YOB,XSRS,YSRS))**2+(ZOB-ZSRS)**2)
               CLNGTH=SQRT(CLXS**2+CLYS**2+CLZS**2)
!
               IF (DIST<DMIN) THEN
!*****************************************************
!*                                                   *
!
!--- If DIST < DMIN it should be assumed to be zero for the sake
!    of numerical accuracy.
!
                  CALL THR_D_GASELF(CLXS,CLYS,CLZS,MCX,MCY,MCZ,CDH,HVK,K,  &
                                    DMIN,G1,G2)
                  GX=GX+G1
                  GZ=GZ+G2
!*                                                   *
!*****************************************************
               END IF
!
               IF (DIST>=DMIN) THEN
!
!*****************************************************
!*                                                   *
!
!-- Determine the numbers of steps according to the distance
!   between the source and the receiver.
!   Self-cells are considered in the above line.
!
!   See the comments on the choices of step numbers in the
!   routine THR_D_GREEN.
!
                  IF (DIST<=1.*CLNGTH) THEN
                     MX=MCX*3/2
                     MY=MCY*3/2
                     MZ=MCZ*3/2
                  ELSEIF (DIST<=3.*CLNGTH) THEN
                     MX=MCX
                     MY=MCY
                     MZ=MCZ
                  ELSE
                     CLDST=SQRT(2.*CLNGTH/DIST)
                     MX=INT(FLOAT(MCX)*CLDST)
                     MY=INT(FLOAT(MCY)*CLDST)
                     MZ=INT(FLOAT(MCZ)*CLDST)
                  END IF
!
!--- The current terms are more smooth than the charge terms
!    for low frequencies.  Hence the number of steps for the
!    numerical integrations can be reduced.
!
!    Tests have shown that the current terms can greatly
!    affect the final accuracies for frequencies above
!    100 Hz or so.   But for lower frequencies the following
!    reduction of MX etc. seems reasonable.
!
!--- Tests done by CRA, Australia indicate that the following
!    reduction in MX etc. introduce a few percent of errors
!    in the magnetic fields for frequency at 100 Hz, and that
!    the results show a jump at 100 Hz in a magnified scale.
!    Further tests showed that even the reduction for frequency
!    lower than 1 Hz there are appreciable instability at
!    later times in time domain solutions.  Thus the following
!    reduction in MX etc. is elimilated.
!
!       IF(FRQ<1.) THEN
!         MX=MX*2/3
!         MY=MY*2/3
!         MZ=MZ*2/3
!       END IF
!
                  IF (MX<1) MX=1
                  IF (MY<1) MY=1
                  IF (MZ<1) MZ=1
!
                  IF (MX>1) CMX=MX-1.
                  IF (MY>1) CMY=MY-1.
                  IF (MZ>1) CMZ=MZ-1.
!
                  C2=-WMU*CLXS*CLYS*CLZS
!
! --- The parameter kint controls if the six-point rule or the
!   multi-step trapezoidal rule should be used.
!   The six-point approach to the volume integration is perserved
!   from the previous work of Xiong et al (1986)
!
!   Step numbers less than or equal to 3 in either dimension
!   may not be more accuarate than the 6-point approach
!
                  IF (MX<=3.AND.MY<=3.AND.MZ<=3.AND.MX>1.AND.MY>1.AND.  &
                      MZ>1) THEN
                     KINT=1
                  ELSE
                     KINT=2
                  END IF
!
                  IF (KINT==1) THEN
                     CALL THR_D_VXYZ(CLXS,CLYS,CLZS,XSRS,YSRS,ZSRS,XX,YY,ZZ)
                     MM1=1
                     MM2=1
                     MM3=6
                  ELSE
                     MM1=MX
                     MM2=MY
                     MM3=MZ
                  END IF
!
                  DO I=1,MM1
                     IF (KINT==2.AND.MM1==1) THEN
                        X1=XSRS
                        CX=1.
                     END IF
                     IF (KINT==2.AND.MM1/=1) THEN
                        X1=XSRS-.5*CLXS+CLXS/CMX*(I-1.)
                        CX=1./CMX
                        IF (I==1.OR.I==MX) CX=.5*CX
                     END IF
                     DO J=1,MM2
                        IF (KINT==2.AND.MM2==1) THEN
                           Y1=YSRS
                           CY=1.
                        END IF
                        IF (KINT==2.AND.MM2/=1) THEN
                           Y1=YSRS-.5*CLYS+CLYS/CMY*(J-1.)
                           CY=1./CMY
                           IF (J==1.OR.J==MY) CY=.5*CY
                        END IF
                        DO J3=1,MM3
                           IF (KINT==2.AND.MM3==1) THEN
                              Z1=ZSRS
                              CZ=1.
                           ELSEIF (KINT==2.AND.MM3/=1) THEN
                              Z1=ZSRS-.5*CLZS+CLZS/CMZ*(J3-1.)
                              CZ=1./CMZ
                              IF (J3==1.OR.J3==MZ) CZ=.5*CZ
                           ELSE
                              X1=XX(J3)
                              Y1=YY(J3)
                              Z1=ZZ(J3)
                           END IF
!
                           IF (KINT==1) THEN
                              C1=C2/6.
                           ELSE
                              C1=C2*CX*CY*CZ
                           END IF
!
                           R1=R(XOB,YOB,ZOB,X1,Y1,Z1)
!
                           G1=.0795774771*EXP(-K*R1)/R1
                           GX=GX+G1*C1
                           IF (ABS(HVK-1.)<=.00001) THEN
                              GZ=GX
                              CYCLE
                           END IF
                           RR1=RR(XOB,YOB,X1,Y1)
                           RA=RK(XOB,YOB,ZOB,X1,Y1,Z1)
                           G2=.0795774771*HVK*EXP(-K*RA/HVK)/RA
                           GZ=GZ+G2*C1
                           IF (RR1<=.001) THEN
                              G3=(.0,.0)
                           ELSE
                              G3=(ZOB-Z1)/RR1**2*(G1-G2)
                           END IF
                           GZX=GZX+(XOB-X1)*G3*C1
                           GZY=GZY+(YOB-Y1)*G3*C1
                        END DO
                     END DO
                  END DO
!
!*                                                   *
!*****************************************************
               END IF
!
            END DO
         END DO
      END DO
!
      GY=GX
      IF (ABS(HVK-1.)<=.00001) GZ=GX
      GAX=GX
!
! ---- Compute the charge terms by surface integrations
!
      C2=.0795774771/CDH
      T2=.288675*CLXS
      T3=.288675*CLYS
      T4=.288675*CLZS
!
      DO L=1,3,2
!
         D1=(.0,.0)
         D2=(.0,.0)
         D3=(.0,.0)
         X1=XSR-(FLOAT(L)-2.)*CLX*.5
!
!-- Note that the coordinates in the x-direction are fixed
!   and cells are divided only in the y and z directions
!
         DO JSUB=1,MSY
            IF (MSY==1) THEN
               YSRS=YSR
            ELSE
               YSRS=YSR+CLYS*(JSUB-1)-CLY/2.+.5*CLYS
            END IF
            DO KSUB=1,MSZ
               IF (MSZ==1) THEN
                  ZSRS=ZSR
               ELSE
                  ZSRS=ZSR+CLZS*(KSUB-1)-CLZ/2.+.5*CLZS
               END IF
!
!-- Determine the distance of the subcell surface over which the
!   integration is to be done to the receiver point with
!   respect to the dimension of the subcell surface.
!
               DIST=SQRT((RR(XOB,YOB,X1,YSRS))**2+(ZOB-ZSRS)**2)
               CLNGTH=SQRT(CLYS**2+CLZS**2)
!
!-- Determine the numbers of steps according to the distance
!   between the source and the receiver
!
!   See the comments on the choices of step numbers in the
!   routine THR_D_GREEN.
!
!   Since the distance of the actual surface of integration
!   to the receiver point is used, DIST may never be zero in
!   forming the scattering matrix.
!
               IF (DIST<=1.*CLNGTH) THEN
                  MY=MCY*3/2
                  MZ=MCZ*3/2
               ELSEIF (DIST<=3.*CLNGTH) THEN
                  MY=MCY
                  MZ=MCZ
               ELSE
                  CLDST=SQRT(2.*CLNGTH/DIST)
                  MY=INT(FLOAT(MCY)*CLDST)
                  MZ=INT(FLOAT(MCZ)*CLDST)
               END IF
!
               IF (MY<1) MY=1
               IF (MZ<1) MZ=1
!
!-- A step number of 3 may not be more accuarate than the 2
!   used for the four-point approach to surface integrations
!
               IF (MY==3) MY=2
               IF (MZ==3) MZ=2
!
               IF (MY>1) CMY=MY-1.
               IF (MZ>1) CMZ=MZ-1.
!
!-- The four-point approach to the surface integration is preserved
!   from Xiong et al (1986)
!
               DO II=1,MY
                  IF (MY==1) THEN
                     Y1=YSRS
                     CY=1.
                  ELSEIF (MY==2) THEN
                     Y1=YSRS+2.*(II-1.5)*T3
                     CY=.5
                  ELSE
                     Y1=YSRS-.5*CLYS+CLYS/CMY*(II-1.)
                     CY=1./CMY
                     IF (II==1.OR.II==MY) CY=.5*CY
                  END IF
                  DO JJ=1,MZ
                     IF (MZ==1) THEN
                        Z1=ZSRS
                        CZ=1.
                     ELSEIF (MZ==2) THEN
                        Z1=ZSRS+2.*(JJ-1.5)*T4
                        CZ=.5
                     ELSE
                        Z1=ZSRS-.5*CLZS+CLZS/CMZ*(JJ-1.)
                        CZ=1./CMZ
                        IF (JJ==1.OR.JJ==MZ) CZ=.5*CZ
                     END IF
                     C1=C2*CY*CZ*CLYS*CLZS
!
                     R1=R(XOB,YOB,ZOB,X1,Y1,Z1)
!
                     CG=K*R1
                     G3=C1*((1.,0.)+CG)*EXP(-CG)/R1/R1/R1
                     B1=XOB-X1
                     D1=D1+B1*G3
                     B2=YOB-Y1
                     D2=D2+B2*G3
                     IF (ABS(HVK-1.)>=.0001) THEN
                        RA=RK(XOB,YOB,ZOB,X1,Y1,Z1)/HVK
                        CG=K*RA
                        G4=C1*((1.,0.)+CG)*EXP(-CG)/RA/RA/RA
                        RR1=RR(XOB,YOB,X1,Y1)
! ----  The limit values of the anisotropic terms for rho = 0
!     have yet to be strictly determined. Here they are assumed
!     to be zero for simplicity.
                        IF (RR1>=DMIN) THEN
                           G1=C1*EXP(-K*R1)/R1
                           G2=C1*EXP(-K*RA)/RA
                           B3=ZOB-Z1
                           CG=(G2-G1+B3**2*(G3-G4))/RR1**2
                           D1=D1+B1*CG
                           D2=D2+B2*CG
                        END IF
                        G3=G4
                     END IF
                     B3=ZOB-Z1
                     D3=D3+B3*G3
                  END DO
               END DO
            END DO
         END DO
         IF (L==1) THEN
            EXX=D1
            EXY=D2
            EXZ=D3
         ELSE
            EXX=EXX-D1
            EXY=EXY-D2
            EXZ=EXZ-D3
         END IF
!
      END DO
!
      DO L=1,3,2
!
         D1=(.0,.0)
         D2=(.0,.0)
         D3=(.0,.0)
         Y1=YSR-(FLOAT(L)-2.)*CLY*.5
!
!-- Note that the coordinates in the y-direction are fixed
!   and cells are divided only in the x and z directions
!
         DO ISUB=1,MSX
            IF (MSX==1) THEN
               XSRS=XSR
            ELSE
               XSRS=XSR+CLXS*(ISUB-1)-CLX/2.+.5*CLXS
            END IF
            DO KSUB=1,MSZ
               IF (MSZ==1) THEN
                  ZSRS=ZSR
               ELSE
                  ZSRS=ZSR+CLZS*(KSUB-1)-CLZ/2.+.5*CLZS
               END IF
!
!-- Determine the distance of the subcell surface over which the
!   integration is to be done to the receiver point with
!   respect to the dimension of the subcell surface.
!
               DIST=SQRT((RR(XOB,YOB,XSRS,Y1))**2+(ZOB-ZSRS)**2)
               CLNGTH=SQRT(CLXS**2+CLZS**2)
!
!-- Determine the numbers of steps according to the distance
!   between the source and the receiver
!
               IF (DIST<=1.*CLNGTH) THEN
                  MX=MCX*3/2
                  MZ=MCZ*3/2
               ELSEIF (DIST<=3.*CLNGTH) THEN
                  MX=MCX
                  MZ=MCZ
               ELSE
                  CLDST=SQRT(2.*CLNGTH/DIST)
                  MX=INT(FLOAT(MCX)*CLDST)
                  MZ=INT(FLOAT(MCZ)*CLDST)
               END IF
!
               IF (MX<1) MX=1
               IF (MZ<1) MZ=1
!
               IF (MX==3) MX=2
               IF (MZ==3) MZ=2
!
               IF (MX>1) CMX=MX-1.
               IF (MZ>1) CMZ=MZ-1.
!
               DO II=1,MX
                  IF (MX==1) THEN
                     X1=XSRS
                     CX=1.                               !^^^^^^^^^^^^APR fix 28 June, 2001
                  ELSEIF (MX==2) THEN
                     X1=XSRS+2.*(II-1.5)*T2
                     CX=.5
                  ELSE
                     X1=XSRS-.5*CLXS+CLXS/CMX*(II-1.)
                     CX=1./CMX
                     IF (II==1.OR.II==MX) CX=.5*CX
                  END IF
                  DO JJ=1,MZ
                     IF (MZ==1) THEN
                        Z1=ZSRS
                        CZ=1.
                     ELSEIF (MZ==2) THEN
                        Z1=ZSRS+2.*(JJ-1.5)*T4
                        CZ=.5
                     ELSE
                        Z1=ZSRS-.5*CLZS+CLZS/CMZ*(JJ-1.)
                        CZ=1./CMZ
                        IF (JJ==1.OR.JJ==MZ) CZ=.5*CZ
                     END IF
                     C1=C2*CX*CZ*CLXS*CLZS
!
                     R1=R(XOB,YOB,ZOB,X1,Y1,Z1)
!
                     CG=K*R1
                     G3=C1*((1.,0.)+CG)*EXP(-CG)/R1/R1/R1
                     B1=XOB-X1
                     D1=D1+B1*G3
                     B2=YOB-Y1
                     D2=D2+B2*G3
                     IF (ABS(HVK-1.)>=.0001) THEN
                        RA=RK(XOB,YOB,ZOB,X1,Y1,Z1)/HVK
                        CG=K*RA
                        G4=C1*((1.,0.)+CG)*EXP(-CG)/RA/RA/RA
                        RR1=RR(XOB,YOB,X1,Y1)
! ----  The limit values of the anisotropic terms for rho = 0
!     have yet to be strictly determined. Here they are assumed
!     to be zero for simplicity.
                        IF (RR1>=DMIN) THEN
                           G1=C1*EXP(-K*R1)/R1
                           G2=C1*EXP(-K*RA)/RA
                           B3=ZOB-Z1
                           CG=(G2-G1+B3**2*(G3-G4))/RR1**2
                           D1=D1+B1*CG
                           D2=D2+B2*CG
                        END IF
                        G3=G4
                     END IF
                     B3=ZOB-Z1
                     D3=D3+B3*G3
                  END DO
               END DO
            END DO
         END DO
         IF (L==1) THEN
            EYX=D1
            EYY=D2
            EYZ=D3
         ELSE
            EYX=EYX-D1
            EYY=EYY-D2
            EYZ=EYZ-D3
         END IF
!
      END DO
!
      DO L=1,3,2
         D1=(.0,.0)
         D2=(.0,.0)
         D3=(.0,.0)
         Z1=ZSR-(FLOAT(L)-2.)*CLZ*.5
!
!-- Note that the coordinates in the z-direction are fixed
!   and cells are divided only in the x and y directions
!
         DO ISUB=1,MSX
            IF (MSX==1) THEN
               XSRS=XSR
            ELSE
               XSRS=XSR+CLXS*(ISUB-1)-CLX/2.+.5*CLXS
            END IF
            DO JSUB=1,MSY
               IF (MSY==1) THEN
                  YSRS=YSR
               ELSE
                  YSRS=YSR+CLYS*(JSUB-1)-CLY/2.+.5*CLYS
               END IF
!
!-- Determine the distance of the subcell surface over which the
!   integration is to be done to the receiver point with
!   respect to the dimension of the subcell surface.
!
               DIST=SQRT((RR(XOB,YOB,XSRS,YSRS))**2+(ZOB-Z1)**2)
               CLNGTH=SQRT(CLXS**2+CLYS**2)
!
!-- Determine the numbers of steps according to the distance
!   between the source and the receiver
!
               IF (DIST<=1.*CLNGTH) THEN
                  MX=MCX*3/2
                  MY=MCY*3/2
               ELSEIF (DIST<=3.*CLNGTH) THEN
                  MX=MCX
                  MY=MCY
               ELSE
                  CLDST=SQRT(2.*CLNGTH/DIST)
                  MX=INT(FLOAT(MCX)*CLDST)
                  MY=INT(FLOAT(MCY)*CLDST)
               END IF
!
               IF (MX<1) MX=1
               IF (MY<1) MY=1
!
               IF (MX==3) MX=2
               IF (MY==3) MY=2
!
               IF (MX>1) CMX=MX-1.
               IF (MY>1) CMY=MY-1.
!
               DO II=1,MX
                  IF (MX==1) THEN
                     X1=XSRS
                     CX=1.
                  ELSEIF (MX==2) THEN
                     X1=XSRS+2.*(II-1.5)*T2
                     CX=.5
                  ELSE
                     X1=XSRS-.5*CLXS+CLXS/CMX*(II-1.)
                     CX=1./CMX
                     IF (II==1.OR.II==MX) CX=.5*CX
                  END IF
                  DO JJ=1,MY
                     IF (MY==1) THEN
                        Y1=YSRS
                        CY=1.
                     ELSEIF (MY==2) THEN
                        Y1=YSRS+2.*(JJ-1.5)*T3
                        CY=.5
                     ELSE
                        Y1=YSRS-.5*CLYS+CLYS/CMY*(JJ-1.)
                        CY=1./CMY
                        IF (JJ==1.OR.JJ==MY) CY=.5*CY
                     END IF
                     C1=C2*CX*CY*CLXS*CLYS
!
                     R1=R(XOB,YOB,ZOB,X1,Y1,Z1)
!
                     CG=K*R1
                     G3=C1*((1.,0.)+CG)*EXP(-CG)/R1/R1/R1
                     B1=XOB-X1
                     D1=D1+B1*G3
                     B2=YOB-Y1
                     D2=D2+B2*G3
                     IF (ABS(HVK-1.)>=.0001) THEN
                        RA=RK(XOB,YOB,ZOB,X1,Y1,Z1)/HVK
                        CG=K*RA
                        G4=C1*((1.,0.)+CG)*EXP(-CG)/RA/RA/RA
                        RR1=RR(XOB,YOB,X1,Y1)
! ---- The limit values of the anisotropic terms for rho = 0
!    have yet to be strictly determined. Here they are assumed
!    to be zero for simplicity.
                        IF (RR1>=DMIN) THEN
                           G1=C1*EXP(-K*R1)/R1
                           G2=C1*EXP(-K*RA)/RA
                           B3=ZOB-Z1
                           CG=(G2-G1+B3**2*(G3-G4))/RR1**2
                           D1=D1+B1*CG
                           D2=D2+B2*CG
                        END IF
                        G3=G4
                     END IF
                     B3=ZOB-Z1
                     D3=D3+B3*G3
                  END DO
               END DO
            END DO
         END DO
         IF (L==1) THEN
            EZX=D1
            EZY=D2
            EZZ=D3
         ELSE
            EZX=EZX-D1
            EZY=EZY-D2
            EZZ=EZZ-D3
         END IF
!
      END DO
!
      EXX=EXX+GX
      EYY=EYY+GY
      EZX=EZX+GZX
      EZY=EZY+GZY
      EZZ=EZZ+GZ
!
! ----- Store the values for a self cell upon computation
!
      IF (KSELF==1.AND.RS<DMIN) THEN
         EXX1=EXX
         EYX1=EYX
         EZX1=EZX
         EXY1=EXY
         EYY1=EYY
         EZY1=EZY
         EXZ1=EXZ
         EYZ1=EYZ
         EZZ1=EZZ
         GAX1=GAX
      END IF
!
! --- Assign the componenets to the arrays ECOMP and HCOMP
!   for data passing
!
!**** Entry point for goto 500
!
  100 ECOMP(1)=EXX
      ECOMP(2)=EYX
      ECOMP(3)=EZX
      ECOMP(4)=EXY
      ECOMP(5)=EYY
      ECOMP(6)=EZY
      ECOMP(7)=EXZ
      ECOMP(8)=EYZ
      ECOMP(9)=EZZ
!
      RETURN
      END
!
!**** End of THR_D_GEPRM
!
!
      SUBROUTINE THR_D_GASELF(CLX,CLY,CLZ,MXINT,MYINT,MZINT,   &
                              CDH,HVK,K,DMIN,GX,GZ)
!
!****  Integration of the current term for a self-cell
!
!   The prism cell is divided into 27 subcells with the one
!   in the center being a cube for the approximation by a sphere.
!   Of the 27 subcells either 18 or 24 have zero size.
!
!
! Input parameters:
!
!   CLX:    Real,  dimension of the cell in the x-direction.
!   CLY:    Real,  dimension of the cell in the y-direction.
!   CLZ:    Real,  dimension of the cell in the z-direction.
!   MXINT:  Integer,  number of steps in the x-direction.
!   MYINT:  Integer,  number of steps in the y-direction.
!   MZINT:  Integer,  number of steps in the z-direction.
!   CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!           the layers including the air (layer 0).
!   HVK:    Real HVK(0:MLAYER),  the coefficients of anisotropy of the layers
!           including the air (layer 0 with HVK(0)=1).  The anisotropy
!           coefficients are defined as the square roots of the ratios of
!           horizontal conductivities to vertical conductivities of each
!           layer.  Elements of HVK are always equal to or larger than 1.
!   K:      Complex,  wave number of the layer which is considered as
!           a whole space for primary parts.
!   DMIN:   Real,  minmum of dimension for numerical treatments of cells.
!           DMIN=0.1 for the low frequency mdule and DMIN=0.001 for the
!           high frequency module.
!
! Output parameters:
!
!   GX:     Complex, the x- (and y-) component of the primay current
!           term due to the selff-cell.
!   GZ:     Complex, the z- component of the primay current term due
!           to the selff-cell.  It differs from GX if the medium is
!           anisotropic.
!
!
!**** Called by:  THR_D_GEPRM
!
!**** Calls:      THR_D_G12
!
!
      IMPLICIT NONE
!
      REAL CLX,CLY,CLZ,CMX,CMY,CMZ,CX,CY,CZ,HVK,R,R1,RA,RK,SL,X1,XI,XR,   &
           Y1,YI,YR,Z1,ZI,ZR
      INTEGER I,II,J,JJ,L,LL,MX,MXINT,MY,MYINT,MZ,MZINT
      COMPLEX GX,GZ,G1,G2,K,CDH,C1,C2
      REAL  DMIN,X(3),Y(3),Z(3),XL(3),YL(3),ZL(3)
!
      R(XR,YR,ZR,XI,YI,ZI)=SQRT((XR-XI)**2+(YR-YI)**2+(ZR-ZI)**2)
      RK(XR,YR,ZR,XI,YI,ZI)=SQRT((XR-XI)**2+(YR-YI)**2+(HVK*(ZR-ZI))**2)
!
      SL=AMIN1(CLX,CLY,CLZ)
      XL(1)=(CLX-SL)/2.
      XL(2)=SL
      XL(3)=(CLX-SL)/2.
      YL(1)=(CLY-SL)/2.
      YL(2)=SL
      YL(3)=(CLY-SL)/2.
      ZL(1)=(CLZ-SL)/2.
      ZL(2)=SL
      ZL(3)=(CLZ-SL)/2.
      X(1)=-(SL/2.+XL(1)/2.)
      X(2)=0.
      X(3)=(SL/2.+XL(3)/2.)
      Y(1)=-(SL/2.+YL(1)/2.)
      Y(2)=0.
      Y(3)=(SL/2.+YL(3)/2.)
      Z(1)=-(SL/2.+ZL(1)/2.)
      Z(2)=0.
      Z(3)=(SL/2.+ZL(3)/2.)
!
      GX=(.0,.0)
      GZ=(.0,.0)
!
      DO I=1,3
         DO J=1,3
            DO L=1,3
!
!**** Skip the center cell and cells with a zero dimension
!
               IF (.NOT.(I==2.AND.J==2.AND.L==2.OR.ABS(XL(I))<=DMIN.OR.  &
                   ABS(YL(J))<=DMIN.OR.ABS(ZL(L))<=DMIN)) THEN
!
                  C2=-K**2/CDH*XL(I)*YL(J)*ZL(L)
!
                  MX=INT(FLOAT(MXINT)*(XL(I)/CLX))
                  IF (MX<1) MX=1
                  MY=INT(FLOAT(MYINT)*(YL(J)/CLY))
                  IF (MY<1) MY=1
                  MZ=INT(FLOAT(MZINT)*(ZL(L)/CLZ))
                  IF (MZ<1) MZ=1
!
                  IF (MX>1) THEN
                     CMX=MX-1.
                  ELSE
                     CMX=1.
                  END IF
                  IF (MY>1) THEN
                     CMY=MY-1.
                  ELSE
                     CMY=1.
                  END IF
                  IF (MZ>1) THEN
                     CMZ=MZ-1.
                  ELSE
                     CMZ=1.
                  END IF
!
                  DO II=1,MX
                     X1=X(I)-.5*XL(I)+XL(I)/CMX*(II-1.)
                     IF (MX>1) THEN
                        CX=1./CMX
                     ELSE
                        CX=1.
                     END IF
                     IF (II==1.OR.II==MX) CX=.5*CX
                     IF (MX==1) CX=1.
                     DO JJ=1,MY
                        Y1=Y(J)-.5*YL(J)+YL(J)/CMY*(JJ-1.)
                        IF (MY>1) THEN
                           CY=1./CMY
                        ELSE
                           CY=1.
                        END IF
                        IF (JJ==1.OR.JJ==MY) CY=.5*CY
                        IF (MY==1) CY=1.
                        DO LL=1,MZ
                           Z1=Z(L)-.5*ZL(L)+ZL(L)/CMZ*(LL-1.)
                           IF (MZ>1) THEN
                              CZ=1./CMZ
                           ELSE
                              CZ=1.
                           END IF
                           IF (LL==1.OR.LL==MZ) CZ=.5*CZ
                           IF (MZ==1) CZ=1.
                           C1=C2*CX*CY*CZ
!
                           R1=R(0.,0.,0.,X1,Y1,Z1)
                           G1=.0795774771*EXP(-K*R1)/R1
                           GX=GX+G1*C1
                           IF (ABS(HVK-1.)>.0001) THEN
                              RA=RK(0.,0.,0.,X1,Y1,Z1)
                              G2=.0795774771*HVK*EXP(-K*RA/HVK)/RA
                              GZ=GZ+G2*C1
                           END IF
!
                        END DO
                     END DO
                  END DO
               END IF
!
            END DO
         END DO
      END DO
      IF (ABS(HVK-1.)<=.0001) GZ=GX
      CALL THR_D_G12(SL,SL,SL,CDH,HVK,K,G1,G2)
      GX=GX+G1
      GZ=GZ+G2
!
      RETURN
      END
!
!**** End of THR_D_GASELF
!
!
      SUBROUTINE THR_D_G12(CLX,CLY,CLZ,CDH,HVK,K,G1,G2)
!
!**** Approximate the volumn integration of the primary current term
!   due to a self-cell by the analytical solution for a sphere.
!
!
! Input parameters:
!
!   CLX:    Real,  dimension of the cell in the x-direction.
!   CLY:    Real,  dimension of the cell in the y-direction.
!   CLZ:    Real,  dimension of the cell in the z-direction.
!   CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!           the layers including the air (layer 0).
!   HVK:    Real HVK(0:MLAYER),  the coefficients of anisotropy of the layers
!           including the air (layer 0 with HVK(0)=1).  The anisotropy
!           coefficients are defined as the square roots of the ratios of
!           horizontal conductivities to vertical conductivities of each
!           layer.  Elements of HVK are always equal to or larger than 1.
!   K:      Complex,  wave number of the layer which is considered as
!           a whole space for primary parts.
!
! Output parameters:
!
!   G1:     Complex, the x- (and y-) component of the primay current
!           term due to the selff-cell approximated by a sphere.
!   G2:     Complex, the z- component of the primay current term due
!           to the selff-cell approximated by a sphere.  It differs
!           from GX if the medium is anisotropic.
!
!
!**** Called by:  THR_D_GASELF
!
!**** Calls:      None
!
!
      IMPLICIT NONE
!
      REAL AV,AVK,CLX,CLY,CLZ,HVK,VOLUME
      COMPLEX G1,G2,K,CDH
      VOLUME=CLX*CLY*CLZ
      AV=.6207505*VOLUME**.33333333
      AVK=AV*HVK**.33333333
      G1=(EXP(-K*AV)*(K*AV+(1.,0.))-(1.,0.))/CDH
      IF (ABS(HVK-1.)<.0001) THEN
         G2=G1
      ELSE
         G2=HVK*HVK*(EXP(-K*AVK/HVK)*(K*AVK/HVK+(1.,0.))-(1.,0.))/CDH
      END IF
!
      RETURN
      END
!
!**** End of THR_D_G12
!
!
      SUBROUTINE THR_D_GHPRM(PSTION,KACC,BLMIN,CLREF,MXINT,MYINT,MZINT,   &
                             CLX,CLY,CLZ,FRQ,CDH,HVK,DMIN,HCOMP)
!
!****  Primary parts of the magnetic Green's function
!
!    Fields are integrated in a prismatic cell using the multistep
!    trapezoidal rules.
!
!
! Input parameters:
!
!   KACC:   Integer,  accuracy level of computation.  KACC=1, 2
!           3, 4, or 5.  KACC controls the accuracy of the
!           numerical integration of the Green's functions
!           with increasing number of steps as KACC increases.
!           The higher the level,  the more accurate at the
!           cost of computation time.  A 2 or 3 is usually
!           adequate.  For high contrast models us 3 or 4.
!           KACC=5 should be used only for serious convergence
!           tests purpose.  See documentation "MARCO.DOC" for
!           more details.
!   BLMIN:  Real,  redius and height of a cylinder to be removed
!           from computation for the treatment of singularity
!           arising in the computation of magnetic fields due to
!           an outcropping cell.  See description for KUTCRP
!           in the following for more details.
!   CLREF:  Real,  minimal dimension of the cell in consideration.
!           In routine THR_D_GREEN it is used as the reference
!           dimension for which the number of steps for numerical
!           integration is defined.  Actual number of steps in each
!           dimension depends on the ratio of that dimension to
!           CLREF.  Here and in the computation of the secondary
!           parts of the Green's tensors in routine THR_D_GREEN
!           CLREF is used as a reference to further dividing a
!           cell into subcells for more efficient and accurate
!           treatments of the numerical integrations.
!   MXINT:  Integer,  number of steps in the x-direction.
!   MYINT:  Integer,  number of steps in the y-direction.
!   MZINT:  Integer,  number of steps in the z-direction.
!   CLX:    Real,  dimension of the cell in the x-direction.
!   CLY:    Real,  dimension of the cell in the y-direction.
!   CLZ:    Real,  dimension of the cell in the z-direction.
!   FRQ:    Real(*4), frequency.
!   CDH:    Complex CDH(0:MLAYER),  complex conductivities of
!           the layers including the air (layer 0).
!   HVK:    Real HVK(0:MLAYER),  coefficients of anisotropy of the layers
!           including the air (layer 0 with HVK(0)=1).  The anisotropy
!           coefficients are defined as the square roots of the ratios of
!           horizontal conductivities to vertical conductivities of each
!           layer.  Elements of HVK are always equal to or larger than 1.
!   DMIN:   Real,  minmum of dimension for numerical treatments of cells.
!           DMIN=0.1 for the low frequency mdule and DMIN=0.001 for the
!           high frequency module.
!
! Output parameters:
!
!   HCOMP:  Complex HCOMP(9),  the nine components of the electric
!           field tensor,  Hxx, Hyx, Hzx, Hxy, ..., and Hzz.  Note that
!           in parameters Hxy etc. the first index "x" denotes the
!           direction of the field and the second index "y" denotes
!           the direction of the source.
!
!Remarks:
!
!    This routine is mainly used for eliminating the singularities
!    in the numnerical integrations of the magnetic Green's functions.
!
!    Tests have shown that this routine is not accurate in treating
!    the sigularty in sea water environments.  There could be still
!    hidden error in the code.   This routine will never be called
!    due to the changes made lately in the routines THR_D_GREEN and
!    gridhf on the parameter kghp.
!    (***!!! may need double precisions !!!***)
!
!
      IMPLICIT NONE
!
      REAL BLMIN,C1,C2,C3,CC,CLDST,CLNGTH,CLXS,CLYS,CLZS,CMX,CMY,CMZ,CX,  &
           CY,CZ,DIST,HVK,R,R1,RA,RHO,RK,RR,SCL,X1,XI,XR,XSRS,Y1,YI,YR,   &
           YSRS,Z1,ZI,ZR,ZSRS
      INTEGER I,ISUB,J,J3,JSUB,KACC,KINT,KSUB,MCX,MCY,MCZ,MM1,MM2,MM3,    &
              MSX,MSY,MSZ,MX,MXINT,MY,MYINT,MZ,MZINT
      REAL  DMIN,XOB,YOB,ZOB,XSR,YSR,ZSR,PSTION(6),                       &
            CLX,CLY,CLZ,FRQ,CLREF,XX(6),YY(6),ZZ(6)
      COMPLEX CDH,K,EKR,EKRA,E1,E2,HCOMP(9),                &
              HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ
!
      R(XR,YR,ZR,XI,YI,ZI)=SQRT((XR-XI)**2+(YR-YI)**2+(ZR-ZI)**2)
      RK(XR,YR,ZR,XI,YI,ZI)=SQRT((XR-XI)**2+(YR-YI)**2+(HVK*(ZR-ZI))**2)
      RR(XR,YR,XI,YI)=SQRT((XR-XI)**2+(YR-YI)**2)
!
! --- Extract parameter values for XOB etc. from PSTION
!
      XOB=PSTION(1)
      YOB=PSTION(2)
      ZOB=PSTION(3)
      XSR=PSTION(4)
      YSR=PSTION(5)
      ZSR=PSTION(6)
!
      CC=1./4./3.1415926*CLX*CLY*CLZ
      K=CSQRT(CMPLX(.0,78.9568352E-7*FRQ)*CDH)
      HXX=(0.,0.)
      HYX=(0.,0.)
      HZX=(0.,0.)
      HXY=(0.,0.)
!    HYY=(0.,0.)
      HZY=(0.,0.)
      HXZ=(0.,0.)
      HYZ=(0.,0.)
!
! ---- Divide the cell into subcells
!
!    Every subcell has a length of either 2*CLREF or 3*CLREF
!    in either direction, according to kacc.   For higher
!    kacc it is more efficient to have smaller subcell size.
!    But small subcell may increase waste for low kacc.
!
      IF (KACC<=3) THEN
         SCL=3.*CLREF
      ELSE
         SCL=2.*CLREF
      END IF
      MSX=INT(CLX/SCL)
      MSY=INT(CLY/SCL)
      MSZ=INT(CLZ/SCL)
      IF (MSX<1) MSX=1
      IF (MSY<1) MSY=1
      IF (MSZ<1) MSZ=1
      MCX=MXINT/MSX
      MCY=MYINT/MSY
      MCZ=MZINT/MSZ
      CLXS=CLX/MSX
      CLYS=CLY/MSY
      CLZS=CLZ/MSZ
!
!--- The magnetic Green's functions are more smooth than the
!    charge terms of the electric Green's function.
!    Hence the knots for numerical integration can be reduced
!
      MCX=MCX*2/3
      MCY=MCY*2/3
      MCZ=MCZ*2/3
!
      DO ISUB=1,MSX
         IF (MSX==1) THEN
            XSRS=XSR
         ELSE
            XSRS=XSR+CLXS*(ISUB-1)-CLX/2.+.5*CLXS
         END IF
         DO JSUB=1,MSY
            IF (MSY==1) THEN
               YSRS=YSR
            ELSE
               YSRS=YSR+CLYS*(JSUB-1)-CLY/2.+.5*CLYS
            END IF
            DO KSUB=1,MSZ
               IF (MSZ==1) THEN
                  ZSRS=ZSR
               ELSE
                  ZSRS=ZSR+CLZS*(KSUB-1)-CLZ/2.+.5*CLZS
               END IF
!
!-- Determine the distance of the subcell to the receiver point
!   with respect to the dimension of the subcell.
!
               DIST=SQRT((RR(XOB,YOB,XSRS,YSRS))**2+(ZOB-ZSRS)**2)
               CLNGTH=SQRT(CLXS**2+CLYS**2+CLZS**2)
!
!-- Determine the numbers of steps according to the distance
!   between the source and the receiver
!
!   See the comments on the choices of step numbers in the
!   routine THR_D_GREEN.
!
               IF (DIST<=1.*CLNGTH) THEN
                  MX=MCX*3/2
                  MY=MCY*3/2
                  MZ=MCZ*3/2
               ELSEIF (DIST<=3.*CLNGTH) THEN
                  MX=MCX
                  MY=MCY
                  MZ=MCZ
               ELSE
                  CLDST=SQRT(2.*CLNGTH/DIST)
                  MX=INT(FLOAT(MCX)*CLDST)
                  MY=INT(FLOAT(MCY)*CLDST)
                  MZ=INT(FLOAT(MCZ)*CLDST)
               END IF
!
               IF (MX<1) MX=1
               IF (MY<1) MY=1
               IF (MZ<1) MZ=1
               IF (MX>1) CMX=MX-1.
               IF (MY>1) CMY=MY-1.
               IF (MZ>1) CMZ=MZ-1.
!
!   Step numbers less than or equal to 3 in either dimension
!   may not be more accuarate than the 6-point approach
!
               IF (MX<=3.AND.MY<=3.AND.MZ<=3.AND.MX>1.AND.MY>1.AND.MZ>1)  &
                   THEN
                  KINT=1
                  CALL THR_D_VXYZ(CLXS,CLYS,CLZS,XSRS,YSRS,ZSRS,XX,YY,ZZ)
                  MM1=1
                  MM2=1
                  MM3=6
               ELSE
                  KINT=2
                  MM1=MX
                  MM2=MY
                  MM3=MZ
               END IF
!
               DO I=1,MM1
                  IF (KINT==2.AND.MM1==1) THEN
                     X1=XSRS
                     CX=1.
                  END IF
                  IF (KINT==2.AND.MM1/=1) THEN
                     X1=XSRS-.5*CLXS+CLXS/CMX*(I-1.)
                     CX=1./CMX
                     IF (I==1.OR.I==MX) CX=.5*CX
                  END IF
                  DO J=1,MM2
                     IF (KINT==2.AND.MM2==1) THEN
                        Y1=YSRS
                        CY=1.
                     END IF
                     IF (KINT==2.AND.MM2/=1) THEN
                        Y1=YSRS-.5*CLYS+CLYS/CMY*(J-1.)
                        CY=1./CMY
                        IF (J==1.OR.J==MY) CY=.5*CY
                     END IF
                     DO J3=1,MM3
                        IF (KINT==2.AND.MM3==1) THEN
                           Z1=ZSRS
                           CZ=1.
                        ELSEIF (KINT==2.AND.MM3/=1) THEN
                           Z1=ZSRS-.5*CLZS+CLZS/CMZ*(J3-1.)
                           CZ=1./CMZ
                           IF (J3==1.OR.J3==MZ) CZ=.5*CZ
                        ELSE
                           X1=XX(J3)
                           Y1=YY(J3)
                           Z1=ZZ(J3)
                        END IF
!
                        IF (KINT==1) THEN
                           C1=CC/6.
                        ELSE
                           C1=CC*CX*CY*CZ
                        END IF
!
                        R1=R(XOB,YOB,ZOB,X1,Y1,Z1)
!
! ----- In order to avoid numerical inaccuracy at the earth's surface
!     in dealing with a outcropping structure or for receivers
!     located within a structure,  singularities are
!     simply omitted if the receiver is very close to the cell
!     in integration.
!
                        IF (R1>=BLMIN) THEN
!
                           RHO=RR(XOB,YOB,X1,Y1)
!
! ----- If Rho < DMIN it should be assumed to be zero for the sake
!     of numerical accuracy.
!
                           IF (RHO>=DMIN) THEN
!
                              IF (ABS(HVK-1.)>=.0001) THEN
                              RA=RK(XOB,YOB,ZOB,X1,Y1,Z1)
                              ELSE
                              RA=R1
                              END IF
                              EKR=EXP(-K*R1)
                              IF (ABS(HVK-1.)>=.0001) THEN
                              EKRA=EXP(-K/HVK*RA)
                              ELSE
                              EKRA=EKR
                              END IF
                              C2=C1*(XOB-X1)*(ZOB-Z1)*(YOB-Y1)/RHO**4
                              E1=EKR*((1.,0.)+K*R1)/R1**3
                              IF (ABS(HVK-1.)>=.0001) THEN
                              E2=EKRA*(CMPLX(HVK,0.)+K*RA)/RA**3
                              ELSE
                              E2=E1
                              END IF
                              HXX=HXX+  &
                                 C2*(2.*(-EKR/R1+HVK*EKRA/RA)-RHO**2*  &
                                 (E1-E2))
                              C2=C1*(ZOB-Z1)  &
                                 /RHO**2*(1.-2.*((XOB-X1)/RHO)**2)
                              C3=C1*(XOB-X1)**2*(ZOB-Z1)/RHO**2
                              HYX=HYX-C1*(ZOB-Z1)  &
                                 *E1-C2*(EKR/R1-HVK*EKRA/RA)+C3*(E1-E2)
                              HZX=HZX+C1*(YOB-Y1)*E1
                              C2=C1*(ZOB-Z1)  &
                                 /RHO**2*(1.-2.*((YOB-Y1)/RHO)**2)
                              C3=C1*(YOB-Y1)**2*(ZOB-Z1)/RHO**2
                              HXY=HXY+C1*(ZOB-Z1)  &
                                 *E1+C2*(EKR/R1-HVK*EKRA/RA)-C3*(E1-E2)
                              HZY=HZY-C1*(XOB-X1)*E1
                              HXZ=HXZ-C1*(YOB-Y1)*E2
                              HYZ=HYZ+C1*(XOB-X1)*E2
!
                           ELSE
!
                              E1=-C1/2.*(1.+1./HVK**2)  &
                                 *EXP(-K*ABS(ZOB-Z1))/(ZOB-Z1)  &
                                 *(K+CMPLX(1./ABS(ZOB-Z1),0.))
                              HYX=HYX+E1
                              HXY=HXY-E1
!
                           END IF
                        END IF
!
                     END DO
                  END DO
               END DO
            END DO
         END DO
      END DO
      HYY=-HXX
      HZZ=(0.,0.)
!
! --- Assign the componenets to the arrays ECOMP and HCOMP
!   for data passing
!
      HCOMP(1)=HXX
      HCOMP(2)=HYX
      HCOMP(3)=HZX
      HCOMP(4)=HXY
      HCOMP(5)=HYY
      HCOMP(6)=HZY
      HCOMP(7)=HXZ
      HCOMP(8)=HYZ
      HCOMP(9)=HZZ
!
      RETURN
      END
!
!**** End of THR_D_GHPRM
!
!
      SUBROUTINE SCAT_EH_MT(NBMAX,NMAX,NXMAX,NYMAX,NZMAX,NBODY,SUB_BLOCK,   &
                            MT_PROFL,MT_STATN,XRMT,YRMT,NX,NY,NZ,NCELL,X,Y, &
                            Z,CLX,CLY,CLZ,JS,NPOL,KSFT,NSUBCM,CDB,CLMN,ZMT, &
                            E0X1,E0Y1,EXMT,EYMT,HXMT,HYMT,HZMT,FRQ,MLAYER,  &
                            ZBND,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,   &
                            NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,      &
                            GRHO03,KCLMN,BLMIN,KACC)
!
!**** Calculate scattered fields at receiver sites
!
!   Note if the receiver is located just on the top of  a block,
!   the electric field is calculated by the scattering current
!   directly
!
!   The array clmn should have the size of mbody. Since mbody
!   may be changed in the main program, here it is defined as 30.
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN2,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN,ZMT
      INTEGER I,IB,IX,IY,J,K,KACC,KCLMN,KEYG,KPOL,KSELF,KSFT,KUTCRP,L,     &
              LP1,LP2,MLAYER,N1
      INTEGER N2,NBMAX,NBODY,NCT,NHFILM,NJ,NJS,NMAX,NN,NN1,MT_PROFL,NPOL,  &
              MT_STATN,NRG,NRG3,NSUBCM,NXMAX,NYMAX,NZMAX,NZOB
      INTEGER NZSR
!
      COMPLEX JS(NMAX,NBODY),EX,EY,EZ,HX,HY,HZ,E0X,E0Y,E0X1,E0Y1,          &
              EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,                         &
              HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ,                         &
              EXMT(MT_PROFL,MT_STATN,2),EYMT(MT_PROFL,MT_STATN,2),         &
              HXMT(MT_PROFL,MT_STATN,2),HYMT(MT_PROFL,MT_STATN,2),         &
              HZMT(MT_PROFL,MT_STATN,2),CDH(0:MLAYER),                     &
              CDB(NSUBCM,NBMAX,NBODY),GRHF(11,NHFILM,NZSR,NZOB),           &
              GRHO0(4,NZSR,NZOB),GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(NBMAX,NBODY),NY(NBMAX,NBODY),NZ(NBMAX,NBODY),             &
              NCELL(NBMAX,NBODY),SUB_BLOCK(NBODY)
      REAL  X(NXMAX,NBMAX,NBODY),Y(NYMAX,NBMAX,NBODY),                     &
            Z(NZMAX,NBMAX,NBODY),CLMN(NBODY),                              &
            CLX(NBMAX,NBODY),CLY(NBMAX,NBODY),CLZ(NBMAX,NBODY),            &
            XRMT(MT_PROFL),YRMT(MT_STATN),                                 &
            ZBND(0:MLAYER),HVK(0:MLAYER),                                  &
            ZOBG(NZOB),ZSRG(2,NZSR),                                       &
            RRG(NRG),RRG3(NRG3),PSTION(6)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ),   &
                  (HCOMP(1),HXX),(HCOMP(2),HYX),(HCOMP(3),HZX),   &
                  (HCOMP(4),HXY),(HCOMP(5),HYY),(HCOMP(6),HZY),   &
                  (HCOMP(7),HXZ),(HCOMP(8),HYZ),(HCOMP(9),HZZ)
!
      KSELF=0
      KEYG=2
!
      IF (NPOL==0.OR.NPOL==1) THEN
         LP1=1+NPOL
         LP2=1+NPOL
      ELSEIF (NPOL==2) THEN
         LP1=1
         LP2=2
      END IF
!
      DO KPOL=LP1,LP2
!
! --- Read js per polarization
!
         IF (NPOL==2) THEN
            DO IB=1,NBODY
               NCT=0
               DO I=1,SUB_BLOCK(IB)
                  NCT=NCT+NCELL(I,IB)
               END DO
               READ (20) (JS(J,IB),J=1,3*NCT)
            END DO
         END IF
!
         IF (KSFT/=0.OR.ZMT>=.1) THEN
            IF (KPOL==1) THEN
               E0X=(0.,0.)
               E0Y=E0Y1
            ELSE
               E0X=E0X1
               E0Y=(0.,0.)
            END IF
         END IF
!
         DO IY=1,MT_STATN
            DO IX=1,MT_PROFL
!
               EX=(0.,0.)
               EY=(0.,0.)
               EZ=(0.,0.)
               HX=(0.,0.)
               HY=(0.,0.)
               HZ=(0.,0.)
!
               IF (KSFT==0.AND.ZMT<.1) THEN
                  KUTCRP=0
                  GOTO 10
               END IF
!
               KUTCRP=0
               DO IB=1,NBODY
                  NJ=0
                  DO L=1,SUB_BLOCK(IB)
                     IF (L>1) NJ=NJ+3*NCELL(L-1,IB)
                     DO I=1,NX(L,IB)
                        DO J=1,NY(L,IB)
                           DO K=1,NZ(L,IB)
                              IF (XRMT(IX)>=X(I,L,IB)-.5*CLX(L,IB)        &
                                 -.1.AND.XRMT(IX)<X(I,L,IB)+.5*CLX(L,IB)  &
                                 +.1.AND.YRMT(IY)>=Y(J,L,IB)              &
                                 -.5*CLY(L,IB)-.1.AND.YRMT(IY)<Y(J,L,IB)  &
                                 +.5*CLY(L,IB)+.1.AND.ZMT>=Z(K,L,IB)      &
                                 -.5*CLZ(L,IB)-.1.AND.ZMT<Z(K,L,IB)       &
                                 +.5*CLZ(L,IB)+.1) THEN
                              KUTCRP=1
                              N1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)   &
                                 +K
                              N2=(N1-1)*3+1+NJ
!
! ---- Determine the E-field (scattered) at the top of an outcropping
!    cell by the scattering current directly
!
                              EXMT(IX,IY,KPOL)=JS(N2,IB)  &
                                 /(CDB(N1,L,IB)-CDH(1))-E0X
                              EYMT(IX,IY,KPOL)=JS(N2+1,IB)  &
                                 /(CDB(N1,L,IB)-CDH(1))-E0Y
                              GOTO 10
                              END IF
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
!
   10          DO IB=1,NBODY
!
                  CLMN2=CLMN(IB)
!
                  NJS=0
                  DO L=1,SUB_BLOCK(IB)
                     IF (L>1) NJS=NJS+3*NCELL(L-1,IB)
                     DO I=1,NX(L,IB)
                        DO J=1,NY(L,IB)
                           DO K=1,NZ(L,IB)
                              NN1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)  &
                                 +K
                              NN=(NN1-1)*3+1+NJS
                              CLX1=CLX(L,IB)
                              CLY1=CLY(L,IB)
                              CLZ1=CLZ(L,IB)
!
                              PSTION(1)=XRMT(IX)
                              PSTION(2)=YRMT(IY)
                              PSTION(3)=ZMT
                              PSTION(4)=X(I,L,IB)
                              PSTION(5)=Y(J,L,IB)
                              PSTION(6)=Z(K,L,IB)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX1,CLY1,CLZ1,     &
                                 CLMN2,KCLMN,BLMIN,KACC,KUTCRP,KSELF,        &
                                 ECOMP,HCOMP)
!
                              EX=EX+(JS(NN,IB)*EXX+JS(NN+1,IB)*EXY+          &
                                     JS(NN+2,IB)*EXZ)
                              EY=EY+(JS(NN,IB)*EYX+JS(NN+1,IB)*EYY+          &
                                     JS(NN+2,IB)*EYZ)
                              EZ=EZ+(JS(NN,IB)*EZX+JS(NN+1,IB)*EZY+          &
                                     JS(NN+2,IB)*EZZ)
                              HX=HX+(JS(NN,IB)*HXX+JS(NN+1,IB)*HXY+          &
                                     JS(NN+2,IB)*HXZ)
                              HY=HY+(JS(NN,IB)*HYX+JS(NN+1,IB)*HYY+          &
                                     JS(NN+2,IB)*HYZ)
                              HZ=HZ+(JS(NN,IB)*HZX+JS(NN+1,IB)*HZY+          &
                                     JS(NN+2,IB)*HZZ)
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
!
               IF (KUTCRP==0) THEN
                  EXMT(IX,IY,KPOL)=EX
                  EYMT(IX,IY,KPOL)=EY
               END IF
               HXMT(IX,IY,KPOL)=HX
               HYMT(IX,IY,KPOL)=HY
               HZMT(IX,IY,KPOL)=HZ
            END DO
         END DO
      END DO
!
      REWIND (20)
!
      RETURN
      END
!
!**** End of SCAT_EH_MT
!
!
      SUBROUTINE SCAT_EH_MTS(NBMAX,NMAX,NXMAX,NYMAX,NZMAX,NBODY,SUB_BLOCK,  &
                             MT_PROFL,MT_STATN,XRMT,YRMT,NX,NY,NZ,NCELL,    &
                             X,Y,Z,CLX,CLY,CLZ,JS,NPOL,KSFT,NSUBCM,CDB,     &
                             CLMN,ZMT,E0X1,E0Y1,EXMT,EYMT,HXMT,HYMT,HZMT,   &
                             FRQ,MLAYER,ZBND,CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,   &
                             RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,NRG3,     &
                             GRHF3,GRHO0,GRHO03,KCLMN,BLMIN,KACC)
!
!**** Calculate scattered fields at receiver stations
!
!   The array clmn should have the size of mbody. Since mbody
!   may be changed in the main program, here it is defined as 30.
!
!
      IMPLICIT NONE
!
      REAL BLMIN,BX,BY,CLMN2,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN,SP,SX,SY,SZ,ZMT
      INTEGER I,IB,IX,IY,J,K,KACC,KCLMN,KEYG,KPOL,KSELF,KSFT,KSYM,           &
              KUTCRP,L,LP1,LP2,MLAYER
      INTEGER N1,N2,NBMAX,NBODY,NCT,NHFILM,NJ,NJS,NMAX,NN,NN1,MT_PROFL,NPOL, &
              MT_STATN,NRG,NRG3,NSUBCM,NXMAX,NYMAX,NZMAX
      INTEGER NZOB,NZSR
!
      COMPLEX JS(NMAX,NBODY),EX,EY,EZ,HX,HY,HZ,E0X,E0Y,E0X1,E0Y1,       &
              EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,                      &
              HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ,                      &
              EXMT(MT_PROFL,MT_STATN,2),EYMT(MT_PROFL,MT_STATN,2),      &
              HXMT(MT_PROFL,MT_STATN,2),HYMT(MT_PROFL,MT_STATN,2),      &
              HZMT(MT_PROFL,MT_STATN,2),                                &
              CDH(0:MLAYER),CDB(NSUBCM,NBMAX,NBODY),                    &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),             &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(NBMAX,NBODY),NY(NBMAX,NBODY),NZ(NBMAX,NBODY),          &
              NCELL(NBMAX,NBODY),SUB_BLOCK(NBODY)
      REAL  X(NXMAX,NBMAX,NBODY),Y(NYMAX,NBMAX,NBODY),                  &
            Z(NZMAX,NBMAX,NBODY),CLMN(NBODY),                           &
            CLX(NBMAX,NBODY),CLY(NBMAX,NBODY),CLZ(NBMAX,NBODY),         &
            XRMT(MT_PROFL),YRMT(MT_STATN),ZBND(0:MLAYER),HVK(0:MLAYER),                         &
            ZOBG(NZOB),ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(6)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ),   &
                  (HCOMP(1),HXX),(HCOMP(2),HYX),(HCOMP(3),HZX),   &
                  (HCOMP(4),HXY),(HCOMP(5),HYY),(HCOMP(6),HZY),   &
                  (HCOMP(7),HXZ),(HCOMP(8),HYZ),(HCOMP(9),HZZ)
!
      KSELF=0
      KEYG=2
!
      IF (NPOL==0.OR.NPOL==1) THEN
         LP1=1+NPOL
         LP2=1+NPOL
      ELSEIF (NPOL==2) THEN
         LP1=1
         LP2=2
      END IF
!
      DO KPOL=LP1,LP2
!
! --- Read js per polarization
!
         IF (NPOL==2) THEN
            DO IB=1,NBODY
               NCT=0
               DO I=1,SUB_BLOCK(IB)
                  NCT=NCT+NCELL(I,IB)
               END DO
               READ (20) (JS(J,IB),J=1,3*NCT)
            END DO
         END IF
!
         IF (KSFT/=0.OR.ZMT>=.1) THEN
            IF (KPOL==1) THEN
               E0X=(0.,0.)
               E0Y=E0Y1
            ELSE
               E0X=E0X1
               E0Y=(0.,0.)
            END IF
         END IF
!
         DO IY=1,MT_STATN
            DO IX=1,MT_PROFL
!
               IF (KPOL==1) THEN
                  SP=1.
               ELSE
                  SP=-1.
               END IF
               EX=(0.,0.)
               EY=(0.,0.)
               EZ=(0.,0.)
               HX=(0.,0.)
               HY=(0.,0.)
               HZ=(0.,0.)
!
               IF (KSFT==0.AND.ZMT<.1) THEN
                  KUTCRP=0
                  GOTO 10
               END IF
!
               KUTCRP=0
               DO IB=1,NBODY
                  NJ=0
                  DO L=1,SUB_BLOCK(IB)
                     IF (L>1) NJ=NJ+3*NCELL(L-1,IB)
                     DO I=1,NX(L,IB)
                        DO J=1,NY(L,IB)
                           DO K=1,NZ(L,IB)
!
! ---- For quarter I
                              IF (XRMT(IX)>=X(I,L,IB)-.5*CLX(L,IB)        &
                                 -.1.AND.XRMT(IX)<X(I,L,IB)+.5*CLX(L,IB)  &
                                 +.1.AND.YRMT(IY)>=Y(J,L,IB)              &
                                 -.5*CLY(L,IB)-.1.AND.YRMT(IY)<Y(J,L,IB)  &
                                 +.5*CLY(L,IB)+.1.AND.ZMT>=Z(K,L,IB)      &
                                 -.5*CLZ(L,IB)-.1.AND.ZMT<Z(K,L,IB)       &
                                 +.5*CLZ(L,IB)+.1) THEN
                              KUTCRP=1
                              N1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)+K
                              N2=(N1-1)*3+1+NJ
!
! ---- Determine the E-field (scattered)  at the top of an outcropping
!    cell by the scattering current directly
!
                              EXMT(IX,IY,KPOL)=JS(N2,IB)        &
                                 /(CDB(N1,L,IB)-CDH(1))-E0X
                              EYMT(IX,IY,KPOL)=JS(N2+1,IB)      &
                                 /(CDB(N1,L,IB)-CDH(1))-E0Y
                              GOTO 10
                              END IF
!
! ---- For quarter II
                              IF (XRMT(IX)>=-X(I,L,IB)-.5*CLX(L,IB)       &
                                 -.1.AND.XRMT(IX)<-X(I,L,IB)              &
                                 +.5*CLX(L,IB)+.1.AND.YRMT(IY)            &
                                 >=Y(J,L,IB)-.5*CLY(L,IB)-.1.AND.         &
                                 YRMT(IY)<Y(J,L,IB)+.5*CLY(L,IB)+.1.AND.  &
                                 ZMT>=Z(K,L,IB)-.5*CLZ(L,IB)-.1.AND.      &
                                 ZMT<Z(K,L,IB)+.5*CLZ(L,IB)+.1) THEN
                              KUTCRP=1
                              N1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)   &
                                 +K
                              N2=(N1-1)*3+1+NJ
!
                              EXMT(IX,IY,KPOL)=-SP*JS(N2,IB)              &
                                 /(CDB(N1,L,IB)-CDH(1))-E0X
                              EYMT(IX,IY,KPOL)=SP*JS(N2+1,IB)             &
                                 /(CDB(N1,L,IB)-CDH(1))-E0Y
                              GOTO 10
                              END IF
!
! ---- For quarter III
                              IF (XRMT(IX)>=-X(I,L,IB)-.5*CLX(L,IB)        &
                                 -.1.AND.XRMT(IX)<-X(I,L,IB)               &
                                 +.5*CLX(L,IB)+.1.AND.YRMT(IY)             &
                                 >=-Y(J,L,IB)-.5*CLY(L,IB)-.1.AND.         &
                                 YRMT(IY)<-Y(J,L,IB)+.5*CLY(L,IB)          &
                                 +.1.AND.ZMT>=Z(K,L,IB)-.5*CLZ(L,IB)       &
                                 -.1.AND.ZMT<Z(K,L,IB)+.5*CLZ(L,IB)+.1)    &
                                 THEN
                              KUTCRP=1
                              N1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)    &
                                 +K
                              N2=(N1-1)*3+1+NJ
!
                              EXMT(IX,IY,KPOL)=JS(N2,IB)                   &
                                 /(CDB(N1,L,IB)-CDH(1))-E0X
                              EYMT(IX,IY,KPOL)=JS(N2+1,IB)                 &
                                 /(CDB(N1,L,IB)-CDH(1))-E0Y
                              GOTO 10
                              END IF
!
! ---- For quarter IV
                              IF (XRMT(IX)>=X(I,L,IB)-.5*CLX(L,IB)         &
                                 -.1.AND.XRMT(IX)<X(I,L,IB)+.5*CLX(L,IB)   &
                                 +.1.AND.YRMT(IY)>=-Y(J,L,IB)              &
                                 -.5*CLY(L,IB)-.1.AND.YRMT(IY)             &
                                 <-Y(J,L,IB)+.5*CLY(L,IB)+.1.AND.          &
                                 ZMT>=Z(K,L,IB)-.5*CLZ(L,IB)-.1.AND.       &
                                 ZMT<Z(K,L,IB)+.5*CLZ(L,IB)+.1) THEN
                              KUTCRP=1
                              N1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)    &
                                 +K
                              N2=(N1-1)*3+1+NJ
!
                              EXMT(IX,IY,KPOL)=-SP*JS(N2,IB)               &
                                 /(CDB(N1,L,IB)-CDH(1))-E0X
                              EYMT(IX,IY,KPOL)=SP*JS(N2+1,IB)              &
                                 /(CDB(N1,L,IB)-CDH(1))-E0Y
                              GOTO 10
                              END IF
!
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
!
   10          DO IB=1,NBODY
!
                  CLMN2=CLMN(IB)
!
                  NJS=0
                  DO L=1,SUB_BLOCK(IB)
                     IF (L>1) NJS=NJS+3*NCELL(L-1,IB)
                     DO I=1,NX(L,IB)
                        DO J=1,NY(L,IB)
                           DO K=1,NZ(L,IB)
                              NN1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)+K
                              NN=(NN1-1)*3+1+NJS
                              CLX1=CLX(L,IB)
                              CLY1=CLY(L,IB)
                              CLZ1=CLZ(L,IB)
!
                              DO KSYM=1,4
                              IF (KSYM==1) THEN
                              BX=1.
                              BY=1.
                              SX=1.
                              SY=1.
                              SZ=1.
                              END IF
                              IF (KSYM==2) THEN
                              BX=-1.
                              BY=1.
                              SX=-SP
                              SY=SP
                              SZ=SP
                              END IF
                              IF (KSYM==3) THEN
                              BX=-1.
                              BY=-1.
                              SX=1.
                              SY=1.
                              SZ=-1.
                              END IF
                              IF (KSYM==4) THEN
                              BX=1.
                              BY=-1.
                              SX=-SP
                              SY=SP
                              SZ=-SP
                              END IF
!
                              PSTION(1)=XRMT(IX)
                              PSTION(2)=YRMT(IY)
                              PSTION(3)=ZMT
                              PSTION(4)=BX*X(I,L,IB)
                              PSTION(5)=BY*Y(J,L,IB)
                              PSTION(6)=Z(K,L,IB)
                              CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,  &
                                 CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,                &
                                 RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                                 NRG3,GRHF3,GRHO0,GRHO03,CLX1,CLY1,CLZ1,     &
                                 CLMN2,KCLMN,BLMIN,KACC,KUTCRP,KSELF,        &
                                 ECOMP,HCOMP)
!
                              EX=EX+(SX*JS(NN,IB)*EXX+SY*JS(NN+1,IB)  &
                                 *EXY+SZ*JS(NN+2,IB)*EXZ)
                              EY=EY+(SX*JS(NN,IB)*EYX+SY*JS(NN+1,IB)  &
                                 *EYY+SZ*JS(NN+2,IB)*EYZ)
                              EZ=EZ+(SX*JS(NN,IB)*EZX+SY*JS(NN+1,IB)  &
                                 *EZY+SZ*JS(NN+2,IB)*EZZ)
                              HX=HX+(SX*JS(NN,IB)*HXX+SY*JS(NN+1,IB)  &
                                 *HXY+SZ*JS(NN+2,IB)*HXZ)
                              HY=HY+(SX*JS(NN,IB)*HYX+SY*JS(NN+1,IB)  &
                                 *HYY+SZ*JS(NN+2,IB)*HYZ)
                              HZ=HZ+(SX*JS(NN,IB)*HZX+SY*JS(NN+1,IB)  &
                                 *HZY+SZ*JS(NN+2,IB)*HZZ)
                              END DO
                           END DO
                        END DO
                     END DO
                  END DO
               END DO
!
               IF (KUTCRP==0) THEN
                  EXMT(IX,IY,KPOL)=EX
                  EYMT(IX,IY,KPOL)=EY
               END IF
               HXMT(IX,IY,KPOL)=HX
               HYMT(IX,IY,KPOL)=HY
               HZMT(IX,IY,KPOL)=HZ
            END DO
         END DO
      END DO
!
      REWIND (20)
!
      RETURN
      END
!
!**** End of SCAT_EH_MTS
!
!
      SUBROUTINE SCAT_EH_CSGS(SUB_RX_MAX,RX_TYPE_INDEX,N_SUB_RX,               &
                              RX_WEIGHT,NBMAX,NEQ,NXMAX,NYMAX,NZMAX,NBODY,     &
                              SUB_BLOCK,NET,N_RX,RX_X,RX_Y,RX_Z,NX,NY,NZ,      &
                              NCELL,X,Y,Z,CLX,CLY,CLZ,JS,NSUBCM,CDB,IEXCI,     &
                              CLMN,M_RX,NTXE,VLT,                              &
                              ENX,ENY,ENZ,EAX,EAY,EAZ,HAX,HAY,HAZ,             &
                              FRQ,MLAYER,ZBND,CDH,CDV,HVK,RMU_LYR,             &
                              NZOB,ZOBG,NZSR,                                  &
                              ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,       &
                              NRG3,GRHF3,GRHO0,GRHO03,KCLMN,BLMIN,KACC)
!
!**** Calculate the scattered fields at receiver sites
!   due to symmetric structures
!
!  *** Note that output HAX etc for magnetic dipoles are in fact components of B.
!
!
!   This routine is similar to the routine SCAT_EH_CS. The numbering
!   of the array JS is completely different.
!
!   Note if the receiver is located within a cell, the electric field
!   is then calculated by the scattering current directly.
!
!   Note the controlling parameter koutcrp was originally designed for
!   outcropping structures so that it bears this named.
!
!   The array clmn should have the size of mbody. Since mbody
!   may be changed in the main program, here it is defined as 30.
!
!
      IMPLICIT NONE
!
      REAL BLMIN,BX,BY,CLMN2,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN
      INTEGER I,IB,IEXCI,II,IQ,J,K,KK,KACC,KCLMN,KEYG,KSELF,KUTCRP,L,      &
              MLAYER,M_RX,N1,N2,NBMAX,NBODY,NEQ
      INTEGER NHFILM,NJ,NN,NN1,NRG,NRG3,NSUB,NSUBCM,NTXE,NXMAX,       &
              NYMAX,NZMAX,NZOB,NZSR
!
      COMPLEX JS(4*NEQ),EX,EY,EZ,HX,HY,HZ,                              &
              EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,                      &
              HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ,                      &
              ENX(M_RX,NTXE),ENY(M_RX,NTXE),ENZ(M_RX,NTXE),       &
              EAX(M_RX),EAY(M_RX),EAZ(M_RX),VLT(M_RX),                  &
              HAX(M_RX),HAY(M_RX),HAZ(M_RX),                            &
              CDH(0:MLAYER),CDV(0:MLAYER),CDB(NSUBCM,NBMAX,NBODY),      &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),             &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(NBMAX,NBODY),NY(NBMAX,NBODY),NZ(NBMAX,NBODY),          &
              NCELL(NBMAX,NBODY),SUB_BLOCK(NBODY),NET(NBODY)
      REAL  X(NXMAX,NBMAX,NBODY),Y(NYMAX,NBMAX,NBODY),                  &
            Z(NZMAX,NBMAX,NBODY),CLMN(NBODY),                           &
            CLX(NBMAX,NBODY),CLY(NBMAX,NBODY),CLZ(NBMAX,NBODY),         &
            ZBND(0:MLAYER),HVK(0:MLAYER),RMU_LYR(MLAYER),               &
            ZOBG(NZOB),ZSRG(2,NZSR),RRG(NRG),RRG3(NRG3),PSTION(6)
      INTEGER, INTENT(IN) :: SUB_RX_MAX,RX_TYPE_INDEX(M_RX,NTXE)
      REAL, INTENT(IN) :: RX_X(SUB_RX_MAX,M_RX,NTXE),              &
                          RX_Y(SUB_RX_MAX,M_RX,NTXE),              &
                          RX_Z(SUB_RX_MAX,M_RX,NTXE),              &

                          RX_WEIGHT(3,SUB_RX_MAX,M_RX,NTXE)
      INTEGER N_RX(NTXE),N_SUB_RX(M_RX,NTXE)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ),   &
                  (HCOMP(1),HXX),(HCOMP(2),HYX),(HCOMP(3),HZX),   &
                  (HCOMP(4),HXY),(HCOMP(5),HYY),(HCOMP(6),HZY),   &
                  (HCOMP(7),HXZ),(HCOMP(8),HYZ),(HCOMP(9),HZZ)
!
      REAL :: LX,LY,LZ,C_INT,RX_XX,RX_YY,RX_ZZ,RMU
      INTEGER :: JJ,NOB
!
      KSELF=0
      KEYG=2
!
      DO II=1,N_RX(IEXCI)
!
!   --  The way stacking up sub-receivers is identical to those for 1D responses
!
         IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!    --     Note that receiver bipoles have been divided into sub-sections
!
            LX=RX_X(2,II,IEXCI)-RX_X(1,II,IEXCI)
            LY=RX_Y(2,II,IEXCI)-RX_Y(1,II,IEXCI)
            LZ=RX_Z(2,II,IEXCI)-RX_Z(1,II,IEXCI)
!
         END IF

         VLT(II)=(0.,0.)
         EAX(II)=(0.,0.)
         EAY(II)=(0.,0.)
         EAZ(II)=(0.,0.)
         HAX(II)=(0.,0.)
         HAY(II)=(0.,0.)
         HAZ(II)=(0.,0.)
!
         DO KK=1,N_SUB_RX(II,IEXCI)
!
            RX_XX=RX_X(KK,II,IEXCI)
            RX_YY=RX_Y(KK,II,IEXCI)
            RX_ZZ=RX_Z(KK,II,IEXCI)
!
!  --  EX etc are used to sum the contributions of the cells
            EX=(0.,0.)
            EY=(0.,0.)
            EZ=(0.,0.)
            HX=(0.,0.)
            HY=(0.,0.)
            HZ=(0.,0.)
!
            KUTCRP=0
            NSUB=0
            DO IB=1,NBODY
               IF (IB>1) NSUB=NSUB+NET(IB-1)/3
               NJ=0
               DO L=1,SUB_BLOCK(IB)
                  IF (L>1) NJ=NJ+NCELL(L-1,IB)
                  DO I=1,NX(L,IB)
                  DO J=1,NY(L,IB)
                  DO K=1,NZ(L,IB)
                     DO IQ=1,4
!
                        IF (IQ==1) THEN
                           BX=-1.
                           BY=-1.
                        END IF
                        IF (IQ==2) THEN
                           BX=1.
                           BY=-1.
                        END IF
                        IF (IQ==3) THEN
                           BX=1.
                           BY=1.
                        END IF
                        IF (IQ==4) THEN
                           BX=-1.
                           BY=1.
                        END IF
!
                        IF (RX_XX>=BX*X(I,L,IB)-.5*CLX(L,IB)        &
                            -.01.AND.RX_XX<BX*X(I,L,IB)             &
                            +.5*CLX(L,IB)+.01.AND.RX_YY             &
                            >=BY*Y(J,L,IB)-.5*CLY(L,IB)-.01.AND.    &
                            RX_YY<BY*Y(J,L,IB)+.5*CLY(L,IB)         &
                            +.01.AND.RX_ZZ>=Z(K,L,IB)               &
                            -.5*CLZ(L,IB)-.01.AND.RX_ZZ             &
                            <Z(K,L,IB)+.5*CLZ(L,IB)+.01) THEN
                           KUTCRP=1
                           N1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)+K
                           N2=12*(N1+NJ+NSUB-1)+3*(IQ-1)+1
!
! ---- Determine the E-field (scattered) within a
!    cell by the scattering current directly
!
                           EX=JS(N2)/(CDB(N1,L,IB)-CDH(1))-ENX(II,IEXCI)
                           EY=JS(N2+1)/(CDB(N1,L,IB)-CDH(1))-ENY(II,IEXCI)
                           EZ=JS(N2+2)/(CDB(N1,L,IB)-CDV(1))-ENZ(II,IEXCI)
                           GOTO 50
                        END IF
                     END DO
                  END DO
                  END DO
                  END DO
               END DO
            END DO
!
   50       NSUB=0
            DO IB=1,NBODY
               IF (IB>1) NSUB=NSUB+NET(IB-1)/3
!
               CLMN2=CLMN(IB)
!
               NJ=0
               DO L=1,SUB_BLOCK(IB)
                  IF (L>1) NJ=NJ+NCELL(L-1,IB)
                  DO I=1,NX(L,IB)
                  DO J=1,NY(L,IB)
                  DO K=1,NZ(L,IB)
                     DO IQ=1,4
!
                        IF (IQ==1) THEN
                           BX=-1.
                           BY=-1.
                        END IF
                        IF (IQ==2) THEN
                           BX=1.
                           BY=-1.
                        END IF
                        IF (IQ==3) THEN
                           BX=1.
                           BY=1.
                        END IF
                        IF (IQ==4) THEN
                           BX=-1.
                           BY=1.
                        END IF
!
                        NN1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)+K
                        NN=12*(NN1+NJ+NSUB-1)+3*(IQ-1)+1
                        CLX1=CLX(L,IB)
                        CLY1=CLY(L,IB)
                        CLZ1=CLZ(L,IB)
!
                        PSTION(1)=RX_XX
                        PSTION(2)=RX_YY
                        PSTION(3)=RX_ZZ
                        PSTION(4)=BX*X(I,L,IB)
                        PSTION(5)=BY*Y(J,L,IB)
                        PSTION(6)=Z(K,L,IB)
                        CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,CDH,  &
                           HVK,NZOB,ZOBG,NZSR,ZSRG,RHOMIN,                 &
                           DMIN,NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,       &
                           GRHO0,GRHO03,CLX1,CLY1,CLZ1,CLMN2,KCLMN,        &
                           BLMIN,KACC,KUTCRP,KSELF,ECOMP,HCOMP)
!
                        IF (KUTCRP==0) THEN
                           EX=EX+(JS(NN)*EXX+JS(NN+1)*EXY+JS(NN+2)*EXZ)
                           EY=EY+(JS(NN)*EYX+JS(NN+1)*EYY+JS(NN+2)*EYZ)
                           EZ=EZ+(JS(NN)*EZX+JS(NN+1)*EZY+JS(NN+2)*EZZ)
                        END IF
                        HX=HX+(JS(NN)*HXX+JS(NN+1)*HXY+JS(NN+2)*HXZ)
                        HY=HY+(JS(NN)*HYX+JS(NN+1)*HYY+JS(NN+2)*HYZ)
                        HZ=HZ+(JS(NN)*HZX+JS(NN+1)*HZY+JS(NN+2)*HZZ)
!
                     END DO
                  END DO
                  END DO
                  END DO
               END DO
            END DO
!
            IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!  --  Integrations along the receiver lines are similar to routines ONE_D_SOURCE
!      and ONE_D_LINE except for vertical lines.
!
!      Trapezoidal rule is used for simplicity
!
               IF (KK==1.or.KK==N_SUB_RX(II,IEXCI)) THEN
                  C_INT=.5
               ELSE
                  C_INT=1.
               END IF
               IF (ABS(LX)>=ABS(LY).AND.ABS(LX)>=ABS(LZ)) THEN
!       --        Integrate along X
                  VLT(II)=VLT(II)+(EX+EY*LY/LX+EZ*LZ/LX)*C_INT*LX
               ELSE IF (ABS(LY)>=ABS(LX).AND.ABS(LY)>=ABS(LZ)) THEN
!       --        Integrate along Y.
!                 Note that integration along Z is done
!                 analytically for strictly vertical receiver lines
                  VLT(II)=VLT(II)+(EY+EX*LX/LY+EZ*LZ/LY)*C_INT*LY
               ELSE
!       --        Integrate along Z.
!                 Note that integration along Z is done for receiver positions.
!                 This is different from routines ONE_D_SOURCE and ONE_D_LINE where
!                 strictly vertical transmitter lines are integrated analytically
!                 in the Hankel kernels.
                  VLT(II)=VLT(II)+(EZ+EX*LX/LZ+EY*LY/LZ)*C_INT*LZ
               END IF
!
            ELSE IF (RX_TYPE_INDEX(II,IEXCI)==2) THEN
!
!          --     Integrate loop receivers that are converted to magnetic dipole receivers
!
               HAX(II)=HAX(II)+HX*RX_WEIGHT(1,K,II,IEXCI)
               HAY(II)=HAY(II)+HY*RX_WEIGHT(2,K,II,IEXCI)
               HAZ(II)=HAZ(II)+HZ*RX_WEIGHT(3,K,II,IEXCI)
!
!  --- Convert H to B (single component)
!
!     -- Receiver layer
               DO JJ=MLAYER-1,0,-1
                  IF (RX_ZZ>=ZBND(JJ)) THEN
                     NOB=JJ+1
                     GOTO 55
                  END IF

               END DO
               NOB=0
            55 CONTINUE
               IF (NOB==0) THEN
                  RMU=1.
               ELSE
                  RMU=RMU_LYR(NOB)
               END IF
!
               RMU=RMU*4.*3.1415926E-7
               VLT(II)=(HAX(II)+HAY(II)+HAZ(II))*RMU
!
            ELSE
!
!       --     Magnetic dipole receivers (only one sub-receiver)
!              Electric components are also computed thought they are not used.
!
!              Electric component may not be used in this particular version
               EAX(II)=EAX(II)+EX
               EAY(II)=EAY(II)+EY
               EAZ(II)=EAZ(II)+EZ
!
!  --- Convert H to B
!
!     -- Receiver layer
               DO JJ=MLAYER-1,0,-1
                  IF (RX_ZZ>=ZBND(JJ)) THEN
                     NOB=JJ+1
                     GOTO 56
                  END IF
               END DO
               NOB=0
            56 CONTINUE
               IF (NOB==0) THEN
                  RMU=1.
               ELSE
                  RMU=RMU_LYR(NOB)
               END IF
               RMU=RMU*4.*3.1415926E-7
               HAX(II)=HAX(II)+HX*RMU
               HAY(II)=HAY(II)+HY*RMU
               HAZ(II)=HAZ(II)+HZ*RMU
!
            END IF
!
         END DO
!
      END DO
!
      RETURN
      END
!
!
      SUBROUTINE SCAT_EH_CS(SUB_RX_MAX,RX_TYPE_INDEX,N_SUB_RX,               &
                            RX_WEIGHT,NBMAX,NMAX,NXMAX,NYMAX,NZMAX,NBODY,    &
                            SUB_BLOCK,N_RX,RX_X,RX_Y,RX_Z,NX,NY,NZ,NCELL,    &
                            X,Y,Z,CLX,CLY,CLZ,JS,NSUBCM,CDB,IEXCI,CLMN,      &
                            M_RX,NTXE,VLT,ENX,ENY,ENZ,EAX,EAY,EAZ,HAX,HAY,   &
                            HAZ,FRQ,MLAYER,ZBND,CDH,CDV,HVK,                 &
                            RMU_LYR,NZOB,ZOBG,NZSR,                          &
                            ZSRG,RHOMIN,DMIN,NHFILM,RRG,NRG,GRHF,RRG3,NRG3,  &
                            GRHF3,GRHO0,GRHO03,KCLMN,BLMIN,KACC)

!**** Calculate scattered fields at receiver sites
!
!  *** Note that output HAX etc for magnetic dipoles are in fact components of B.
!
!   Note if the receiver is located within a cell, the electric field
!   is then calculated by the scattering current directly.
!
!   Note the controlling parameter koutcrp was originally designed for
!   outcropping structures so that it bears this named.
!
!   The array clmn should have the size of mbody. Since mbody
!   may be changed in the main program, here it is defined as 30.
!
!   ENX, ENY,  etc. are used to compute electric fields for receivers
!   onm or within the 3D target.
!
!
!   Parameters  FRQ,MLAYER,ZBND,
!             CDH,HVK,NZOB,ZOBG,NZSR,ZSRG,
!             RHOMIN,DMIN,NHFILM,RRG,GRHF,GRHF3,GRHO0,
!             GRHO03,KCLMN,BLMIN,
!             KACC,  are to be passed to routine THR_D_GREEN
!
!
      IMPLICIT NONE
!
      REAL BLMIN,CLMN2,CLX1,CLY1,CLZ1,DMIN,FRQ,RHOMIN
      INTEGER I,IB,IEXCI,II,J,K,KK,KACC,KCLMN,KEYG,KSELF,KUTCRP,L,MLAYER,   &
              M_RX,N1,N2,NBMAX,NBODY,NHFILM,NJ
      INTEGER NJS,NMAX,NN,NN1,NRG,NRG3,NSUBCM,NTXE,NXMAX,NYMAX,        &
              NZMAX,NZOB,NZSR
!
      COMPLEX JS(NMAX,NBODY),EX,EY,EZ,HX,HY,HZ,                          &
              EXX,EYX,EZX,EXY,EYY,EZY,EXZ,EYZ,EZZ,                       &
              HXX,HYX,HZX,HXY,HYY,HZY,HXZ,HYZ,HZZ,                       &
              ENX(M_RX,NTXE),ENY(M_RX,NTXE),ENZ(M_RX,NTXE),        &
              EAX(M_RX),EAY(M_RX),EAZ(M_RX),VLT(M_RX),                   &
              HAX(M_RX),HAY(M_RX),HAZ(M_RX),                             &
              CDH(0:MLAYER),CDV(0:MLAYER),CDB(NSUBCM,NBMAX,NBODY),       &
              GRHF(11,NHFILM,NZSR,NZOB),GRHO0(4,NZSR,NZOB),              &
              GRHF3(11,NHFILM,NZSR),GRHO03(4,NZSR)
      INTEGER NX(NBMAX,NBODY),NY(NBMAX,NBODY),NZ(NBMAX,NBODY),           &
              NCELL(NBMAX,NBODY),SUB_BLOCK(NBODY)
      REAL  X(NXMAX,NBMAX,NBODY),Y(NYMAX,NBMAX,NBODY),                   &
            Z(NZMAX,NBMAX,NBODY),CLMN(NBODY),                            &
            CLX(NBMAX,NBODY),CLY(NBMAX,NBODY),CLZ(NBMAX,NBODY),          &
            ZBND(0:MLAYER),HVK(0:MLAYER),ZOBG(NZOB),ZSRG(2,NZSR),        &
            RRG(NRG),RRG3(NRG3),PSTION(6),RMU_LYR(MLAYER)
      INTEGER, INTENT(IN) :: SUB_RX_MAX,RX_TYPE_INDEX(M_RX,NTXE)
      REAL, INTENT(IN) :: RX_X(SUB_RX_MAX,M_RX,NTXE),        &
                          RX_Y(SUB_RX_MAX,M_RX,NTXE),        &
                          RX_Z(SUB_RX_MAX,M_RX,NTXE),        &
                          RX_WEIGHT(3,SUB_RX_MAX,M_RX,NTXE)
      INTEGER N_RX(NTXE),N_SUB_RX(M_RX,NTXE)
      COMPLEX ECOMP(9),HCOMP(9)
      EQUIVALENCE (ECOMP(1),EXX),(ECOMP(2),EYX),(ECOMP(3),EZX),   &
                  (ECOMP(4),EXY),(ECOMP(5),EYY),(ECOMP(6),EZY),   &
                  (ECOMP(7),EXZ),(ECOMP(8),EYZ),(ECOMP(9),EZZ),   &
                  (HCOMP(1),HXX),(HCOMP(2),HYX),(HCOMP(3),HZX),   &
                  (HCOMP(4),HXY),(HCOMP(5),HYY),(HCOMP(6),HZY),   &
                  (HCOMP(7),HXZ),(HCOMP(8),HYZ),(HCOMP(9),HZZ)
!
      REAL :: LX,LY,LZ,C_INT,RX_XX,RX_YY,RX_ZZ,RMU
      INTEGER :: JJ,NOB
!
      KSELF=0
      KEYG=2
!
      DO II=1,N_RX(IEXCI)
!
!   --  The way stacking up sub-receivers is identical to those for 1D responses
!
         IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!    --     Note that receiver bipoles have been divided into sub-sections
!
            LX=RX_X(2,II,IEXCI)-RX_X(1,II,IEXCI)
            LY=RX_Y(2,II,IEXCI)-RX_Y(1,II,IEXCI)
            LZ=RX_Z(2,II,IEXCI)-RX_Z(1,II,IEXCI)
!
         END IF

         VLT(II)=(0.,0.)
         EAX(II)=(0.,0.)
         EAY(II)=(0.,0.)
         EAZ(II)=(0.,0.)
         HAX(II)=(0.,0.)
         HAY(II)=(0.,0.)
         HAZ(II)=(0.,0.)
!
         DO KK=1,N_SUB_RX(II,IEXCI)
!
            RX_XX=RX_X(KK,II,IEXCI)
            RX_YY=RX_Y(KK,II,IEXCI)
            RX_ZZ=RX_Z(KK,II,IEXCI)
!
!  --  EX etc are used to sum the contributions of the cells
            EX=(0.,0.)
            EY=(0.,0.)
            EZ=(0.,0.)
            HX=(0.,0.)
            HY=(0.,0.)
            HZ=(0.,0.)
!
!    --  Set outcrop (or receive on or within target) to 0
            KUTCRP=0
!
            DO IB=1,NBODY
               NJ=0
               DO L=1,SUB_BLOCK(IB)
                  IF (L>1) NJ=NJ+3*NCELL(L-1,IB)
                  DO I=1,NX(L,IB)
                  DO J=1,NY(L,IB)
                  DO K=1,NZ(L,IB)
                     IF (RX_XX>=X(I,L,IB)-.5*CLX(L,IB)          &
                         -.01.AND.RX_XX<X(I,L,IB)               &
                         +.5*CLX(L,IB)+.01.AND.RX_YY            &
                         >=Y(J,L,IB)-.5*CLY(L,IB)-.01.AND.      &
                         RX_YY<Y(J,L,IB)+.5*CLY(L,IB)           &
                         +.01.AND.RX_ZZ>=Z(K,L,IB)              &
                         -.5*CLZ(L,IB)-.01.AND.RX_ZZ            &
                         <Z(K,L,IB)+.5*CLZ(L,IB)+.01) THEN
                        KUTCRP=1
                        N1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)+K
                           N2=(N1-1)*3+1+NJ
!
! ---- Determine the E-field (scattered) within a
!      cell by the scattering current directly
!
                        EX=JS(N2,IB)/(CDB(N1,L,IB)-CDH(1))-ENX(II,IEXCI)
                        EY=JS(N2+1,IB)/(CDB(N1,L,IB)-CDH(1))-ENY(II,IEXCI)
                        EZ=JS(N2+2,IB)/(CDB(N1,L,IB)-CDV(1))-ENZ(II,IEXCI)
                        GOTO 50
                     END IF
                  END DO
                  END DO
                  END DO
               END DO
            END DO
!
   50       DO IB=1,NBODY
!
               CLMN2=CLMN(IB)
!
               NJS=0
               DO L=1,SUB_BLOCK(IB)
                  IF (L>1) NJS=NJS+3*NCELL(L-1,IB)
                  DO I=1,NX(L,IB)
                  DO J=1,NY(L,IB)
                  DO K=1,NZ(L,IB)
                     NN1=(I-1)*NY(L,IB)*NZ(L,IB)+(J-1)*NZ(L,IB)+K
                     NN=(NN1-1)*3+1+NJS

                     CLX1=CLX(L,IB)
                     CLY1=CLY(L,IB)
                     CLZ1=CLZ(L,IB)
!
                     PSTION(1)=RX_XX
                     PSTION(2)=RX_YY
                     PSTION(3)=RX_ZZ
                     PSTION(4)=X(I,L,IB)
                     PSTION(5)=Y(J,L,IB)
                     PSTION(6)=Z(K,L,IB)
                     CALL THR_D_GREEN(KEYG,PSTION,FRQ,MLAYER,ZBND,CDH,HVK,       &
                              NZOB,ZOBG,NZSR,ZSRG,RHOMIN,DMIN,                   &
                              NHFILM,RRG,NRG,GRHF,RRG3,NRG3,GRHF3,GRHO0,         &
                              GRHO03,CLX1,CLY1,CLZ1,CLMN2,KCLMN,BLMIN,KACC,      &
                              KUTCRP,KSELF,ECOMP,HCOMP)
!
                     IF (KUTCRP==0) THEN
                        EX=EX+(JS(NN,IB)*EXX+JS(NN+1,IB)*EXY+JS(NN+2,IB)*EXZ)
                        EY=EY+(JS(NN,IB)*EYX+JS(NN+1,IB)*EYY+JS(NN+2,IB)*EYZ)
                        EZ=EZ+(JS(NN,IB)*EZX+JS(NN+1,IB)*EZY+JS(NN+2,IB)*EZZ)
                     END IF
                     HX=HX+(JS(NN,IB)*HXX+JS(NN+1,IB)*HXY+JS(NN+2,IB)*HXZ)
                     HY=HY+(JS(NN,IB)*HYX+JS(NN+1,IB)*HYY+JS(NN+2,IB)*HYZ)
                     HZ=HZ+(JS(NN,IB)*HZX+JS(NN+1,IB)*HZY+JS(NN+2,IB)*HZZ)
                  END DO
                  END DO
                  END DO
               END DO
            END DO
!
            IF (RX_TYPE_INDEX(II,IEXCI)==3) THEN
!
!  --  Integrations along the receiver lines are similar to routines ONE_D_SOURCE
!      and ONE_D_LINE except for vertical lines.
!
!      Trapezoidal rule is used for simplicity
!
               IF (KK==1.or.KK==N_SUB_RX(II,IEXCI)) THEN
                  C_INT=.5
               ELSE
                  C_INT=1.
               END IF
               IF (ABS(LX)>=ABS(LY).AND.ABS(LX)>=ABS(LZ)) THEN
!       --        Integrate along X
                  VLT(II)=VLT(II)+(EX+EY*LY/LX+EZ*LZ/LX)*C_INT*LX
               ELSE IF (ABS(LY)>=ABS(LX).AND.ABS(LY)>=ABS(LZ)) THEN
!       --        Integrate along Y.
!                 Note that integration along Z is done
!                 analytically for strictly vertical receiver lines
                  VLT(II)=VLT(II)+(EY+EX*LX/LY+EZ*LZ/LY)*C_INT*LY
               ELSE
!       --        Integrate along Z.
!                 Note that integration along Z is done for receiver positions.
!                 This is different from routines ONE_D_SOURCE and ONE_D_LINE where
!                 strictly vertical transmitter lines are integrated analytically
!                 in the Hankel kernels.
                  VLT(II)=VLT(II)+(EZ+EX*LX/LZ+EY*LY/LZ)*C_INT*LZ
               END IF
!
            ELSE IF (RX_TYPE_INDEX(II,IEXCI)==2) THEN
!
!          --     Integrate loop receivers that are converted to magnetic dipole receivers
!
               HAX(II)=HAX(II)+HX*RX_WEIGHT(1,K,II,IEXCI)
               HAY(II)=HAY(II)+HY*RX_WEIGHT(2,K,II,IEXCI)
               HAZ(II)=HAZ(II)+HZ*RX_WEIGHT(3,K,II,IEXCI)
!
!  --- Convert H to B (single component)
!
!     -- Receiver layer
                  DO JJ=MLAYER-1,0,-1
                     IF (RX_ZZ>=ZBND(JJ)) THEN
                        NOB=JJ+1
                        GOTO 55
                     END IF
                  END DO
                  NOB=0
               55 CONTINUE
                  IF (NOB==0) THEN
                     RMU=1.
                  ELSE
                     RMU=RMU_LYR(NOB)
                  END IF
!
               RMU=RMU*4.*3.1415926E-7
               VLT(II)=(HAX(II)+HAY(II)+HAZ(II))*RMU
!
            ELSE
!
!       --     Magnetic dipole receivers (only one sub-receiver)
!              Electric components are also computed thought they are not used.
!
!              Electric component may not be used in this particular version
               EAX(II)=EAX(II)+EX
               EAY(II)=EAY(II)+EY
               EAZ(II)=EAZ(II)+EZ
!
!  --- Convert H to B
!
!     -- Receiver layer
               DO JJ=MLAYER-1,0,-1
                  IF (RX_ZZ>=ZBND(JJ)) THEN
                     NOB=JJ+1
                     GOTO 56
                  END IF
               END DO
               NOB=0
            56 CONTINUE
               IF (NOB==0) THEN
                  RMU=1.
               ELSE
                  RMU=RMU_LYR(NOB)
               END IF
               RMU=RMU*4.*3.1415926E-7
               HAX(II)=HAX(II)+HX*RMU
               HAY(II)=HAY(II)+HY*RMU
               HAZ(II)=HAZ(II)+HZ*RMU
!
            END IF
!
         END DO
!
      END DO
!
      RETURN
      END
!
!
   SUBROUTINE HFILL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KITG,   &
                    KCHRG,NOB,NSR,RLO,RHI,ZOB,ZSRH,ZSRL,NRG,RRG,HF,NHFILM)
!
!****  HANKEL TRANSFORMATIONS BY DIGITAL LINEAR FILTERING
!      for computing normal responses
!
!      The filters used here yield an accuracy of about 0.4E-8.
!
!      This routine is based on a filtering routine provided by
!      N. Christensen.  Though the routine has been restructured,
!      it still retains the basic original designs of Christensen
!      because of their efficience.
!
!   Input parameters:
!
!      RLO:  real (*4), minimum of rho.
!      RHI:  real     , maximumof rho.
!
!      The parameters KEMD, MLAYER, ZBND, LRYTH, HVK, KKH, KANIS, KPRM,
!      KITG, KCHRG, NOB, NSR, ZOB,  ZSRH and ZSRL are to be passed
!      to routine kernel.  See routine kernel for their descriptions.
!
!
!   Output parameters:
!
!      NRG:  integer (*4), number of data point returned.
!      RRG:  real RRG(nhfil), the discrete values of rho on
!            logrithmic scale on which results of the Hankel
!            transforms are returned.
!      HF:   complex(11,nhfil), the nhfil columns of the
!            11 components of the Hankel transforms of the
!            Green's tensors.  Note that the values contained
!            in HF must be divided by rho in order to get the
!            actual Hankel transforms.
!
!****  CALLED by:  gridhf, gridcs
!
!****  CALLS    :  kernel
!
!
!
      IMPLICIT NONE
!
      INTEGER, PARAMETER :: NHFILM_MAX=91
!
      INTEGER, INTENT(IN) :: KEYG,KEMD,MLAYER,KANIS,KPRM,KITG,KCHRG,NOB,NSR,NHFILM
      INTEGER, INTENT(OUT) :: NRG
      REAL, INTENT(IN) :: RLO,RHI
      REAL, INTENT(OUT) :: RRG(NHFILM)
      COMPLEX, INTENT(inOUT) :: HF(11,NHFILM)
!      COMPLEX, INTENT(OUT) :: HF(11,NHFILM)
!
      INTEGER ::  NC(NHFILM_MAX),INR(491),NLO,NHI,NF,I0F,I0G,IGSH,   &
                  NLIM,KRHO
      REAL :: FILT0(401),FILT1(401),DEL,R1,E,R
      COMPLEX :: FC0(5,491),FC1(6,491),                     &
                 SUM0(5),SUM1(6),SDEL0(5),SDEL1(6),FKN(11)
      COMMON /J0BLK/FILT0 /J1BLK/FILT1
!
      REAL, PARAMETER :: EPS=1.E-9
      REAL :: X
      INTEGER ::  I,IG,IJ,J,K
!
!  -- Parameters to be passed to the routine kernel
!
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER)
      REAL, INTENT(IN) :: LRYTH(MLAYER),HVK(0:MLAYER),ZBND(0:MLAYER),   &
                          ZOB,ZSRH,ZSRL
!
!  -- Check if NFHILM exceeds design limit of 91 (for lateral maximal distance of
!     100 km using 15-per-decade filters)
!
      IF (NHFILM>NHFILM_MAX) WRITE (*,'(A)')  &
         '*** WARNING: model geometry exceeds design limit of 100 km!  Results may not be accurate!'
!
!  -- Initialise FKN to avoid compiler errors for some compilers
!
      FKN=(0.,0.)
!
!  -- Parameter KRHO is required by routine ONE_D_KERNEL.
!     KRHO=1 means rho (or R in this routine) .ne. zero
!
      KRHO=1
!
!  -- Inititalizations
!
!     NLO, NHI, NRG, R1,  and E are determined by DEL,  RLO,  and RHI
!
      DEL=ALOG(10.)/15.
      NLO=INT(ALOG(RLO)/DEL+100.)-101
      IF (NLO<-15) NLO=-15
      NHI=INT(ALOG(RHI)/DEL+100.)-98
      IF (NHI>75) NHI=75
      NRG=NHI-NLO+1
      R1=EXP(FLOAT(NLO)*DEL)
      E=EXP(DEL)
!
!  --  NG=491 is the dimension of the arrays INR, FC0,  and FC1
!
      NLIM=60; NF=401; I0F=251; I0G=326; INR=-1
!
      R=R1/E
      IGSH=INT(ALOG(R)/DEL+100.5)-100
!
      R_loop:  DO K=1,NRG   !  This loop computes the discreted values of
                            !  the Hankel integrals at discreted points of
                            !  R on a logarithmic scale determined by DEL.
                            !  All transforms are returned simultaneously.
!
         R=R*E
!
! --- The evaluation of IGSH has been moved to the top of the do loop
!     since the value of R may not be very accurate if it is large.
!        IGSH=INT(ALOG(R)/DEL+100.5)-100
!
         IGSH=IGSH+1
!
         X=E/R*EXP(-0.141555714)     ! To be exact: EXP(-0.1415557141054993)
         SUM0=(0.,0.);  SUM1=(0.,0.)
!
         Lower_convolution_loop:  DO I=1,NF
!
            IJ=I0F-I+1
!
! --- Calculation of convolution, arg. of kernel to zero
!
!   -- Check for limits to convolution, arg. of kernel to zero.
!      Exit if the IJ runs out of the filters range
!
            IF (IJ<1) THEN
!
!               WRITE (4,111) R
!
!**** EXIT lower convolution loop due to exhaustion of filters
!
               EXIT
!
            END IF
!
            X=X/E
            IG=I0G-IGSH-I+1
            IF (INR(IG)<0) THEN
               CALL ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS, &
                         KPRM,KRHO,KITG,KCHRG,NOB,NSR,ZOB,(ZSRH+ZSRL)/2.,   &
                         ZSRH,ZSRL,X,FKN)
               FC0(1:3,IG)=FKN(1:3)
               FC0(4:5,IG)=FKN(7:8)
               FC1(1:3,IG)=FKN(4:6)
               FC1(4:6,IG)=FKN(9:11)
               INR(IG)=1
            END IF
!
            DO J=1,5
               SDEL0(J)=FILT0(IJ)*FC0(J,IG)
               SDEL1(J)=FILT1(IJ)*FC1(J,IG)
               SUM0(J)=SUM0(J)+SDEL0(J)
               SUM1(J)=SUM1(J)+SDEL1(J)
            END DO
            SDEL1(6)=FILT1(IJ)*FC1(6,IG)
            SUM1(6)=SUM1(6)+SDEL1(6)
!
            IF (I>NLIM) THEN
               DO J=1,5
!
! --- Use 1.E-28 so that its product with EPS is larger
!     than 1.E-38 to avoid possible problems on some machines
!
                  IF (ABS(SDEL0(J))>(1.E-28+ABS(SUM0(J)))*EPS) GOTO 50
                  IF (ABS(SDEL1(J))>(1.E-28+ABS(SUM1(J)))*EPS) GOTO 50
               END DO
               IF (ABS(SDEL1(6))>(1.E-28+ABS(SUM1(6)))*EPS) GOTO 50
!
!****   Proper EXIT of lower convolution loop upon convergence
!
               EXIT
!
            END IF
!
   50    END DO Lower_convolution_loop
!
         NC(K)=I
!
! --- Calculation of convolution, arg. of kernel to infinity
!
         X=1./R*EXP(-0.141555714)    ! To be exact: EXP(-0.1415557141054993)
!
         Upper_convolution_loop:  DO I=1,NF
!
            IJ=I0F+I
!
! --- Check for limits to convolution, arg. of kernel to infinity.
!     Exit if the IJ runs out of the filters range
!
            IF (IJ>NF) THEN
!
!               WRITE (4,222) R
!
!****   EXIT upper convolution loop due to exhaustion of filters
!
               EXIT
!
            END IF
!
            X=X*E
            IG=I0G-IGSH+I
            IF (INR(IG)<0) THEN
               CALL ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,  &
                         KPRM,KRHO,KITG,KCHRG,NOB,NSR,ZOB,(ZSRH+ZSRL)/2.,    &
                         ZSRH,ZSRL,X,FKN)
               FC0(1:3,IG)=FKN(1:3)
               FC0(4:5,IG)=FKN(7:8)
               FC1(1:3,IG)=FKN(4:6)
               FC1(4:6,IG)=FKN(9:11)
               INR(IG)=1
            END IF
!
            DO J=1,5
               SDEL0(J)=FILT0(IJ)*FC0(J,IG)
               SDEL1(J)=FILT1(IJ)*FC1(J,IG)
               SUM0(J)=SUM0(J)+SDEL0(J)
               SUM1(J)=SUM1(J)+SDEL1(J)
            END DO
            SDEL1(6)=FILT1(IJ)*FC1(6,IG)
            SUM1(6)=SUM1(6)+SDEL1(6)
!
            DO J=1,5
               IF (ABS(SDEL0(J))>(1.E-28+ABS(SUM0(J)))*EPS) GOTO 100
               IF (ABS(SDEL1(J))>(1.E-28+ABS(SUM1(J)))*EPS) GOTO 100
            END DO
            IF (ABS(SDEL1(6))>(1.E-28+ABS(SUM1(6)))*EPS) GOTO 100
!
!****   Proper EXIT of upper convolution loop upon convergence
!
            EXIT
!
  100    END DO Upper_convolution_loop
!
         NC(K)=NC(K)+I
!
         HF(1:3,K)=SUM0(1:3)
         HF(7:8,K)=SUM0(4:5)
         HF(4:6,K)=SUM1(1:3)
         HF(9:11,K)=SUM1(4:6)
!
         RRG(K)=R
!
      END DO R_loop
!
      RETURN
!
!  111    FORMAT (1X,'Convolution truncated for argument of kernel ',
!       'function going towards zero',/,'for distance ',F11.3,' M')
!  222    FORMAT (1X,'Convolution truncated for argument of kernel ',
!     'function going towards infinity',/,'for distance ',F11.3,' M')
!
   END SUBROUTINE HFILL
!
!
!     B L O C K   D A T A   J 0 C O E F
!
!     BLOCK DATA J0COF CONTAINS THE FILTERCOEFFICIENTS OF THE
!     J0 TRANSFORM USED IN THE SUBROUTINE HFIL
!
!     15-per-decade filters for an opening angle of analyticity
!     of 0.32 pi with an optimized shift of 0.1415557141054993.
!
!     Accuracy of the filter: 0.4001E-08
!
!
      BLOCK DATA J0COF
      REAL :: FILT0(401),J01(76),J02(76),J03(76),J04(76),J05(76),   &
                    J06(21)
      EQUIVALENCE (FILT0(1),J01(1)),(FILT0(77),J02(1)),   &
                (FILT0(153),J03(1)),(FILT0(229),J04(1)),   &
                (FILT0(305),J05(1)),(FILT0(381),J06(1))
      COMMON /J0BLK/ FILT0
!
      DATA J01 /   &
     2.87065431E-18, 3.34693720E-18, 3.90224228E-18, 4.54968047E-18,   &
     5.30453798E-18, 6.18463723E-18, 7.21075761E-18, 8.40712614E-18,   &
     9.80198944E-18, 1.14282806E-17, 1.33243970E-17, 1.55351063E-17,   &
     1.81126042E-17, 2.11177461E-17, 2.46214843E-17, 2.87065431E-17,   &
     3.34693720E-17, 3.90224228E-17, 4.54968047E-17, 5.30453798E-17,   &
     6.18463723E-17, 7.21075761E-17, 8.40712614E-17, 9.80198944E-17,   &
     1.14282806E-16, 1.33243970E-16, 1.55351063E-16, 1.81126042E-16,   &
     2.11177461E-16, 2.46214843E-16, 2.87065431E-16, 3.34693720E-16,   &
     3.90224228E-16, 4.54968047E-16, 5.30453798E-16, 6.18463723E-16,   &
     7.21075761E-16, 8.40712614E-16, 9.80198944E-16, 1.14282806E-15,   &
     1.33243970E-15, 1.55351063E-15, 1.81126042E-15, 2.11177461E-15,   &
     2.46214843E-15, 2.87065431E-15, 3.34693720E-15, 3.90224228E-15,   &
     4.54968047E-15, 5.30453798E-15, 6.18463723E-15, 7.21075761E-15,   &
     8.40712614E-15, 9.80198944E-15, 1.14282806E-14, 1.33243970E-14,   &
     1.55351063E-14, 1.81126042E-14, 2.11177461E-14, 2.46214843E-14,   &
     2.87065431E-14, 3.34693720E-14, 3.90224228E-14, 4.54968047E-14,   &
     5.30453798E-14, 6.18463723E-14, 7.21075761E-14, 8.40712614E-14,   &
     9.80198944E-14, 1.14282806E-13, 1.33243970E-13, 1.55351063E-13,   &
     1.81126042E-13, 2.11177461E-13, 2.46214843E-13, 2.87065431E-13/
      DATA J02 /   &
     3.34693720E-13, 3.90224228E-13, 4.54968047E-13, 5.30453798E-13,   &
     6.18463723E-13, 7.21075761E-13, 8.40712614E-13, 9.80198944E-13,   &
     1.14282806E-12, 1.33243970E-12, 1.55351063E-12, 1.81126042E-12,   &
     2.11177461E-12, 2.46214843E-12, 2.87065431E-12, 3.34693720E-12,   &
     3.90224228E-12, 4.54968047E-12, 5.30453798E-12, 6.18463723E-12,   &
     7.21075761E-12, 8.40712614E-12, 9.80198944E-12, 1.14282806E-11,   &
     1.33243970E-11, 1.55351063E-11, 1.81126042E-11, 2.11177461E-11,   &
     2.46214843E-11, 2.87065431E-11, 3.34693720E-11, 3.90224228E-11,   &
     4.54968047E-11, 5.30453798E-11, 6.18463723E-11, 7.21075761E-11,   &
     8.40712614E-11, 9.80198944E-11, 1.14282806E-10, 1.33243970E-10,   &
     1.55351063E-10, 1.81126042E-10, 2.11177461E-10, 2.46214843E-10,   &
     2.87065431E-10, 3.34693720E-10, 3.90224228E-10, 4.54968047E-10,   &
     5.30453798E-10, 6.18463723E-10, 7.21075761E-10, 8.40712614E-10,   &
     9.80198944E-10, 1.14282806E-09, 1.33243970E-09, 1.55351063E-09,   &
     1.81126042E-09, 2.11177461E-09, 2.46214843E-09, 2.87065431E-09,   &
     3.34693720E-09, 3.90224228E-09, 4.54968047E-09, 5.30453798E-09,   &
     6.18463723E-09, 7.21075761E-09, 8.40712614E-09, 9.80198944E-09,   &
     1.14282806E-08, 1.33243970E-08, 1.55351063E-08, 1.81126042E-08,   &
     2.11177461E-08, 2.46214843E-08, 2.87065431E-08, 3.34693720E-08/
      DATA J03 /   &
     3.90224228E-08, 4.54968047E-08, 5.30453798E-08, 6.18463723E-08,   &
     7.21075761E-08, 8.40712614E-08, 9.80198944E-08, 1.14282806E-07,   &
     1.33243970E-07, 1.55351063E-07, 1.81126042E-07, 2.11177461E-07,   &
     2.46214843E-07, 2.87065431E-07, 3.34693720E-07, 3.90224228E-07,   &
     4.54968047E-07, 5.30453798E-07, 6.18463723E-07, 7.21075761E-07,   &
     8.40712614E-07, 9.80198944E-07, 1.14282806E-06, 1.33243970E-06,   &
     1.55351063E-06, 1.81126042E-06, 2.11177461E-06, 2.46214843E-06,   &
     2.87065431E-06, 3.34693720E-06, 3.90224228E-06, 4.54968047E-06,   &
     5.30453798E-06, 6.18463722E-06, 7.21075761E-06, 8.40712613E-06,   &
     9.80198943E-06, 1.14282806E-05, 1.33243970E-05, 1.55351063E-05,   &
     1.81126041E-05, 2.11177460E-05, 2.46214841E-05, 2.87065428E-05,   &
     3.34693716E-05, 3.90224222E-05, 4.54968037E-05, 5.30453783E-05,   &
     6.18463698E-05, 7.21075721E-05, 8.40712551E-05, 9.80198844E-05,   &
     1.14282791E-04, 1.33243945E-04, 1.55351024E-04, 1.81125979E-04,   &
     2.11177361E-04, 2.46214684E-04, 2.87065180E-04, 3.34693322E-04,   &
     3.90223598E-04, 4.54967048E-04, 5.30452215E-04, 6.18461213E-04,   &
     7.21071783E-04, 8.40706310E-04, 9.80188952E-04, 1.14281223E-03,   &
     1.33241460E-03, 1.55347086E-03, 1.81119738E-03, 2.11167469E-03,   &
     2.46199007E-03, 2.87040334E-03, 3.34653944E-03, 3.90161188E-03/
      DATA J04 /   &
     4.54868137E-03, 5.30295454E-03, 6.18212771E-03, 7.20678044E-03,   &
     8.40082307E-03, 9.79200041E-03, 1.14124506E-02, 1.32993111E-02,   &
     1.54953546E-02, 1.80496165E-02, 2.10179485E-02, 2.44633830E-02,   &
     2.84561142E-02, 3.30727806E-02, 3.83945388E-02, 4.45031197E-02,   &
     5.14736016E-02, 5.93619503E-02, 6.81843807E-02, 7.78842097E-02,   &
     8.82800769E-02, 9.89874216E-02, 1.09303673E-01, 1.18048811E-01,   &
     1.23361519E-01, 1.22476901E-01, 1.11572863E-01, 8.58971633E-02,   &
     4.06059055E-02,-2.69568319E-02,-1.12628810E-01,-1.98185246E-01,   &
    -2.44343000E-01,-1.94732733E-01,-1.24397970E-02, 2.35873580E-01,   &
     3.12450410E-01,-9.44123562E-03,-3.87660057E-01, 4.49548570E-03,   &
     4.13817274E-01,-4.18831226E-01, 2.40369307E-01,-1.00474404E-01,   &
     3.41489331E-02,-1.00624245E-02, 2.68559099E-03,-6.73153626E-04,   &
     1.63267246E-04,-3.90482717E-05, 9.28958411E-06,-2.20560148E-06,   &
     5.23277296E-07,-1.24112646E-07, 2.94349396E-08,-6.98103957E-09,   &
     1.65593565E-09,-3.92966591E-10, 9.33610703E-11,-2.22470443E-11,   &
     5.34223603E-12,-1.30809232E-12, 3.35731723E-13,-9.54220365E-14,   &
     3.24134978E-14,-1.37441203E-14, 7.00930351E-15,-3.98362871E-15,   &
     2.38179010E-15,-1.45447107E-15, 8.95658593E-16,-5.53328136E-16,   &
     3.42267983E-16,-2.11819831E-16, 1.31113348E-16,-8.11613944E-17/
      DATA J05 /   &
     5.02435622E-17,-3.11033761E-17, 1.92543144E-17,-1.19194862E-17,   &
     7.37882574E-18,-4.56781773E-18, 2.82773434E-18,-1.75052547E-18,   &
     1.08367304E-18,-6.70841339E-19, 4.15288250E-19,-2.57086605E-19,   &
     1.59144885E-19,-9.85214433E-20, 6.09902700E-20,-3.77563781E-20,   &
     2.33724121E-20,-1.44688262E-20, 8.95718061E-21,-5.54478256E-21,   &
     3.43252926E-21,-2.12492682E-21, 1.31542300E-21,-8.14320058E-22,   &
     5.04109447E-22,-3.12071796E-22, 1.93186129E-22,-1.19592958E-22,   &
     7.40346923E-23,-4.58307182E-23, 2.83717624E-23,-1.75636974E-23,   &
     1.08726976E-23,-6.73080403E-24, 4.16674143E-24,-2.57944426E-24,   &
     1.59675850E-24,-9.88482145E-25, 6.11925287E-25,-3.78815693E-25,   &
     2.34507926E-25,-1.45173411E-25, 8.98703877E-26,-5.56326389E-26,   &
     3.44396857E-26,-2.13200736E-26, 1.31983062E-26,-8.17048271E-27,   &
     5.05798105E-27,-3.13105129E-27, 1.93829404E-27,-1.19991126E-27,   &
     7.42783257E-28,-4.59823919E-28, 2.84656426E-28,-1.76218064E-28,   &
     1.09092857E-28,-6.75345043E-29, 4.18044194E-29,-2.58802253E-29,   &
     1.60212885E-29,-9.91806183E-30, 6.13982768E-30,-3.80089214E-30,   &
     2.35278363E-30,-1.45650281E-30, 9.01655563E-31,-5.58174493E-31,   &
     3.45540779E-31,-2.13916879E-31, 1.32426333E-31,-8.19729908E-32,   &
     5.07457960E-32,-3.14144410E-32, 1.94472683E-32,-1.20389291E-32/
      DATA J06 /   &
     7.45275953E-33,-4.61366813E-33, 2.85600623E-33,-1.76802491E-33,   &
     1.09450461E-33,-6.77558513E-34, 4.19445951E-34,-2.59660080E-34,   &
     1.60743847E-34,-9.95055086E-35, 6.15993712E-35,-3.81333929E-35,   &
     2.36066622E-35,-1.46138190E-35, 9.04675557E-36,-5.60022625E-36,   &
     3.46684701E-36,-2.14616839E-36, 1.32859582E-36,-8.22473604E-37,   &
     5.09156200E-37/
!
   END BLOCK DATA J0COF
!
!
!     B L O C K   D A T A   J 1 C O E F
!
!     BLOCK DATA J1COF CONTAINS THE FILTERCOEFFICIENTS OF THE
!     J1 TRANSFORM USED IN THE SUBROUTINE HFIL
!
!     15-per-decade filters for an opening angle of analyticity
!     of 0.32 pi with a shift of 0.1415557141054993 optimized
!     for the Jo fitlers.
!
!     Accuracy of the filters: 0.8001E-07
!
      BLOCK DATA J1COF
      REAL :: FILT1(401),J11(76),J12(76),J13(76),J14(76),J15(76),   &
                    J16(21)
      EQUIVALENCE (FILT1(1),J11(1)),(FILT1(77),J12(1)),   &
                (FILT1(153),J13(1)),(FILT1(229),J14(1)),   &
                (FILT1(305),J15(1)),(FILT1(381),J16(1))
      COMMON /J1BLK/ FILT1
!
      DATA J11 /   &
     2.68415363E-35, 3.64872140E-35, 4.95991275E-35, 6.74228909E-35,   &
     9.16517377E-35, 1.24587375E-34, 1.69358645E-34, 2.30218756E-34,   &
     3.12949338E-34, 4.25409682E-34, 5.78283370E-34, 7.86093195E-34,   &
     1.06858081E-33, 1.45258215E-33, 1.97457683E-33, 2.68415363E-33,   &
     3.64872140E-33, 4.95991275E-33, 6.74228909E-33, 9.16517377E-33,   &
     1.24587375E-32, 1.69358645E-32, 2.30218756E-32, 3.12949338E-32,   &
     4.25409682E-32, 5.78283370E-32, 7.86093195E-32, 1.06858081E-31,   &
     1.45258215E-31, 1.97457683E-31, 2.68415363E-31, 3.64872140E-31,   &
     4.95991275E-31, 6.74228909E-31, 9.16517377E-31, 1.24587375E-30,   &
     1.69358645E-30, 2.30218756E-30, 3.12949338E-30, 4.25409682E-30,   &
     5.78283370E-30, 7.86093195E-30, 1.06858081E-29, 1.45258215E-29,   &
     1.97457683E-29, 2.68415363E-29, 3.64872140E-29, 4.95991275E-29,   &
     6.74228909E-29, 9.16517377E-29, 1.24587375E-28, 1.69358645E-28,   &
     2.30218756E-28, 3.12949338E-28, 4.25409682E-28, 5.78283370E-28,   &
     7.86093195E-28, 1.06858081E-27, 1.45258215E-27, 1.97457683E-27,   &
     2.68415363E-27, 3.64872140E-27, 4.95991275E-27, 6.74228909E-27,   &
     9.16517377E-27, 1.24587375E-26, 1.69358645E-26, 2.30218756E-26,   &
     3.12949338E-26, 4.25409682E-26, 5.78283370E-26, 7.86093195E-26,   &
     1.06858081E-25, 1.45258215E-25, 1.97457683E-25, 2.68415363E-25/
      DATA J12 /   &
     3.64872140E-25, 4.95991275E-25, 6.74228909E-25, 9.16517377E-25,   &
     1.24587375E-24, 1.69358645E-24, 2.30218756E-24, 3.12949338E-24,   &
     4.25409682E-24, 5.78283370E-24, 7.86093195E-24, 1.06858081E-23,   &
     1.45258215E-23, 1.97457683E-23, 2.68415363E-23, 3.64872140E-23,   &
     4.95991275E-23, 6.74228909E-23, 9.16517377E-23, 1.24587375E-22,   &
     1.69358645E-22, 2.30218756E-22, 3.12949338E-22, 4.25409682E-22,   &
     5.78283370E-22, 7.86093195E-22, 1.06858081E-21, 1.45258215E-21,   &
     1.97457683E-21, 2.68415363E-21, 3.64872140E-21, 4.95991275E-21,   &
     6.74228909E-21, 9.16517377E-21, 1.24587375E-20, 1.69358645E-20,   &
     2.30218756E-20, 3.12949338E-20, 4.25409682E-20, 5.78283370E-20,   &
     7.86093195E-20, 1.06858081E-19, 1.45258215E-19, 1.97457683E-19,   &
     2.68415363E-19, 3.64872140E-19, 4.95991275E-19, 6.74228909E-19,   &
     9.16517377E-19, 1.24587375E-18, 1.69358645E-18, 2.30218756E-18,   &
     3.12949338E-18, 4.25409682E-18, 5.78283370E-18, 7.86093195E-18,   &
     1.06858081E-17, 1.45258215E-17, 1.97457683E-17, 2.68415363E-17,   &
     3.64872140E-17, 4.95991275E-17, 6.74228909E-17, 9.16517377E-17,   &
     1.24587375E-16, 1.69358645E-16, 2.30218756E-16, 3.12949338E-16,   &
     4.25409682E-16, 5.78283370E-16, 7.86093195E-16, 1.06858081E-15,   &
     1.45258215E-15, 1.97457683E-15, 2.68415363E-15, 3.64872140E-15/
      DATA J13 /   &
     4.95991275E-15, 6.74228909E-15, 9.16517377E-15, 1.24587375E-14,   &
     1.69358645E-14, 2.30218756E-14, 3.12949338E-14, 4.25409682E-14,   &
     5.78283370E-14, 7.86093195E-14, 1.06858081E-13, 1.45258215E-13,   &
     1.97457683E-13, 2.68415363E-13, 3.64872140E-13, 4.95991275E-13,   &
     6.74228909E-13, 9.16517376E-13, 1.24587375E-12, 1.69358645E-12,   &
     2.30218756E-12, 3.12949338E-12, 4.25409682E-12, 5.78283370E-12,   &
     7.86093196E-12, 1.06858081E-11, 1.45258215E-11, 1.97457683E-11,   &
     2.68415364E-11, 3.64872139E-11, 4.95991276E-11, 6.74228907E-11,   &
     9.16517379E-11, 1.24587375E-10, 1.69358646E-10, 2.30218755E-10,   &
     3.12949339E-10, 4.25409679E-10, 5.78283375E-10, 7.86093186E-10,   &
     1.06858082E-09, 1.45258213E-09, 1.97457686E-09, 2.68415357E-09,   &
     3.64872146E-09, 4.95991257E-09, 6.74228925E-09, 9.16517326E-09,   &
     1.24587379E-08, 1.69358631E-08, 2.30218763E-08, 3.12949297E-08,   &
     4.25409693E-08, 5.78283250E-08, 7.86093200E-08, 1.06858045E-07,   &
     1.45258208E-07, 1.97457575E-07, 2.68415318E-07, 3.64871807E-07,   &
     4.95991062E-07, 6.74227866E-07, 9.16516498E-07, 1.24587044E-06,   &
     1.69358305E-06, 2.30217687E-06, 3.12948076E-06, 4.25406197E-06,   &
     5.78278794E-06, 7.86081726E-06, 1.06856448E-05, 1.45254412E-05,   &
     1.97451926E-05, 2.68402673E-05, 3.64852005E-05, 4.95948712E-05/
      DATA J14 /   &
     6.74158915E-05, 9.16374058E-05, 1.24563151E-04, 1.69310235E-04,   &
     2.30135200E-04, 3.12785420E-04, 4.25122195E-04, 5.77727319E-04,   &
     7.85105978E-04, 1.06669197E-03, 1.44919742E-03, 1.96815477E-03,   &
     2.67256480E-03, 3.62687618E-03, 4.92028882E-03, 6.66798741E-03,   &
     9.02991900E-03, 1.22062442E-02, 1.64752875E-02, 2.21657575E-02,   &
     2.97327167E-02, 3.96513407E-02, 5.25658762E-02, 6.89409168E-02,   &
     8.93500131E-02, 1.13434944E-01, 1.40517821E-01, 1.66814097E-01,   &
     1.87264863E-01, 1.89364995E-01, 1.61060719E-01, 8.15845262E-02,   &
    -4.57409574E-02,-2.03869309E-01,-2.83167704E-01,-1.89808486E-01,   &
     1.51397346E-01, 3.39867954E-01, 5.39374572E-02,-4.74219029E-01,   &
     2.76081898E-01, 6.96051968E-02,-2.13923811E-01, 2.01080806E-01,   &
    -1.44372487E-01, 9.42258544E-02,-5.94817835E-02, 3.71071447E-02,   &
    -2.30417725E-02, 1.42803764E-02,-8.84350132E-03, 5.47488643E-03,   &
    -3.38902013E-03, 2.09774759E-03,-1.29844829E-03, 8.03698482E-04,   &
    -4.97462689E-04, 3.07912591E-04,-1.90587414E-04, 1.17967105E-04,   &
    -7.30176085E-05, 4.51954044E-05,-2.79744107E-05, 1.73152040E-05,   &
    -1.07175195E-05, 6.63377821E-06,-4.10608196E-06, 2.54152438E-06,   &
    -1.57311672E-06, 9.73705480E-07,-6.02690410E-07, 3.73044763E-07,   &
    -2.30901957E-07, 1.42920419E-07,-8.84628542E-08, 5.47554830E-08/
      DATA J15 /   &
    -3.38917724E-08, 2.09778486E-08,-1.29845713E-08, 8.03700578E-09,   &
    -4.97463186E-09, 3.07912709E-09,-1.90587442E-09, 1.17967112E-09,   &
    -7.30176101E-10, 4.51954048E-10,-2.79744108E-10, 1.73152041E-10,   &
    -1.07175195E-10, 6.63377821E-11,-4.10608196E-11, 2.54152438E-11,   &
    -1.57311672E-11, 9.73705480E-12,-6.02690410E-12, 3.73044763E-12,   &
    -2.30901957E-12, 1.42920419E-12,-8.84628542E-13, 5.47554830E-13,   &
    -3.38917724E-13, 2.09778486E-13,-1.29845713E-13, 8.03700578E-14,   &
    -4.97463186E-14, 3.07912709E-14,-1.90587442E-14, 1.17967112E-14,   &
    -7.30176101E-15, 4.51954048E-15,-2.79744108E-15, 1.73152041E-15,   &
    -1.07175195E-15, 6.63377821E-16,-4.10608196E-16, 2.54152438E-16,   &
    -1.57311672E-16, 9.73705480E-17,-6.02690410E-17, 3.73044763E-17,   &
    -2.30901957E-17, 1.42920419E-17,-8.84628542E-18, 5.47554830E-18,   &
    -3.38917724E-18, 2.09778486E-18,-1.29845713E-18, 8.03700578E-19,   &
    -4.97463186E-19, 3.07912709E-19,-1.90587442E-19, 1.17967112E-19,   &
    -7.30176101E-20, 4.51954048E-20,-2.79744108E-20, 1.73152041E-20,   &
    -1.07175195E-20, 6.63377821E-21,-4.10608196E-21, 2.54152438E-21,   &
    -1.57311672E-21, 9.73705480E-22,-6.02690410E-22, 3.73044763E-22,   &
    -2.30901957E-22, 1.42920419E-22,-8.84628542E-23, 5.47554830E-23,   &
    -3.38917724E-23, 2.09778486E-23,-1.29845713E-23, 8.03700578E-24/
      DATA J16 /   &
    -4.97463186E-24, 3.07912709E-24,-1.90587442E-24, 1.17967112E-24,   &
    -7.30176101E-25, 4.51954048E-25,-2.79744108E-25, 1.73152041E-25,   &
    -1.07175195E-25, 6.63377821E-26,-4.10608196E-26, 2.54152438E-26,   &
    -1.57311672E-26, 9.73705480E-27,-6.02690410E-27, 3.73044763E-27,   &
    -2.30901957E-27, 1.42920419E-27,-8.84628542E-28, 5.47554830E-28,   &
    -3.38917724E-28/

!
   END BLOCK DATA J1COF
!
!
   SUBROUTINE HFILH(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,KPRM,KITG,   &
                    KCHRG,NOB,NSR,RLO,RHI,ZOB,ZSRH,ZSRL,NRG,RRG,HF,NHFILM)
!
!****  HANKEL TRANSFORMATIONS BY DIGITAL LINEAR FILTERING
!      for computing normal responses
!
!      The filters used here yield an accuracy of about 0.4E-8.
!
!      This routine is based on a filtering routine provided by
!      N. Christensen.  Though the routine has been restructured,
!      it still retains the basic original designs of Christensen
!      because of their efficience.
!
!   Input parameters:
!
!      RLO:  real (*4), minimum of rho.
!      RHI:  real     , maximumof rho.
!
!      The parameters KEMD, MLAYER, ZBND, LRYTH, HVK, KKH, KANIS, KPRM,
!      KITG, KCHRG, NOB, NSR, ZOB,  ZSRH and ZSRL are to be passed
!      to routine kernel.  See routine kernel for their descriptions.
!
!
!   Output parameters:
!
!      NRG:  integer (*4), number of data point returned.
!      RRG:  real RRG(nhfil), the discrete values of rho on
!            logrithmic scale on which results of the Hankel
!            transforms are returned.
!      HF:   complex(11,nhfil), the nhfil columns of the
!            11 components of the Hankel transforms of the
!            Green's tensors.  Note that the values contained
!            in HF must be divided by rho in order to get the
!            actual Hankel transforms.
!
!****  CALLED by:  gridhf, gridcs
!
!****  CALLS    :  kernel
!
!
!
      IMPLICIT NONE
!
      INTEGER, PARAMETER :: NHFILM_MAX=301
!
      INTEGER, INTENT(IN) :: KEYG,KEMD,MLAYER,KANIS,KPRM,KITG,KCHRG,NOB,NSR,NHFILM
      INTEGER, INTENT(OUT) :: NRG
      REAL, INTENT(IN) :: RLO,RHI
      REAL, INTENT(OUT) :: RRG(NHFILM)
      COMPLEX, INTENT(OUT) :: HF(11,NHFILM)
!
      INTEGER ::  NC(NHFILM_MAX),INR(1001),NLO,NHI,NF,I0F,I0G,IGSH,   &
                  NLIM,KRHO
      REAL :: FILT0(600),FILT1(600),DEL,R1,E,R
      COMPLEX :: FC0(5,1001),FC1(6,1001),                         &
                 SUM0(5),SUM1(6),SDEL0(5),SDEL1(6),FKN(11)
      COMMON /J0BLK2/FILT0 /J1BLK2/FILT1
!
      REAL, PARAMETER :: EPS=1.E-7
      REAL :: X
      INTEGER ::  I,IG,IJ,J,K
!
!  -- Parameters to be passed to the routine kernel
!
      COMPLEX, INTENT(IN) :: KKH(0:MLAYER)
      REAL, INTENT(IN) :: LRYTH(MLAYER),HVK(0:MLAYER),ZBND(0:MLAYER),   &
                          ZOB,ZSRH,ZSRL
!
!  -- Check if NFHILM exceeds design limit of 301 (for lateral maximal distance of
!     10 km using 50-per-decade filters)
!
      IF (NHFILM>NHFILM_MAX) WRITE (*,'(A,/A)')  &
         '*** WARNING: model geometry exceeds design limit of 10 km for the high frequency module!', &
         '    Results may not be accurate!'
!
!  -- Parameter KRHO is required by routine ONE_D_KERNEL.
!     KRHO=1 means rho (or R in this routine) .ne. zero
!
      KRHO=1
!
!  -- Inititalizations
!
!     NLO, NHI, NRG, R1,  and E are determined by DEL,  RLO,  and RHI
!
      DEL=ALOG(10.)/50.
      NLO=INT(ALOG(RLO)/DEL+100.)-101
      IF (NLO<-100) NLO=-100
      NHI=INT(ALOG(RHI)/DEL+100.)-98
      IF (NHI>200) NHI=200
      NRG=NHI-NLO+1
      R1=EXP(NLO*DEL)
      E=EXP(DEL)
!
! -- I0G=I0F+NHI
!    NG=I0G+(NF-I0F)+abs(NLO)+1
!    NG=1001 is the dimension of the arrays INR, FC0,  and FC1
!
      NLIM=60; NF=600; I0F=401; I0G=701; INR=-1
!
      R=R1/E
      IGSH=INT(ALOG(R)/DEL+100.5)-100
!
      R_loop:  DO K=1,NRG   !  This loop computes the discreted values of
                            !  the Hankel integrals at discreted points of
                            !  R on a logarithmic scale determined by DEL.
                            !  All transforms are returned simultaneously.
!
         R=R*E
!
! --- The evaluation of IGSH has been moved to the top of the do loop
!     since the value of R may not be very accurate if it is large.
!        IGSH=INT(ALOG(R)/DEL+100.5)-100
!
         IGSH=IGSH+1
!
         X=E/R
         SUM0=(0.,0.);  SUM1=(0.,0.)
!
         Lower_convolution_loop:  DO I=1,NF
!
            IJ=I0F-I+1
!
! --- Calculation of convolution, arg. of kernel to zero
!
!   -- Check for limits to convolution, arg. of kernel to zero.
!      Exit if the IJ runs out of the filters range
!
            IF (IJ<1) THEN
!
!               WRITE (4,111) R
!
!**** EXIT lower convolution loop due to exhaustion of filters
!
               EXIT
!
            END IF
!
            X=X/E
            IG=I0G-IGSH-I+1
            IF (INR(IG)<0) THEN
               CALL ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS, &
                           KPRM,KRHO,KITG,KCHRG,NOB,NSR,ZOB,(ZSRH+ZSRL)/2., &
                           ZSRH,ZSRL,X,FKN)
               FC0(1:3,IG)=FKN(1:3)
               FC0(4:5,IG)=FKN(7:8)
               FC1(1:3,IG)=FKN(4:6)
               FC1(4:6,IG)=FKN(9:11)
               INR(IG)=1
            END IF
!
            DO J=1,5
               SDEL0(J)=FILT0(IJ)*FC0(J,IG)
               SDEL1(J)=FILT1(IJ)*FC1(J,IG)
               SUM0(J)=SUM0(J)+SDEL0(J)
               SUM1(J)=SUM1(J)+SDEL1(J)
            END DO
            SDEL1(6)=FILT1(IJ)*FC1(6,IG)
            SUM1(6)=SUM1(6)+SDEL1(6)
!
            IF (I>NLIM) THEN
               DO J=1,5
!
! --- Use 1.E-28 so that its product with EPS is larger
!     than 1.E-38 to avoid possible problems on some machines
!
                  IF (ABS(SDEL0(J))>(1.E-28+ABS(SUM0(J)))*EPS) GOTO 50
                  IF (ABS(SDEL1(J))>(1.E-28+ABS(SUM1(J)))*EPS) GOTO 50
               END DO
               IF (ABS(SDEL1(6))>(1.E-28+ABS(SUM1(6)))*EPS) GOTO 50
!
!****   Proper EXIT of lower convolution loop upon convergence
!
               EXIT
!
            END IF
!
   50    END DO Lower_convolution_loop
!
         NC(K)=I
!
! --- Calculation of convolution, arg. of kernel to infinity
!
         X=1./R
!
         Upper_convolution_loop:  DO I=1,NF
!
            IJ=I0F+I
!
! --- Check for limits to convolution, arg. of kernel to infinity.
!     Exit if the IJ runs out of the filters range
!
            IF (IJ>NF) THEN
!
!               WRITE (4,222) R
!
!****   EXIT upper convolution loop due to exhaustion of filters
!
               EXIT
!
            END IF
!
            X=X*E
            IG=I0G-IGSH+I
            IF (INR(IG)<0) THEN
               CALL ONE_D_KERNEL(KEYG,KEMD,MLAYER,ZBND,LRYTH,HVK,KKH,KANIS,  &
                         KPRM,KRHO,KITG,KCHRG,NOB,NSR,ZOB,(ZSRH+ZSRL)/2.,    &
                         ZSRH,ZSRL,X,FKN)
               FC0(1:3,IG)=FKN(1:3)
               FC0(4:5,IG)=FKN(7:8)
               FC1(1:3,IG)=FKN(4:6)
               FC1(4:6,IG)=FKN(9:11)
               INR(IG)=1
            END IF
!
            DO J=1,5
               SDEL0(J)=FILT0(IJ)*FC0(J,IG)
               SDEL1(J)=FILT1(IJ)*FC1(J,IG)
               SUM0(J)=SUM0(J)+SDEL0(J)
               SUM1(J)=SUM1(J)+SDEL1(J)
            END DO
            SDEL1(6)=FILT1(IJ)*FC1(6,IG)
            SUM1(6)=SUM1(6)+SDEL1(6)
!
            DO J=1,5
               IF (ABS(SDEL0(J))>(1.E-28+ABS(SUM0(J)))*EPS) GOTO 100
               IF (ABS(SDEL1(J))>(1.E-28+ABS(SUM1(J)))*EPS) GOTO 100
            END DO
            IF (ABS(SDEL1(6))>(1.E-28+ABS(SUM1(6)))*EPS) GOTO 100
!
!****   Proper EXIT of upper convolution loop upon convergence
!
            EXIT
!
  100    END DO Upper_convolution_loop
!
         NC(K)=NC(K)+I
!
         HF(1:3,K)=SUM0(1:3)
         HF(7:8,K)=SUM0(4:5)
         HF(4:6,K)=SUM1(1:3)
         HF(9:11,K)=SUM1(4:6)
!
         RRG(K)=R
!
      END DO R_loop
!
      RETURN
!
!  111    FORMAT (1X,'Convolution truncated for argument of kernel ',
!       'function going towards zero',/,'for distance ',F11.3,' M')
!  222    FORMAT (1X,'Convolution truncated for argument of kernel ',
!     'function going towards infinity',/,'for distance ',F11.3,' M')
!
   END SUBROUTINE HFILH
!
!
!     B L O C K   D A T A   J 0 C O E F
!
!     BLOCK DATA J0COF CONTAINS THE FILTERCOEFFICIENTS OF THE
!     J0 TRANSFORM USED IN THE SUBROUTINE HFIL
!
!     50-per-decade filters for functions with opening angle of
!     analyticity of 0.1 pi (optimized).
!     Accuracy of the filter: 056E-08
!
      BLOCK DATA J0COF2
! ------
      REAL FILT0(600),J01(76),J02(76),J03(76),J04(72),   &
                J05(76),J06(76),J07(76),J08(72)
      EQUIVALENCE (FILT0(1),J01(1)),(FILT0(77),J02(1)),   &
            (FILT0(153),J03(1)),(FILT0(229),J04(1)),   &
            (FILT0(301),J05(1)),(FILT0(377),J06(1)),   &
            (FILT0(453),J07(1)),(FILT0(529),J08(1))
      COMMON /J0BLK2/ FILT0
! ----------
      DATA J01 /   &
       4.60517018E-10, 4.82220517E-10, 5.04946869E-10, 5.28744282E-10,   &
       5.53663232E-10, 5.79756577E-10, 6.07079662E-10, 6.35690445E-10,   &
       6.65649613E-10, 6.97020713E-10, 7.29870287E-10, 7.64268014E-10,   &
       8.00286856E-10, 8.38003213E-10, 8.77497088E-10, 9.18852252E-10,   &
       9.62156424E-10, 1.00750146E-09, 1.05498354E-09, 1.10470338E-09,   &
       1.15676645E-09, 1.21128317E-09, 1.26836919E-09, 1.32814559E-09,   &
       1.39073916E-09, 1.45628268E-09, 1.52491517E-09, 1.59678220E-09,   &
       1.67203623E-09, 1.75083687E-09, 1.83335127E-09, 1.91975445E-09,   &
       2.01022969E-09, 2.10496890E-09, 2.20417303E-09, 2.30805250E-09,   &
       2.41682767E-09, 2.53072925E-09, 2.64999884E-09, 2.77488944E-09,   &
       2.90566595E-09, 3.04260577E-09, 3.18599936E-09, 3.33615088E-09,   &
       3.49337883E-09, 3.65801670E-09, 3.83041372E-09, 4.01093555E-09,   &
       4.19996512E-09, 4.39790338E-09, 4.60517018E-09, 4.82220517E-09,   &
       5.04946869E-09, 5.28744282E-09, 5.53663232E-09, 5.79756577E-09,   &
       6.07079662E-09, 6.35690445E-09, 6.65649613E-09, 6.97020713E-09,   &
       7.29870287E-09, 7.64268014E-09, 8.00286856E-09, 8.38003213E-09,   &
       8.77497088E-09, 9.18852252E-09, 9.62156424E-09, 1.00750146E-08,   &
       1.05498354E-08, 1.10470338E-08, 1.15676645E-08, 1.21128317E-08,   &
       1.26836919E-08, 1.32814559E-08, 1.39073916E-08, 1.45628268E-08/
      DATA J02 /   &
       1.52491517E-08, 1.59678220E-08, 1.67203623E-08, 1.75083687E-08,   &
       1.83335127E-08, 1.91975445E-08, 2.01022969E-08, 2.10496890E-08,   &
       2.20417303E-08, 2.30805250E-08, 2.41682767E-08, 2.53072925E-08,   &
       2.64999884E-08, 2.77488944E-08, 2.90566595E-08, 3.04260577E-08,   &
       3.18599936E-08, 3.33615088E-08, 3.49337883E-08, 3.65801670E-08,   &
       3.83041372E-08, 4.01093555E-08, 4.19996512E-08, 4.39790338E-08,   &
       4.60517018E-08, 4.82220517E-08, 5.04946869E-08, 5.28744282E-08,   &
       5.53663232E-08, 5.79756577E-08, 6.07079662E-08, 6.35690445E-08,   &
       6.65649613E-08, 6.97020713E-08, 7.29870287E-08, 7.64268014E-08,   &
       8.00286856E-08, 8.38003213E-08, 8.77497088E-08, 9.18852252E-08,   &
       9.62156424E-08, 1.00750146E-07, 1.05498354E-07, 1.10470338E-07,   &
       1.15676645E-07, 1.21128317E-07, 1.26836919E-07, 1.32814559E-07,   &
       1.39073916E-07, 1.45628268E-07, 1.52491517E-07, 1.59678220E-07,   &
       1.67203623E-07, 1.75083687E-07, 1.83335127E-07, 1.91975445E-07,   &
       2.01022969E-07, 2.10496890E-07, 2.20417303E-07, 2.30805250E-07,   &
       2.41682767E-07, 2.53072925E-07, 2.64999884E-07, 2.77488944E-07,   &
       2.90566595E-07, 3.04260577E-07, 3.18599936E-07, 3.33615088E-07,   &
       3.49337883E-07, 3.65801670E-07, 3.83041372E-07, 4.01093555E-07,   &
       4.19996512E-07, 4.39790338E-07, 4.60517018E-07, 4.82220517E-07/
      DATA J03 /   &
       5.04946869E-07, 5.28744282E-07, 5.53663232E-07, 5.79756577E-07,   &
       6.07079662E-07, 6.35690445E-07, 6.65649613E-07, 6.97020713E-07,   &
       7.29870287E-07, 7.64268014E-07, 8.00286856E-07, 8.38003213E-07,   &
       8.77497088E-07, 9.18852252E-07, 9.62156424E-07, 1.00750146E-06,   &
       1.05498354E-06, 1.10470338E-06, 1.15676645E-06, 1.21128317E-06,   &
       1.26836919E-06, 1.32814559E-06, 1.39073916E-06, 1.45628268E-06,   &
       1.52491517E-06, 1.59678220E-06, 1.67203623E-06, 1.75083687E-06,   &
       1.83335127E-06, 1.91975445E-06, 2.01022969E-06, 2.10496890E-06,   &
       2.20417303E-06, 2.30805250E-06, 2.41682767E-06, 2.53072924E-06,   &
       2.64999884E-06, 2.77488944E-06, 2.90566595E-06, 3.04260576E-06,   &
       3.18599935E-06, 3.33615088E-06, 3.49337882E-06, 3.65801670E-06,   &
       3.83041371E-06, 4.01093555E-06, 4.19996511E-06, 4.39790337E-06,   &
       4.60517017E-06, 4.82220515E-06, 5.04946868E-06, 5.28744280E-06,   &
       5.53663230E-06, 5.79756574E-06, 6.07079660E-06, 6.35690442E-06,   &
       6.65649610E-06, 6.97020709E-06, 7.29870283E-06, 7.64268009E-06,   &
       8.00286850E-06, 8.38003206E-06, 8.77497080E-06, 9.18852243E-06,   &
       9.62156414E-06, 1.00750145E-05, 1.05498353E-05, 1.10470337E-05,   &
       1.15676643E-05, 1.21128315E-05, 1.26836917E-05, 1.32814556E-05,   &
       1.39073913E-05, 1.45628264E-05, 1.52491513E-05, 1.59678216E-05/
      DATA J04 /   &
       1.67203618E-05, 1.75083681E-05, 1.83335120E-05, 1.91975437E-05,   &
       2.01022960E-05, 2.10496879E-05, 2.20417290E-05, 2.30805236E-05,   &
       2.41682750E-05, 2.53072905E-05, 2.64999862E-05, 2.77488919E-05,   &
       2.90566566E-05, 3.04260543E-05, 3.18599898E-05, 3.33615044E-05,   &
       3.49337833E-05, 3.65801612E-05, 3.83041305E-05, 4.01093479E-05,   &
       4.19996425E-05, 4.39790238E-05, 4.60516903E-05, 4.82220384E-05,   &
       5.04946718E-05, 5.28744108E-05, 5.53663032E-05, 5.79756347E-05,   &
       6.07079399E-05, 6.35690143E-05, 6.65649265E-05, 6.97020314E-05,   &
       7.29869829E-05, 7.64267488E-05, 8.00286252E-05, 8.38002520E-05,   &
       8.77496292E-05, 9.18851337E-05, 9.62155374E-05, 1.00750025E-04,   &
       1.05498216E-04, 1.10470179E-04, 1.15676462E-04, 1.21128108E-04,   &
       1.26836678E-04, 1.32814283E-04, 1.39073599E-04, 1.45627904E-04,   &
       1.52491099E-04, 1.59677741E-04, 1.67203072E-04, 1.75083054E-04,   &
       1.83334401E-04, 1.91974611E-04, 2.01022012E-04, 2.10495791E-04,   &
       2.20416041E-04, 2.30803801E-04, 2.41681103E-04, 2.53071014E-04,   &
       2.64997690E-04, 2.77486425E-04, 2.90563703E-04, 3.04257256E-04,   &
       3.18596124E-04, 3.33610711E-04, 3.49332857E-04, 3.65795900E-04,   &
       3.83034747E-04, 4.01085949E-04, 4.19987779E-04, 4.39780311E-04/
      DATA J05 /   &
       4.60505505E-04, 4.82207298E-04, 5.04931692E-04, 5.28726857E-04,   &
       5.53643225E-04, 5.79733606E-04, 6.07053288E-04, 6.35660164E-04,   &
       6.65614845E-04, 6.96980794E-04, 7.29824454E-04, 7.64215391E-04,   &
       8.00226436E-04, 8.37933843E-04, 8.77417440E-04, 9.18760804E-04,   &
       9.62051428E-04, 1.00738091E-03, 1.05484513E-03, 1.10454447E-03,   &
       1.15658399E-03, 1.21107368E-03, 1.26812866E-03, 1.32786943E-03,   &
       1.39042209E-03, 1.45591863E-03, 1.52449719E-03, 1.59630230E-03,   &
       1.67148523E-03, 1.75020425E-03, 1.83262493E-03, 1.91892051E-03,   &
       2.00927221E-03, 2.10386957E-03, 2.20291084E-03, 2.30660334E-03,   &
       2.41516383E-03, 2.52881894E-03, 2.64780555E-03, 2.77237126E-03,   &
       2.90277475E-03, 3.03928631E-03, 3.18218821E-03, 3.33177523E-03,   &
       3.48835506E-03, 3.65224884E-03, 3.82379158E-03, 4.00333264E-03,   &
       4.19123621E-03, 4.38788176E-03, 4.59366445E-03, 4.80899561E-03,   &
       5.03430310E-03, 5.27003166E-03, 5.51664322E-03, 5.77461721E-03,   &
       6.04445067E-03, 6.32665842E-03, 6.62177303E-03, 6.93034469E-03,   &
       7.25294099E-03, 7.59014644E-03, 7.94256181E-03, 8.31080334E-03,   &
       8.69550146E-03, 9.09729939E-03, 9.51685123E-03, 9.95481962E-03,   &
       1.04118729E-02, 1.08886819E-02, 1.13859152E-02, 1.19042351E-02,   &
       1.24442908E-02, 1.30067124E-02, 1.35921022E-02, 1.42010252E-02/
      DATA J06 /   &
       1.48339985E-02, 1.54914777E-02, 1.61738426E-02, 1.68813792E-02,   &
       1.76142602E-02, 1.83725219E-02, 1.91560376E-02, 1.99644872E-02,   &
       2.07973230E-02, 2.16537299E-02, 2.25325805E-02, 2.34323846E-02,   &
       2.43512313E-02, 2.52867241E-02, 2.62359084E-02, 2.71951897E-02,   &
       2.81602430E-02, 2.91259114E-02, 3.00860955E-02, 3.10336309E-02,   &
       3.19601552E-02, 3.28559646E-02, 3.37098600E-02, 3.45089847E-02,   &
       3.52386557E-02, 3.58821911E-02, 3.64207388E-02, 3.68331127E-02,   &
       3.70956440E-02, 3.71820590E-02, 3.70633982E-02, 3.67079922E-02,   &
       3.60815204E-02, 3.51471762E-02, 3.38659754E-02, 3.21972468E-02,   &
       3.00993519E-02, 2.75306906E-02, 2.44510522E-02, 2.08233821E-02,   &
       1.66160357E-02, 1.18055894E-02, 6.38027816E-03, 3.44107043E-04,   &
      -6.27833813E-03,-1.34364048E-02,-2.10473034E-02,-2.89896424E-02,   &
      -3.70968931E-02,-4.51512855E-02,-5.28788597E-02,-5.99466655E-02,   &
      -6.59634116E-02,-7.04851845E-02,-7.30281623E-02,-7.30904525E-02,   &
      -7.01852087E-02,-6.38868657E-02,-5.38915096E-02,-4.00908342E-02,   &
      -2.26566059E-02,-2.12886922E-03, 2.05037869E-02, 4.37494922E-02,   &
       6.56077059E-02, 8.36421404E-02, 9.51627029E-02, 9.75421306E-02,   &
       8.86770131E-02, 6.75717609E-02, 3.49752624E-02,-6.06439764E-03,   &
      -4.99310726E-02,-8.87120321E-02,-1.13257605E-01,-1.15162686E-01/
      DATA J07 /   &
      -8.95365553E-02,-3.79967711E-02, 2.91956022E-02, 9.33401582E-02,   &
       1.31238982E-01, 1.23296106E-01, 6.40923137E-02,-2.90651232E-02,   &
      -1.16218757E-01,-1.48978992E-01,-9.78740373E-02, 1.96927747E-02,   &
       1.33529906E-01, 1.56211304E-01, 5.26261838E-02,-1.06190954E-01,   &
      -1.74441242E-01,-6.40940077E-02, 1.27718733E-01, 1.75015876E-01,   &
      -9.43249426E-03,-1.92356894E-01,-8.51707929E-02, 1.72634174E-01,   &
       1.29946071E-01,-1.68973353E-01,-1.27072974E-01, 2.02695179E-01,   &
       5.59069073E-02,-2.35399765E-01, 1.03760280E-01, 1.50478122E-01,   &
      -2.59977858E-01, 1.64370256E-01, 2.30311231E-02,-1.75973825E-01,   &
       2.42721193E-01,-2.36689502E-01, 1.93948395E-01,-1.44015408E-01,   &
       1.01803808E-01,-7.10544426E-02, 5.00485543E-02,-3.56659226E-02,   &
       2.53377819E-02,-1.75701668E-02, 1.17221735E-02,-7.53086182E-03,   &
       4.73448763E-03,-2.96940386E-03, 1.87193402E-03,-1.18208479E-03,   &
       7.45850501E-04,-4.70556798E-04, 2.96908215E-04,-1.87335624E-04,   &
       1.18200714E-04,-7.45797008E-05, 4.70565083E-05,-2.96907435E-05,   &
       1.87335570E-05,-1.18200753E-05, 7.45796333E-06,-4.70565673E-06,   &
       2.96906868E-06,-1.87335569E-06, 1.18200753E-06,-7.45796332E-07,   &
       4.70565673E-07,-2.96906868E-07, 1.87335569E-07,-1.18200753E-07,   &
       7.45796332E-08,-4.70565673E-08, 2.96906868E-08,-1.87335569E-08/
      DATA J08 /   &
       1.18200753E-08,-7.45796332E-09, 4.70565673E-09,-2.96906868E-09,   &
       1.87335569E-09,-1.18200753E-09, 7.45796332E-10,-4.70565673E-10,   &
       2.96906868E-10,-1.87335569E-10, 1.18200753E-10,-7.45796332E-11,   &
       4.70565673E-11,-2.96906868E-11, 1.87335569E-11,-1.18200753E-11,   &
       7.45796332E-12,-4.70565673E-12, 2.96906868E-12,-1.87335569E-12,   &
       1.18200753E-12,-7.45796332E-13, 4.70565673E-13,-2.96906868E-13,   &
       1.87335569E-13,-1.18200753E-13, 7.45796332E-14,-4.70565673E-14,   &
       2.96906868E-14,-1.87335569E-14, 1.18200753E-14,-7.45796332E-15,   &
       4.70565673E-15,-2.96906868E-15, 1.87335569E-15,-1.18200753E-15,   &
       7.45796332E-16,-4.70565673E-16, 2.96906868E-16,-1.87335569E-16,   &
       1.18200753E-16,-7.45796332E-17, 4.70565673E-17,-2.96906868E-17,   &
       1.87335569E-17,-1.18200753E-17, 7.45796332E-18,-4.70565673E-18,   &
       2.96906868E-18,-1.87335569E-18, 1.18200753E-18,-7.45796332E-19,   &
       4.70565673E-19,-2.96906868E-19, 1.87335569E-19,-1.18200753E-19,   &
       7.45796332E-20,-4.70565673E-20, 2.96906868E-20,-1.87335569E-20,   &
       1.18200753E-20,-7.45796332E-21, 4.70565673E-21,-2.96906868E-21,   &
       1.87335569E-21,-1.18200753E-21, 7.45796332E-22,-4.70565673E-22,   &
       2.96906868E-22,-1.87335569E-22, 1.18200753E-22,-7.45796332E-23/

   END BLOCK DATA J0COF2
!
!
!     B L O C K   D A T A   J 1 C O E F
!
!     BLOCK DATA J0COF CONTAINS THE FILTERCOEFFICIENTS OF THE
!     J1 TRANSFORM USED IN THE SUBROUTINE HFIL
!
!     50-per-decade filters for functions with opening angle of
!     analyticity of 0.1 pi (optimized).
!     Accuracy of the filter: 056E-08
!
   BLOCK DATA J1COF2
! ------
      REAL FILT1(600),J11(76),J12(76),J13(76),J14(72),   &
                      J15(76),J16(76),J17(76),J18(72)
      EQUIVALENCE (FILT1(1),J11(1)),(FILT1(77),J12(1)),   &
                  (FILT1(153),J13(1)),(FILT1(229),J14(1)),   &
                  (FILT1(301),J15(1)),(FILT1(377),J16(1)),   &
                  (FILT1(453),J17(1)),(FILT1(529),J18(1))
      COMMON /J1BLK2/ FILT1
! ----------
      DATA J11 /   &
       2.30258509E-18, 2.52473435E-18, 2.76831616E-18, 3.03539831E-18,   &
       3.32824807E-18, 3.64935144E-18, 4.00143428E-18, 4.38748544E-18,   &
       4.81078212E-18, 5.27491770E-18, 5.78383225E-18, 6.34184595E-18,   &
       6.95369581E-18, 7.62457584E-18, 8.36018116E-18, 9.16675636E-18,   &
       1.00511485E-17, 1.10208651E-17, 1.20841383E-17, 1.32499942E-17,   &
       1.45283297E-17, 1.59299968E-17, 1.74668941E-17, 1.91520686E-17,   &
       2.09998256E-17, 2.30258509E-17, 2.52473435E-17, 2.76831616E-17,   &
       3.03539831E-17, 3.32824807E-17, 3.64935144E-17, 4.00143428E-17,   &
       4.38748544E-17, 4.81078212E-17, 5.27491770E-17, 5.78383225E-17,   &
       6.34184595E-17, 6.95369581E-17, 7.62457584E-17, 8.36018116E-17,   &
       9.16675636E-17, 1.00511485E-16, 1.10208651E-16, 1.20841383E-16,   &
       1.32499942E-16, 1.45283297E-16, 1.59299968E-16, 1.74668941E-16,   &
       1.91520686E-16, 2.09998256E-16, 2.30258509E-16, 2.52473435E-16,   &
       2.76831616E-16, 3.03539831E-16, 3.32824807E-16, 3.64935144E-16,   &
       4.00143428E-16, 4.38748544E-16, 4.81078212E-16, 5.27491770E-16,   &
       5.78383225E-16, 6.34184595E-16, 6.95369581E-16, 7.62457584E-16,   &
       8.36018116E-16, 9.16675636E-16, 1.00511485E-15, 1.10208651E-15,   &
       1.20841383E-15, 1.32499942E-15, 1.45283297E-15, 1.59299968E-15,   &
       1.74668941E-15, 1.91520686E-15, 2.09998256E-15, 2.30258509E-15/
      DATA J12 /   &
       2.52473435E-15, 2.76831616E-15, 3.03539831E-15, 3.32824807E-15,   &
       3.64935144E-15, 4.00143428E-15, 4.38748544E-15, 4.81078212E-15,   &
       5.27491770E-15, 5.78383225E-15, 6.34184595E-15, 6.95369581E-15,   &
       7.62457584E-15, 8.36018116E-15, 9.16675636E-15, 1.00511485E-14,   &
       1.10208651E-14, 1.20841383E-14, 1.32499942E-14, 1.45283297E-14,   &
       1.59299968E-14, 1.74668941E-14, 1.91520686E-14, 2.09998256E-14,   &
       2.30258509E-14, 2.52473435E-14, 2.76831616E-14, 3.03539831E-14,   &
       3.32824807E-14, 3.64935144E-14, 4.00143428E-14, 4.38748544E-14,   &
       4.81078212E-14, 5.27491770E-14, 5.78383225E-14, 6.34184595E-14,   &
       6.95369581E-14, 7.62457584E-14, 8.36018116E-14, 9.16675636E-14,   &
       1.00511485E-13, 1.10208651E-13, 1.20841383E-13, 1.32499942E-13,   &
       1.45283297E-13, 1.59299968E-13, 1.74668941E-13, 1.91520686E-13,   &
       2.09998256E-13, 2.30258509E-13, 2.52473435E-13, 2.76831616E-13,   &
       3.03539831E-13, 3.32824807E-13, 3.64935144E-13, 4.00143428E-13,   &
       4.38748544E-13, 4.81078212E-13, 5.27491770E-13, 5.78383225E-13,   &
       6.34184595E-13, 6.95369581E-13, 7.62457584E-13, 8.36018116E-13,   &
       9.16675636E-13, 1.00511485E-12, 1.10208651E-12, 1.20841383E-12,   &
       1.32499942E-12, 1.45283297E-12, 1.59299968E-12, 1.74668941E-12,   &
       1.91520686E-12, 2.09998256E-12, 2.30258509E-12, 2.52473435E-12/
      DATA J13 /   &
       2.76831616E-12, 3.03539831E-12, 3.32824807E-12, 3.64935144E-12,   &
       4.00143428E-12, 4.38748544E-12, 4.81078212E-12, 5.27491770E-12,   &
       5.78383225E-12, 6.34184595E-12, 6.95369581E-12, 7.62457584E-12,   &
       8.36018116E-12, 9.16675636E-12, 1.00511485E-11, 1.10208651E-11,   &
       1.20841383E-11, 1.32499942E-11, 1.45283297E-11, 1.59299968E-11,   &
       1.74668941E-11, 1.91520686E-11, 2.09998256E-11, 2.30258509E-11,   &
       2.52473435E-11, 2.76831616E-11, 3.03539831E-11, 3.32824807E-11,   &
       3.64935144E-11, 4.00143428E-11, 4.38748544E-11, 4.81078212E-11,   &
       5.27491770E-11, 5.78383225E-11, 6.34184595E-11, 6.95369580E-11,   &
       7.62457583E-11, 8.36018115E-11, 9.16675635E-11, 1.00511485E-10,   &
       1.10208651E-10, 1.20841383E-10, 1.32499942E-10, 1.45283297E-10,   &
       1.59299968E-10, 1.74668941E-10, 1.91520686E-10, 2.09998256E-10,   &
       2.30258509E-10, 2.52473434E-10, 2.76831616E-10, 3.03539831E-10,   &
       3.32824806E-10, 3.64935143E-10, 4.00143427E-10, 4.38748543E-10,   &
       4.81078211E-10, 5.27491769E-10, 5.78383223E-10, 6.34184593E-10,   &
       6.95369578E-10, 7.62457580E-10, 8.36018112E-10, 9.16675631E-10,   &
       1.00511484E-09, 1.10208651E-09, 1.20841383E-09, 1.32499941E-09,   &
       1.45283296E-09, 1.59299967E-09, 1.74668940E-09, 1.91520684E-09,   &
       2.09998254E-09, 2.30258506E-09, 2.52473431E-09, 2.76831612E-09/
      DATA J14 /   &
       3.03539826E-09, 3.32824801E-09, 3.64935136E-09, 4.00143419E-09,   &
       4.38748534E-09, 4.81078200E-09, 5.27491755E-09, 5.78383207E-09,   &
       6.34184573E-09, 6.95369554E-09, 7.62457552E-09, 8.36018078E-09,   &
       9.16675590E-09, 1.00511479E-08, 1.10208645E-08, 1.20841375E-08,   &
       1.32499933E-08, 1.45283286E-08, 1.59299954E-08, 1.74668925E-08,   &
       1.91520666E-08, 2.09998232E-08, 2.30258480E-08, 2.52473400E-08,   &
       2.76831575E-08, 3.03539781E-08, 3.32824746E-08, 3.64935071E-08,   &
       4.00143341E-08, 4.38748440E-08, 4.81078087E-08, 5.27491619E-08,   &
       5.78383043E-08, 6.34184377E-08, 6.95369318E-08, 7.62457268E-08,   &
       8.36017736E-08, 9.16675179E-08, 1.00511430E-07, 1.10208586E-07,   &
       1.20841304E-07, 1.32499847E-07, 1.45283183E-07, 1.59299830E-07,   &
       1.74668776E-07, 1.91520487E-07, 2.09998017E-07, 2.30258221E-07,   &
       2.52473089E-07, 2.76831200E-07, 3.03539331E-07, 3.32824205E-07,   &
       3.64934421E-07, 4.00142559E-07, 4.38747499E-07, 4.81076956E-07,   &
       5.27490260E-07, 5.78381409E-07, 6.34182412E-07, 6.95366956E-07,   &
       7.62454428E-07, 8.36014322E-07, 9.16671074E-07, 1.00510936E-06,   &
       1.10207992E-06, 1.20840591E-06, 1.32498989E-06, 1.45282152E-06,   &
       1.59298590E-06, 1.74667285E-06, 1.91518695E-06, 2.09995862E-06/
      DATA J15 /   &
       2.30255631E-06, 2.52469974E-06, 2.76827456E-06, 3.03534829E-06,   &
       3.32818793E-06, 3.64927914E-06, 4.00134736E-06, 4.38738094E-06,   &
       4.81065648E-06, 5.27476665E-06, 5.78365065E-06, 6.34162762E-06,   &
       6.95343331E-06, 7.62426025E-06, 8.35980174E-06, 9.16630019E-06,   &
       1.00506000E-05, 1.10202058E-05, 1.20833456E-05, 1.32490412E-05,   &
       1.45271839E-05, 1.59286192E-05, 1.74652380E-05, 1.91500774E-05,   &
       2.09974317E-05, 2.30229728E-05, 2.52438832E-05, 2.76790015E-05,   &
       3.03489816E-05, 3.32764675E-05, 3.64862850E-05, 4.00056513E-05,   &
       4.38644050E-05, 4.80952584E-05, 5.27340733E-05, 5.78201640E-05,   &
       6.33966284E-05, 6.95107116E-05, 7.62142035E-05, 8.35638748E-05,   &
       9.16219542E-05, 1.00456651E-04, 1.10142728E-04, 1.20762128E-04,   &
       1.32404658E-04, 1.45168743E-04, 1.59162247E-04, 1.74503369E-04,   &
       1.91321630E-04, 2.09758946E-04, 2.29970806E-04, 2.52127553E-04,   &
       2.76415794E-04, 3.03039927E-04, 3.32223821E-04, 3.64212642E-04,   &
       3.99274845E-04, 4.37704351E-04, 4.79822912E-04, 5.25982694E-04,   &
       5.76569083E-04, 6.32003737E-04, 6.92747904E-04, 7.59306017E-04,   &
       8.32229604E-04, 9.12121507E-04, 9.99640457E-04, 1.09550600E-03,   &
       1.20050384E-03, 1.31549152E-03, 1.44140461E-03, 1.57926325E-03,   &
       1.73017919E-03, 1.89536325E-03, 2.07613328E-03, 2.27392245E-03/
      DATA J16 /   &
       2.49028813E-03, 2.72692095E-03, 2.98565437E-03, 3.26847437E-03,   &
       3.57752939E-03, 3.91514019E-03, 4.28380958E-03, 4.68623176E-03,   &
       5.12530094E-03, 5.60411891E-03, 6.12600106E-03, 6.69448033E-03,   &
       7.31330839E-03, 7.98645318E-03, 8.71809182E-03, 9.51259761E-03,   &
       1.03745198E-02, 1.13085539E-02, 1.23195017E-02, 1.34122165E-02,   &
       1.45915325E-02, 1.58621751E-02, 1.72286459E-02, 1.86950815E-02,   &
       2.02650784E-02, 2.19414796E-02, 2.37261172E-02, 2.56195033E-02,   &
       2.76204632E-02, 2.97257032E-02, 3.19293069E-02, 3.42221513E-02,   &
       3.65912412E-02, 3.90189554E-02, 4.14822072E-02, 4.39515238E-02,   &
       4.63900585E-02, 4.87525553E-02, 5.09843050E-02, 5.30201419E-02,   &
       5.47835576E-02, 5.61860319E-02, 5.71267155E-02, 5.74926379E-02,   &
       5.71596563E-02, 5.59944121E-02, 5.38576081E-02, 5.06089630E-02,   &
       4.61142310E-02, 4.02546797E-02, 3.29393758E-02, 2.41205275E-02,   &
       1.38119230E-02, 2.11017094E-03,-1.07820632E-02,-2.45323484E-02,   &
      -3.86567852E-02,-5.25039734E-02,-6.52496779E-02,-7.59086262E-02,   &
      -8.33710480E-02,-8.64720931E-02,-8.41014913E-02,-7.53579184E-02,   &
      -5.97465042E-02,-3.74078185E-02,-9.35194375E-03, 2.23476721E-02,   &
       5.44667035E-02, 8.27324429E-02, 1.02205384E-01, 1.08009484E-01,   &
       9.64214846E-02, 6.62185168E-02, 2.00199394E-02,-3.48308154E-02/
      DATA J17 /   &
      -8.64498513E-02,-1.20266502E-01,-1.22852465E-01,-8.73164392E-02,   &
      -1.87454417E-02, 6.30026603E-02, 1.26367652E-01, 1.39041623E-01,   &
       8.51536602E-02,-1.86851784E-02,-1.20647421E-01,-1.54988583E-01,   &
      -8.53357097E-02, 5.42088071E-02, 1.60774254E-01, 1.32709510E-01,   &
      -2.60237018E-02,-1.69518174E-01,-1.30111549E-01, 7.31795405E-02,   &
       1.92473002E-01, 4.04161015E-02,-1.84470017E-01,-1.11036608E-01,   &
       1.68793258E-01, 1.32176928E-01,-1.82955230E-01,-1.00285243E-01,   &
       2.26406849E-01,-1.80287971E-02,-2.14944458E-01, 1.98547698E-01,   &
       1.53007645E-02,-2.17036005E-01, 2.79610498E-01,-2.15027208E-01,   &
       9.93616663E-02, 3.45980499E-03,-6.70269908E-02, 9.27734596E-02,   &
      -9.29901615E-02, 7.99912686E-02,-6.23721951E-02, 4.50807177E-02,   &
      -3.05435474E-02, 1.96162742E-02,-1.21638751E-02, 7.47164224E-03,   &
      -4.64145230E-03, 2.92310770E-03,-1.84788664E-03, 1.16608029E-03,   &
      -7.35473240E-04, 4.64060005E-04,-2.92802409E-04, 1.84744007E-04,   &
      -1.16565588E-04, 7.35478527E-05,-4.64055278E-05, 2.92799363E-05,   &
      -1.84743780E-05, 1.16565443E-05,-7.35478219E-06, 4.64055383E-06,   &
      -2.92799152E-06, 1.84743775E-06,-1.16565442E-06, 7.35478216E-07,   &
      -4.64055382E-07, 2.92799151E-07,-1.84743775E-07, 1.16565442E-07,   &
      -7.35478216E-08, 4.64055382E-08,-2.92799151E-08, 1.84743775E-08/
      DATA J18 /   &
      -1.16565442E-08, 7.35478216E-09,-4.64055382E-09, 2.92799151E-09,   &
      -1.84743775E-09, 1.16565442E-09,-7.35478216E-10, 4.64055382E-10,   &
      -2.92799151E-10, 1.84743775E-10,-1.16565442E-10, 7.35478216E-11,   &
      -4.64055382E-11, 2.92799151E-11,-1.84743775E-11, 1.16565442E-11,   &
      -7.35478216E-12, 4.64055382E-12,-2.92799151E-12, 1.84743775E-12,   &
      -1.16565442E-12, 7.35478216E-13,-4.64055382E-13, 2.92799151E-13,   &
      -1.84743775E-13, 1.16565442E-13,-7.35478216E-14, 4.64055382E-14,   &
      -2.92799151E-14, 1.84743775E-14,-1.16565442E-14, 7.35478216E-15,   &
      -4.64055382E-15, 2.92799151E-15,-1.84743775E-15, 1.16565442E-15,   &
      -7.35478216E-16, 4.64055382E-16,-2.92799151E-16, 1.84743775E-16,   &
      -1.16565442E-16, 7.35478216E-17,-4.64055382E-17, 2.92799151E-17,   &
      -1.84743775E-17, 1.16565442E-17,-7.35478216E-18, 4.64055382E-18,   &
      -2.92799151E-18, 1.84743775E-18,-1.16565442E-18, 7.35478216E-19,   &
      -4.64055382E-19, 2.92799151E-19,-1.84743775E-19, 1.16565442E-19,   &
      -7.35478216E-20, 4.64055382E-20,-2.92799151E-20, 1.84743775E-20,   &
      -1.16565442E-20, 7.35478216E-21,-4.64055382E-21, 2.92799151E-21,   &
      -1.84743775E-21, 1.16565442E-21,-7.35478216E-22, 4.64055382E-22,   &
      -2.92799151E-22, 1.84743775E-22,-1.16565442E-22, 7.35478216E-23/
!
   END BLOCK DATA J1COF2
!
!
   SUBROUTINE PRINT_FD(NW,PRFL,M_RX,NFRQ,NTX_EVENT,N_RX,SOURCE_TYPE,SURVEY_TYPE,FREQ,   &
                       SUB_RX_MAX,SUB_BIPOLE,RX_X,RX_Y,RX_Z,N_SIDE,NCRD,             &
                       RXOE,RXON,RXOZ,                                               &
                       RX_TYPE_INDEX,TX_CRDX,TX_CRDY,TX_CRDZ,MD_ANGLE,DO3D,          &
                       HPX,HPY,HPZ,VOLTP,                                &
                       HSX,HSY,HSZ,VOLTS)
!
!****  Print the frequency domain results in files suitable for
!      plotting
!
!  ** Internal computational coordinates X, Y, and Z are switched back to
!     I/O coordinates of East, North, and Vertical in printing.  Note that
!     signs for the vertical components are unchanged.
!
!
!   Input parameters:
!
!     NW:
!     PRFL:
!     M_RX:   Integer,  maximal number of receiver sites.
!     NFRQ:   Integer,  number of frequencies.
!     NTX_EVENT:  Integer,  number of excitations.
!     N_RX:   Integer N_RX(NTX_EVENT),  number of receiver sites.
!     CS_TYPE:   Integer,  type of excitation and configuration.  See
!             documentation "MARCO.DOC" for description.
!     FREQ:   Real FREQ(NFRQ), array for the frequencies.
!     RX_X,RX_Y,RX_Z:  Real RX_X(M_RX,NTX_EVENT), RX_Y(M_RX,NTX_EVENT),
!             RX_Z(RCP,NTX_EVENT),  receiver sites coordinates in the x, y,
!             and z-directions for the receiver sites,  respectively.
!     TR_OFF_X:    Real,  transmitter-receiver separation for moving current
!             loops or moving magnetic dipoles (CS_TYPE=6, 7, or 8).
!     TSRY:
!     TR_OFF_Z:    Real,  transmitter-receiver eleviation differentce for
!             moving current loops or moving magnetic dipoles
!             (CS_TYPE=6, 7, or 8) as in airborne or downhole measurements.
!     N_SIDE:
!     NCRD:
!     TX_CRDX, TX_CRDY, TX_CRDZ:   Real TX_CRDX(NCRD,NTX_EVENT),
!     TX_CRDY(NCRD,NTX_EVENT), TX_CRDZ(NCRD,NTX_EVENT):
!             coordinates of electrodes (the end points of current bipoles
!             or loop corners) or the center coordinates of a current loop
!             or a magnetic dipole for all the excitations.   For various
!             values of CS_TYPE,  the four elements for the first index of
!             TX_CRDX, TX_CRDY,  and TX_CRDZ contain the following information:
!             CS_TYPE =2, and 3:  the first two elements of TX_CRDX etc.
!                      represent the two electrodes of the bipoles;
!                     =4: the arrays TX_CRDX etc. show the coordinates
!                         of the four corner of the rectangular loop.
!                     =5, and 6: the first elements of TX_CRDX etc. contain the
!                         coordinates of the centre of the circular
!                         loop;  and
!                     =7, 8, and 9: the first elements of TX_CRDX etc.
!                         contain the coordinates of the centre of the
!                         magnetic dipole.
!     RAD:    Real,  radius of the current loop as with CS_TYPE=5 and 6.
!     MD_ANGLE: Real MD_ANGLE(2,NTX_EVENT),  orientations of arbitrary magnetic
!             dipoles for ksrc=9 for each excitation.  For each excitation
!             the two elements of MD_ANGLE(1:2,*) contains the dip angle
!             MD_ANGLE(1,*) and the azimuthal angle MD_ANGLE(2,*) of the
!             magnetic dipole.  The dip angle is the angle from the negative
!             z-axis, i.e., from the axis up in the air (assuming the z axis
!             is pointing downwards).  The azimuthal angle is the angle from
!             the north,  the x-axis.  Thus for a vertical magnetic dipole
!             MD_ANGLE(1,*)=0 for pointing up air and MD_ANGLE(1,*)=180 for
!             pointing down.  A horizontal magnetic dipole pointing north will
!             have MD_ANGLE(1,*)=90 and MD_ANGLE(2,*)=0,  and a horizontal
!             magnetic dipole pointing east will have MD_ANGLE(1,*)=90 and
!             MD_ANGLE(2,*)=90.
!     HPX, HPY, HPZ, VOLTP:
!     HSX, HSY, HSZ, VOLTS:
!
!   Output parameter:  None.  This routine produces output files only.
!
!
!   Remarks:
!
!     The scaling factor has been considered in writing the
!     EM fields in the temporary files.  The values for the
!     frequencies have been back-transformed, too.
!
!
!**** Called by:  main
!
!**** Calls:      none
!
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN) :: DO3D,PRFL,SOURCE_TYPE,SURVEY_TYPE,M_RX,NFRQ,NTX_EVENT,    &
                          NCRD,NW,SUB_RX_MAX,SUB_BIPOLE,RX_TYPE_INDEX(M_RX,NTX_EVENT)
   COMPLEX, INTENT(IN) :: HPX(M_RX,NTX_EVENT,NFRQ),HPY(M_RX,NTX_EVENT,NFRQ),   &
                          HPZ(M_RX,NTX_EVENT,NFRQ),HSX(M_RX,NTX_EVENT,NFRQ),   &
                          HSY(M_RX,NTX_EVENT,NFRQ),HSZ(M_RX,NTX_EVENT,NFRQ),   &
                          VOLTP(M_RX,NTX_EVENT,NFRQ),                       &
                          VOLTS(M_RX,NTX_EVENT,NFRQ)
   REAL, INTENT(IN) :: TX_CRDX(NCRD,NTX_EVENT),TX_CRDY(NCRD,NTX_EVENT),           &
                       TX_CRDZ(NCRD,NTX_EVENT),RX_X(SUB_RX_MAX,M_RX,NTX_EVENT),   &
                       RX_Y(SUB_RX_MAX,M_RX,NTX_EVENT),RX_Z(SUB_RX_MAX,M_RX,NTX_EVENT)
   REAL, INTENT(IN) :: MD_ANGLE(2,NTX_EVENT),FREQ(NFRQ),RXOE,RXON,RXOZ
   INTEGER, INTENT(IN) :: N_RX(NTX_EVENT),N_SIDE(NTX_EVENT)
!
   INTEGER ::  I,IEXCI,IFRQ,J
!
! --- Print results in sounding format
!
!  --- Total field
!
   IF (PRFL==0.OR.PRFL==2) THEN
!
! *** Note that PRFL=2 will print both format
!
      WRITE (NW,1000)
!
      Excitation_loop:  DO IEXCI=1,NTX_EVENT
!
         IF (SURVEY_TYPE/=2) THEN
!     -- Print transmitter info for multiple RX per transmitter
            IF (NTX_EVENT>1) THEN
               WRITE (NW,1010) IEXCI
            END IF
!
            IF (SOURCE_TYPE==1) WRITE (NW,1020)                                &
               (TX_CRDY(J,IEXCI),TX_CRDX(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
!               (TX_CRDX(J,IEXCI),TX_CRDY(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
            IF (SOURCE_TYPE==2) WRITE (NW,1030)                                &
               (TX_CRDY(J,IEXCI),TX_CRDX(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
!               (TX_CRDX(J,IEXCI),TX_CRDY(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
            IF (SOURCE_TYPE==3) WRITE (NW,1040) TX_CRDY(1,IEXCI),                  &
               TX_CRDX(1,IEXCI),TX_CRDZ(1,IEXCI),(MD_ANGLE(J,IEXCI),J=1,2)
!            IF (SOURCE_TYPE==3) WRITE (NW,1040) TX_CRDX(1,IEXCI),                  &
!               TX_CRDY(1,IEXCI),TX_CRDZ(1,IEXCI),(MD_ANGLE(J,IEXCI),J=1,2)
!
         END IF
!
         DO I=1,N_RX(IEXCI)
!
            IF (RX_TYPE_INDEX(I,IEXCI)==1) THEN
               WRITE (NW,1100) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI)
!               WRITE (NW,1100) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI)
               WRITE (NW,1120)
            ELSE IF (RX_TYPE_INDEX(I,IEXCI)==2) THEN
!      Finite loop receivers.     4 sides for the time being (first 4 triangle centres)
               WRITE (NW,1100) (RX_Y(1,I,IEXCI)+RX_Y(2,I,IEXCI)+       &
                                RX_Y(3,I,IEXCI)+RX_Y(4,I,IEXCI))/4.,   &
                               (RX_X(1,I,IEXCI)+RX_X(2,I,IEXCI)+       &
                                RX_X(3,I,IEXCI)+RX_X(4,I,IEXCI))/4.,   &
                               (RX_Z(1,I,IEXCI)+RX_Z(2,I,IEXCI)+       &
                                RX_Z(3,I,IEXCI)+RX_Z(4,I,IEXCI))/4.
            ELSE IF (RX_TYPE_INDEX(I,IEXCI)==3) THEN
!      Print the first and the last sub bipole electrodes
!               WRITE (NW,1150) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
!                               RX_X(SUB_BIPOLE,I,IEXCI),RX_Y(SUB_BIPOLE,I,IEXCI),  &
               WRITE (NW,1150) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
                               RX_Y(SUB_BIPOLE,I,IEXCI),RX_X(SUB_BIPOLE,I,IEXCI),  &
                               RX_Z(SUB_BIPOLE,I,IEXCI)
               WRITE (NW,1160)
            END IF
!
            DO IFRQ=1,NFRQ
!
               IF (RX_TYPE_INDEX(I,IEXCI)==1) THEN
!     --    Magnetic receivers
!                  WRITE (NW,1170) FREQ(IFRQ),HPX(I,IEXCI,IFRQ)+HSX(I,IEXCI,IFRQ),  &
!                                             HPY(I,IEXCI,IFRQ)+HSY(I,IEXCI,IFRQ),  &
                  WRITE (NW,1170) FREQ(IFRQ),HPY(I,IEXCI,IFRQ)+HSY(I,IEXCI,IFRQ),  &
                                             HPX(I,IEXCI,IFRQ)+HSX(I,IEXCI,IFRQ),  &
                                             HPZ(I,IEXCI,IFRQ)+HSZ(I,IEXCI,IFRQ)
               ELSE IF (RX_TYPE_INDEX(I,IEXCI)==2) THEN
!     --    Finite loop receivers.
 !                 WRITE (NW,1170) FREQ(IFRQ),HPY(I,IEXCI,IFRQ)+HSY(I,IEXCI,IFRQ),  &
 !                                            HPX(I,IEXCI,IFRQ)+HSX(I,IEXCI,IFRQ),  &
 !                                            HPZ(I,IEXCI,IFRQ)+HSZ(I,IEXCI,IFRQ)
                  WRITE (NW,1180) FREQ(IFRQ),VOLTP(I,IEXCI,IFRQ)+VOLTS(I,IEXCI,IFRQ)
               ELSE IF (RX_TYPE_INDEX(I,IEXCI)==3) THEN
!      --  Electric bipole receivers
                  WRITE (NW,1180) FREQ(IFRQ),VOLTP(I,IEXCI,IFRQ)+VOLTS(I,IEXCI,IFRQ)
               END IF
!
            END DO
!
            IF (DO3D==1) THEN
!
               WRITE (NW,'(/A)') '  Stripped 3D target responses:'
               DO IFRQ=1,NFRQ
!
                  IF (RX_TYPE_INDEX(I,IEXCI)==1) THEN
!        --    Magnetic receivers
!                     WRITE (NW,1170) FREQ(IFRQ),HSX(I,IEXCI,IFRQ),  &
!                                                HSY(I,IEXCI,IFRQ),  &
                     WRITE (NW,1170) FREQ(IFRQ),HSY(I,IEXCI,IFRQ),  &
                                                HSX(I,IEXCI,IFRQ),  &
                                                HSZ(I,IEXCI,IFRQ)
                  ELSE IF (RX_TYPE_INDEX(I,IEXCI)==2) THEN
!         --  Finite loop receivers.
   !                  WRITE (NW,1170) FREQ(IFRQ),HSY(I,IEXCI,IFRQ),  &
   !                                             HSX(I,IEXCI,IFRQ),  &
   !                                             HSZ(I,IEXCI,IFRQ)
                     WRITE (NW,1180) FREQ(IFRQ),VOLTS(I,IEXCI,IFRQ)
                  ELSE IF (RX_TYPE_INDEX(I,IEXCI)==3) THEN
!         --  Electric bipole receivers
                     WRITE (NW,1180) FREQ(IFRQ),VOLTS(I,IEXCI,IFRQ)
                  END IF
!
               END DO
!
            END IF
!
         END DO
!
      END DO Excitation_loop
!
   END IF
!
   IF (PRFL==1.OR.PRFL==2) THEN
!
! --- Print results in profile format
!
      WRITE (NW,2000)
!
      IF (SURVEY_TYPE==2) THEN
!   -- There is only one receiver per transmitter position for SURVEY_TYPE=2
!
         WRITE (NW,1060) RXOE,RXON,RXOZ
!
         DO IFRQ=1,NFRQ
!
            WRITE (NW,2100) FREQ(IFRQ)
!
            IF (RX_TYPE_INDEX(1,1)==1) THEN   !**  First receiver of the each event!!
!     --       Magnetic receivers
               WRITE (NW,2110)
            ELSE IF (RX_TYPE_INDEX(1,1)==2) THEN
!               not ready for finite loop receivers.  use similar design as in PRINT_TD
            ELSE IF (RX_TYPE_INDEX(1,1)==3) THEN
!     --       Electric bipole receivers
               WRITE (NW,2120)
            END IF
!
            DO IEXCI=1,NTX_EVENT
               I=1  ! only one receiver per transmitter
!
               IF (RX_TYPE_INDEX(I,IEXCI)==1) THEN
!     --    Magnetic receivers
!                  WRITE (NW,2170) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
!                                  HPX(I,IEXCI,IFRQ)+HSX(I,IEXCI,IFRQ),  &
!                                  HPY(I,IEXCI,IFRQ)+HSY(I,IEXCI,IFRQ),  &
                  WRITE (NW,2170) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
                                  HPY(I,IEXCI,IFRQ)+HSY(I,IEXCI,IFRQ),  &
                                  HPX(I,IEXCI,IFRQ)+HSX(I,IEXCI,IFRQ),  &
                                  HPZ(I,IEXCI,IFRQ)+HSZ(I,IEXCI,IFRQ)
               ELSE IF (RX_TYPE_INDEX(I,IEXCI)==2) THEN
!         not ready for finite loop receivers
               ELSE IF (RX_TYPE_INDEX(I,IEXCI)==3) THEN
!         Print the first and the last sub bipole electrodes
!                  WRITE (NW,2180) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
!                                  RX_X(SUB_BIPOLE,I,IEXCI),RX_Y(SUB_BIPOLE,I,IEXCI),  &
                  WRITE (NW,2180) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
                                  RX_Y(SUB_BIPOLE,I,IEXCI),RX_X(SUB_BIPOLE,I,IEXCI),  &
                                  RX_Z(SUB_BIPOLE,I,IEXCI),                           &
                                  VOLTP(I,IEXCI,IFRQ)+VOLTS(I,IEXCI,IFRQ)
               END IF
!
            END DO
!
            IF (DO3D==1) THEN
!
               WRITE (NW,'(/A)') '  Stripped 3D target responses:'
               DO IEXCI=1,NTX_EVENT
               I=1  ! only one receiver per transmitter
!
                  IF (RX_TYPE_INDEX(I,IEXCI)==1) THEN
!        --    Magnetic receivers
!                     WRITE (NW,2170) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
!                                     HSX(I,IEXCI,IFRQ),  &
!                                     HSY(I,IEXCI,IFRQ),  &
                     WRITE (NW,2170) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
                                     HSY(I,IEXCI,IFRQ),  &
                                     HSX(I,IEXCI,IFRQ),  &
                                     HSZ(I,IEXCI,IFRQ)
                  ELSE IF (RX_TYPE_INDEX(I,IEXCI)==2) THEN
!               not ready for finite loop receivers.  use similar design as in PRINT_TD
                  ELSE IF (RX_TYPE_INDEX(I,IEXCI)==3) THEN
!            Print the first and the last sub bipole electrodes
!                     WRITE (NW,2180) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
!                                     RX_X(SUB_BIPOLE,I,IEXCI),RX_Y(SUB_BIPOLE,I,IEXCI),  &
                     WRITE (NW,2180) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
                                     RX_Y(SUB_BIPOLE,I,IEXCI),RX_X(SUB_BIPOLE,I,IEXCI),  &
                                     RX_Z(SUB_BIPOLE,I,IEXCI),                           &
                                     VOLTS(I,IEXCI,IFRQ)
                  END IF
!
               END DO
!
            END IF
!
         END DO
!
      ELSE
!
         Excitation_loop2:  DO IEXCI=1,NTX_EVENT
!
            IF (NTX_EVENT>1) THEN
               WRITE (NW,1010) IEXCI
            END IF
!
            IF (SOURCE_TYPE==1) WRITE (NW,1020)                                &
               (TX_CRDY(J,IEXCI),TX_CRDX(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
!               (TX_CRDX(J,IEXCI),TX_CRDY(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
            IF (SOURCE_TYPE==2) WRITE (NW,1030)                                &
               (TX_CRDY(J,IEXCI),TX_CRDX(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
!               (TX_CRDX(J,IEXCI),TX_CRDY(J,IEXCI),TX_CRDZ(J,IEXCI),J=1,N_SIDE(IEXCI))
!            IF (SOURCE_TYPE==3) WRITE (NW,1040) TX_CRDX(1,IEXCI),                  &
!               TX_CRDY(1,IEXCI),TX_CRDZ(1,IEXCI),(MD_ANGLE(J,IEXCI),J=1,2)
            IF (SOURCE_TYPE==3) WRITE (NW,1040) TX_CRDY(1,IEXCI),                  &
               TX_CRDX(1,IEXCI),TX_CRDZ(1,IEXCI),(MD_ANGLE(J,IEXCI),J=1,2)
!
            DO IFRQ=1,NFRQ
!
               WRITE (NW,2100) FREQ(IFRQ)
!
               IF (RX_TYPE_INDEX(1,IEXCI)==1) THEN   !**  First receiver of the each event!!
!        --       Magnetic receivers
                  WRITE (NW,2110)
               ELSE IF (RX_TYPE_INDEX(1,IEXCI)==2) THEN
!               not ready for finite loop receivers.  use similar design as in PRINT_TD
               ELSE IF (RX_TYPE_INDEX(1,IEXCI)==3) THEN
!        --       Electric bipole receivers
                  WRITE (NW,2120)
               END IF
!
               DO I=1,N_RX(IEXCI)
!
                  IF (RX_TYPE_INDEX(I,IEXCI)==1) THEN
!        --    Magnetic receivers
!                     WRITE (NW,2170) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
!                                     HPX(I,IEXCI,IFRQ)+HSX(I,IEXCI,IFRQ),  &
!                                     HPY(I,IEXCI,IFRQ)+HSY(I,IEXCI,IFRQ),  &
                     WRITE (NW,2170) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
                                     HPY(I,IEXCI,IFRQ)+HSY(I,IEXCI,IFRQ),  &
                                     HPX(I,IEXCI,IFRQ)+HSX(I,IEXCI,IFRQ),  &
                                     HPZ(I,IEXCI,IFRQ)+HSZ(I,IEXCI,IFRQ)
                  ELSE IF (RX_TYPE_INDEX(I,IEXCI)==2) THEN
!               not ready for finite loop receivers.  use similar design as in PRINT_TD
                  ELSE IF (RX_TYPE_INDEX(I,IEXCI)==3) THEN
!            Print the first and the last sub bipole electrodes
!                     WRITE (NW,2180) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
!                                     RX_X(SUB_BIPOLE,I,IEXCI),RX_Y(SUB_BIPOLE,I,IEXCI),  &
                     WRITE (NW,2180) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
                                     RX_Y(SUB_BIPOLE,I,IEXCI),RX_X(SUB_BIPOLE,I,IEXCI),  &
                                     RX_Z(SUB_BIPOLE,I,IEXCI),                           &
                                     VOLTP(I,IEXCI,IFRQ)+VOLTS(I,IEXCI,IFRQ)
                  END IF
!
               END DO
!
               IF (DO3D==1) THEN
!
                  WRITE (NW,'(/A)') '  Stripped 3D target responses:'
                  DO I=1,N_RX(IEXCI)
!
                     IF (RX_TYPE_INDEX(I,IEXCI)==1) THEN
!           --    Magnetic receivers
!                        WRITE (NW,2170) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
!                                        HSX(I,IEXCI,IFRQ),  &
!                                        HSY(I,IEXCI,IFRQ),  &
                        WRITE (NW,2170) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),  &
                                        HSY(I,IEXCI,IFRQ),  &
                                        HSX(I,IEXCI,IFRQ),  &
                                        HSZ(I,IEXCI,IFRQ)
                     ELSE IF (RX_TYPE_INDEX(I,IEXCI)==2) THEN
!               not ready for finite loop receivers.  use similar design as in PRINT_TD
                     ELSE IF (RX_TYPE_INDEX(I,IEXCI)==3) THEN
!               Print the first and the last sub bipole electrodes
!                        WRITE (NW,2180) RX_X(1,I,IEXCI),RX_Y(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
!                                        RX_X(SUB_BIPOLE,I,IEXCI),RX_Y(SUB_BIPOLE,I,IEXCI),  &
                        WRITE (NW,2180) RX_Y(1,I,IEXCI),RX_X(1,I,IEXCI),RX_Z(1,I,IEXCI),    &
                                        RX_Y(SUB_BIPOLE,I,IEXCI),RX_X(SUB_BIPOLE,I,IEXCI),  &
                                        RX_Z(SUB_BIPOLE,I,IEXCI),                           &
                                        VOLTS(I,IEXCI,IFRQ)
                     END IF
!
                  END DO
!
               END IF
!
            END DO
!
         END DO Excitation_loop2
!
      END IF
!
   END IF
!
   RETURN
!
 1000 FORMAT (//'==========  COMPONENTS IN SOUNDING FORMAT  ==========')
 1010 FORMAT (//,'***** Event #',I3,' *****')
 1020 FORMAT (/'East, North, & Vertical of loop corners:',            &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,');',                &
              /'   (',3F12.2,')',';   (',3F12.2,')')
 1030 FORMAT (/'East, North, & Vertical of electrodes: (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')',       &
           ';'/'                                       (',3F12.2,')')
 1040 FORMAT (/'East, North, & Vertical of dipole:     (',3F12.2,')',       &
              /'Dipole orientation:',5X,'Dip angle:',F7.2,' Deg.;',     &
                               '  Azimuthal angle:',F7.2,' Deg.')
 1060 FORMAT (//,'   Transmitter-receiver offset in East, North and Vertical: ',  &
                /5X,3F12.2,                                                       &
                /'*** The following coordinates are receiver positions.')
 1100 FORMAT (//' --- Receiver (E N V):  (',3F12.2,')')
 1120 FORMAT (/' Magnetic field:',/'  Frequency        East-component        ',                &
            '     North-component     ','      Vertical-component   ',/' ')
 1150 FORMAT (//' --- Receiver (E N V):  (',3F12.2,')   to',      &
               /'                        (',3F12.2,')')
 1160 FORMAT (/'  Frequency               Voltage         ')
 1170 FORMAT (G12.4,1X,2G13.5,1X,2G13.5,1X,2G13.5)
 1180 FORMAT (G12.4,2X,2G15.6)
 2000 FORMAT (//'==========  COMPONENTS IN PROFILE FORMAT  ==========')
 2100 FORMAT (//' --- Frequency: ',G14.5)
 2110 FORMAT (/' Magnetic field:',     &
              /'    Easting   Northing   Vertical    East-component     ',    &
            '    North-component          Vertical-component   ',/' ')
 2120 FORMAT (/'   Easting   Northing   Vertical ',    &
               '   Easting   Northing   Vertical ',    &
               '         Voltage ')
 2170 FORMAT (3F10.1,3(1X,2(1PE12.4)))
 2180 FORMAT (3F10.1,2X,3F10.1,2X,2G15.6)
!
   END SUBROUTINE PRINT_FD









!  PARAMETER FILE

!  In COMPUTE_3D,  INTEGER, PARAMETER :: NZSRMAX=100  sets the maximum number of z' levels
!  avasilable for interpolation for 3D source wire.

! To map currents, go to compute_3d and print out E fields.  This requires specifying a lot
!  of magnetic dipole positions and then getting

!  E3X,E3Y,E3Z the scattered electric fields and
!  EPX,EPY,EPZ the primary fields


!  HISTORY
!
!
!     CHANGES to make Version 4.2.1 from Version 4.1
!     ----------------------------------------------
!
!    1. The extended AMIRA format output (.amx) has been added
!
!    2. CPU time is now written out
!
!    3. Internal cleaning re FDREAD & DO3D actions
!
!    4. Changes in TXCNVD to remove call to cubic spline routine when
!       insufficient data points are present.
!
!     CHANGES since Version 4.0:
!     --------------------------
!
!    1. The on-time electric fields are computed correctly through
!       changes to SET_FRQ, TDEM_3D and COSTRN.
!
!    2. Receiver channels can be input relative to any time origin
!       by specifying KRXW as a negative number.  (See RECORDS 4 below)
!       This requires a receiver channel time origin to be set.
!       This origin could be the start of the on-time, the top of the ramp
!       or any other relevant point.
!
!    3. The user can specify frequency ranges for time-domain transform
!       by setting TDFD = -1  (see DATA DESCRIPTION below)
!
!
!
!     CHANGES to create 4.0:     INPUT FORMAT HAS CHANGED !
!     ---------------------      ==========================
!
!    1. The input format has changed appreciably to make all P223D programs,
!       ground and airborne, as consistent as possible.   These changes
!       allow EMGUI2 to be used for setting up input files for Marco.
!
!    2. There are four survey_type options including separate specification
!       of transmitters and receiver groups or source and receivers moving
!       at constant offset.
!
!    3. Sources can include magnetic dipoles, loops and electric bipoles.
!       These can have arbitrary 3D paths as defined by straight line
!       segments between however many vertices the user cares to specify.
!
!    4. Receivers can include mixed groups of magnetic dipoles, loops and
!       electric dipoles.  In the electric dipole case, the program computes
!       voltage between electrodes instead of electric fields.
!
!    5. Time domain results can be computed for all the transmitter-receiver
!       configurations that used to be available only for the frequency domain
!       in older versions.
!
!    6. Arbitrary current waveforms are used in the time domain.  Delay times
!       are now referenced to the start of the waveform to remove ambiguity as
!       to the definition of signal turn-off
!
!    7. The tops of prisms are now specified in RLs.  As the prism top becomes
!        deeper, PRISM_TOP (RECORD 14) now increases negatively.  This requires
!    8   GND_LVL, the RL of the flat earth, to be specified in RECORD 10.
!
!    9. Transmitter and receiver positions are now expressed as RLs
!
!   10. Real world coordinates can be used for Eastings and Northings
!
!   11. The lithology definitions have changed (RECORD 11)
!
!   12. New output formatting in Marco.out for easier importation into
!       spreadsheets programs; eg, EXCEL.
!
!   13. Model symmetries are detected automatically.
!

!                FORTRAN 90 RELEASE HISTORY
!                --------------------------
!
!                Version 4.4.0   10 June, 2003
!                Version 4.3.0   24 January, 2003
!                Version 4.2.1   July, 2002
!                Version 4.1     July, 2001
!                Version 3.0P    July, 1999
!                Version 2.6.1   May, 1999
!                Version 2.6     June, 1998
!                Version 2.2     October, 1997
!                Version 2.1     May, 1997
!                Version 2.0     October, 1996
!                Version 1.2     February, 1996
!                Version 1.1     September, 1995
!

